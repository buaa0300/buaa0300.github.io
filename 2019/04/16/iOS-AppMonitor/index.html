<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="APM基础小记"><meta name="keywords" content="APM,Monitor"><meta name="author" content="南华coder"><meta name="copyright" content="南华coder"><title>APM基础小记 | 南华coder的空间</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、概述"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、APM是什么"><span class="toc-number">1.1.</span> <span class="toc-text">1、APM是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、APM工具"><span class="toc-number">1.2.</span> <span class="toc-text">2、APM工具</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、CPU使用率监控"><span class="toc-number">2.</span> <span class="toc-text">二、CPU使用率监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、Task和CPU"><span class="toc-number">2.1.</span> <span class="toc-text">1、Task和CPU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、Mach-Task和线程列表"><span class="toc-number">2.2.</span> <span class="toc-text">2、Mach Task和线程列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、单个线程信息结构"><span class="toc-number">2.3.</span> <span class="toc-text">3、单个线程信息结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、CPU-占用率计算"><span class="toc-number">2.4.</span> <span class="toc-text">4、CPU 占用率计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、为什么关注CPU使用率"><span class="toc-number">2.5.</span> <span class="toc-text">4、为什么关注CPU使用率</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、内存使用监控"><span class="toc-number">3.</span> <span class="toc-text">三、内存使用监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、内存"><span class="toc-number">3.1.</span> <span class="toc-text">1、内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、内存信息结构"><span class="toc-number">3.2.</span> <span class="toc-text">2、内存信息结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、内存信息获取"><span class="toc-number">3.3.</span> <span class="toc-text">3、内存信息获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、为什么关注内存使用"><span class="toc-number">3.4.</span> <span class="toc-text">4、为什么关注内存使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、FPS监控"><span class="toc-number">4.</span> <span class="toc-text">四、FPS监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、FPS和CADisplayLink"><span class="toc-number">4.1.</span> <span class="toc-text">1、FPS和CADisplayLink</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、FPS监控实现"><span class="toc-number">4.2.</span> <span class="toc-text">2、FPS监控实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、错信FPS值Case1"><span class="toc-number">4.3.</span> <span class="toc-text">3、错信FPS值Case1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、错信FPS值Case2"><span class="toc-number">4.4.</span> <span class="toc-text">4、错信FPS值Case2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、为什么关注FPS"><span class="toc-number">4.5.</span> <span class="toc-text">5、为什么关注FPS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五、卡顿监控"><span class="toc-number">5.</span> <span class="toc-text">五、卡顿监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、卡顿和RunLoop"><span class="toc-number">5.1.</span> <span class="toc-text">1、卡顿和RunLoop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、如何判断卡顿"><span class="toc-number">5.2.</span> <span class="toc-text">2、如何判断卡顿</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、卡顿监控的实现"><span class="toc-number">5.3.</span> <span class="toc-text">3、卡顿监控的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、卡顿时间阈值说明"><span class="toc-number">5.4.</span> <span class="toc-text">4、卡顿时间阈值说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、电量监控"><span class="toc-number">6.</span> <span class="toc-text">六、电量监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、手动查看电量"><span class="toc-number">6.1.</span> <span class="toc-text">1、手动查看电量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、电量监控方案1"><span class="toc-number">6.2.</span> <span class="toc-text">2、电量监控方案1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、电量监控方案2"><span class="toc-number">6.3.</span> <span class="toc-text">3、电量监控方案2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、耗电量大的操作"><span class="toc-number">6.4.</span> <span class="toc-text">4、耗电量大的操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#七、End"><span class="toc-number">7.</span> <span class="toc-text">七、End</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、总结"><span class="toc-number">7.1.</span> <span class="toc-text">1、总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、推荐的阅读资料"><span class="toc-number">7.2.</span> <span class="toc-text">2、推荐的阅读资料</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">南华coder</div><div class="author-info__description text-center">于无声处听惊雷,于无色处见繁花</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">49</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">南华coder的空间</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">APM基础小记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS进阶/">iOS进阶</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><em>天之道，损有余而补不足</em></p>
<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、APM是什么"><a href="#1、APM是什么" class="headerlink" title="1、APM是什么"></a>1、APM是什么</h5><ul>
<li>我们平时关注更多的是：需求是否delay，线上bug有多少？每个周期(比如2-3周) 关注下App的DAU、DNU、这些产品指标；但是团队中需要有人去关注App的技术质量指标：如Crash率、启动时间、安装包大小、核心页面的FPS、CPU使用率、内存占用、电量使用、卡顿情况等。</li>
<li>关注App线上质量，从技术维度来判断App是否健康。不健康的App表现为启动时间慢、页面卡顿、耗电量大等，这些App最终会失去用户；</li>
<li><strong>APM</strong> (Application Performance Manage)旨在建立APP的质量监控接入框架，方便App能快速集成，对性能监控项的异常数据进行采集和分析，输出相应问题的分析、定位与优化建议，从而帮助开发者开发出更高质量的应用。</li>
</ul>
<h5 id="2、APM工具"><a href="#2、APM工具" class="headerlink" title="2、APM工具"></a>2、APM工具</h5><ul>
<li>微信最近开源了微信的APM工具<a href="https://github.com/Tencent/matrix" target="_blank" rel="noopener">Matrix</a>, 提供了针对iOS、Android和macOS系统的性能监控方案。这个方案很全面，可以直接接入App，当然也可以吸收其优秀的技术细节，优化自己的APM工具。</li>
<li>本文不是介绍如何定制一个APM工具，而是介绍在APM监控中，比较重要的几个监控维度：<strong>CPU使用率、内存使用、FPS和卡顿监控</strong>。</li>
</ul>
<h4 id="二、CPU使用率监控"><a href="#二、CPU使用率监控" class="headerlink" title="二、CPU使用率监控"></a>二、CPU使用率监控</h4><h5 id="1、Task和CPU"><a href="#1、Task和CPU" class="headerlink" title="1、Task和CPU"></a>1、Task和CPU</h5><ul>
<li>任务（Task）是一种容器（Container）对象；虚拟内存空间和其他资源都是通过这个容器对象管理的，这些资源包括设备和其他句柄。</li>
<li>严格地说，Mach 的任务并不是其他操作系统中所谓的进程，因为 Mach 作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只是提供了最基本的实现。不过在 BSD 的模型中，这两个概念有1：1的简单映射，每一个 BSD 进程（也就是 OS X 进程）都在底层关联了一个 Mach 任务对象。</li>
<li>而每App运行，会对应一个<code>Mach Task</code>，Task下可能有多条线程同时执行任务，每个线程都是利用CPU的基本单位。<strong>要计算CPU 占用率，就需要获得当前<code>Mach Task</code>下，所有线程占用 CPU 的情况</strong>。</li>
</ul>
<h5 id="2、Mach-Task和线程列表"><a href="#2、Mach-Task和线程列表" class="headerlink" title="2、Mach Task和线程列表"></a>2、Mach Task和线程列表</h5><ul>
<li>一个<code>Mach Task</code>包含它的线程列表。内核提供了<code>task_threads</code> API 调用获取指定 task 的线程列表，然后可以通过<code>thread_info</code> API调用来查询指定线程的信息，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t task_threads</span><br><span class="line">(</span><br><span class="line">    task_t target_task,</span><br><span class="line">    thread_act_array_t *act_list,</span><br><span class="line">    mach_msg_type_number_t *act_listCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：<code>task_threads</code> 将<code>target_task</code> 任务中的所有线程保存在<code>act_list</code>数组中，<code>act_listCnt</code>表示线程个数：</p>
<h5 id="3、单个线程信息结构"><a href="#3、单个线程信息结构" class="headerlink" title="3、单个线程信息结构"></a>3、单个线程信息结构</h5><ul>
<li>iOS 的线程技术与Mac OS X类似，也是基于 Mach 线程技术实现的，可以通过<code>thread_info</code>这个API调用来查询指定线程的信息，thread_info结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t thread_info</span><br><span class="line">(</span><br><span class="line">    thread_act_t target_act,</span><br><span class="line">    thread_flavor_t flavor,  // 传入不同的宏定义获取不同的线程信息</span><br><span class="line">    thread_info_t thread_info_out,  // 查询到的线程信息</span><br><span class="line">    mach_msg_type_number_t *thread_info_outCnt  // 信息的大小</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>在 Mach 层中<code>thread_basic_info</code> 结构体封装了单个线程的基本信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct thread_basic_info &#123;</span><br><span class="line">  time_value_t    user_time;     // 用户运行时长</span><br><span class="line">  time_value_t    system_time;   // 系统运行时长</span><br><span class="line">  integer_t       cpu_usage;     // CPU 使用率</span><br><span class="line">  policy_t        policy;        // 调度策略</span><br><span class="line">  integer_t       run_state;     // 运行状态</span><br><span class="line">  integer_t       flags;         // 各种标记</span><br><span class="line">  integer_t       suspend_count; // 暂停线程的计数</span><br><span class="line">  integer_t       sleep_time;    // 休眠的时间</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="4、CPU-占用率计算"><a href="#4、CPU-占用率计算" class="headerlink" title="4、CPU 占用率计算"></a>4、CPU 占用率计算</h5><ul>
<li>先获取当前task中的线程总数(<strong>threadCount</strong>)和所有线程数组(<strong>threadList</strong>)</li>
<li>遍历这个数组来获取单个线程的基本信息。线程基本信息的结构是<strong>thread_basic_info_t</strong>，这里面有CPU的使用率(<strong>cpu_usage</strong>)字段，累计所有线程的CPU使用率就能获得整个APP的CPU使用率(cpuUsage)。</li>
<li>需要注意的是：cpuUsage是一个整数，想要获得百分比形式，需要除以TH_USAGE_SCALE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	Scale factor for usage field.</span><br><span class="line"> */</span><br><span class="line">#define TH_USAGE_SCALE	1000</span><br></pre></td></tr></table></figure>
<ul>
<li>可以定时，比如2s去计算一次CPU的使用率</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ (double)getCpuUsage &#123;</span><br><span class="line">    </span><br><span class="line">    kern_return_t           kr;</span><br><span class="line">    thread_array_t          threadList;         // 保存当前Mach task的线程列表</span><br><span class="line">    mach_msg_type_number_t  threadCount;        // 保存当前Mach task的线程个数</span><br><span class="line">    thread_info_data_t      threadInfo;         // 保存单个线程的信息列表</span><br><span class="line">    mach_msg_type_number_t  threadInfoCount;    // 保存当前线程的信息列表大小</span><br><span class="line">    thread_basic_info_t     threadBasicInfo;    // 线程的基本信息</span><br><span class="line">    </span><br><span class="line">    // 通过“task_threads”API调用获取指定 task 的线程列表</span><br><span class="line">    //  mach_task_self_，表示获取当前的 Mach task</span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;threadList, &amp;threadCount);</span><br><span class="line">    if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    double cpuUsage = 0;</span><br><span class="line">     // 遍历所有线程</span><br><span class="line">    for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        threadInfoCount = THREAD_INFO_MAX;</span><br><span class="line">        // 通过“thread_info”API调用来查询指定线程的信息</span><br><span class="line">        //  flavor参数传的是THREAD_BASIC_INFO，使用这个类型会返回线程的基本信息，</span><br><span class="line">        //  定义在 thread_basic_info_t 结构体，包含了用户和系统的运行时间、运行状态和调度优先级等</span><br><span class="line">        kr = thread_info(threadList[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount);</span><br><span class="line">        if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        threadBasicInfo = (thread_basic_info_t)threadInfo;</span><br><span class="line">        if (!(threadBasicInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            cpuUsage += threadBasicInfo-&gt;cpu_usage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 回收内存，防止内存泄漏</span><br><span class="line">    vm_deallocate(mach_task_self(), (vm_offset_t)threadList, threadCount * sizeof(thread_t));</span><br><span class="line">    </span><br><span class="line">    return cpuUsage / (double)TH_USAGE_SCALE * 100.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、为什么关注CPU使用率"><a href="#4、为什么关注CPU使用率" class="headerlink" title="4、为什么关注CPU使用率"></a>4、为什么关注CPU使用率</h5><ul>
<li>CPU的使用率是对APP使用CPU情况的评估，App频繁操作，CPU使用率一般在40%-50%；</li>
<li>假如CPU使用过高（&gt;90%），可以认为CPU满负载，此种情况大概率发生卡顿，可以选择上报。</li>
<li>一段时间内CPU的使用率一直超过某个阈值(80%)，此种情况大概率发生卡顿，可以选择上报。</li>
</ul>
<h4 id="三、内存使用监控"><a href="#三、内存使用监控" class="headerlink" title="三、内存使用监控"></a>三、内存使用监控</h4><h5 id="1、内存"><a href="#1、内存" class="headerlink" title="1、内存"></a>1、内存</h5><ul>
<li>内存是有限且系统共享的资源，一个App占用地多，系统和其他App所能用的就更少；减少内存占用能不仅仅让自己App，其他App，甚至是整个系统都表现得更好。</li>
<li>关注App的内存使用情况十分重要</li>
</ul>
<h5 id="2、内存信息结构"><a href="#2、内存信息结构" class="headerlink" title="2、内存信息结构"></a>2、内存信息结构</h5><ul>
<li>Mach task 的内存使用信息存放在<code>mach_task_basic_info</code>结构体中 ，其中<code>resident_size</code> 为驻留内存大小，而phys_footprint表示实际使用的物理内存，iOS 9之后使用phys_footprint来统计App占用的内存大小（和Xcode和Instruments的值显示值接近）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct task_vm_info &#123;</span><br><span class="line">  mach_vm_size_t  virtual_size;       // 虚拟内存大小</span><br><span class="line">  integer_t region_count;             // 内存区域的数量</span><br><span class="line">  integer_t page_size;</span><br><span class="line">  mach_vm_size_t  resident_size;      // 驻留内存大小</span><br><span class="line">  mach_vm_size_t  resident_size_peak; // 驻留内存峰值</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  /* added for rev1 */</span><br><span class="line">  mach_vm_size_t  phys_footprint;     // 实际使用的物理内存</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h5 id="3、内存信息获取"><a href="#3、内存信息获取" class="headerlink" title="3、内存信息获取"></a>3、内存信息获取</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint64_t qs_getAppMemoryBytes() &#123;</span><br><span class="line">    task_vm_info_data_t vmInfo;</span><br><span class="line">    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;</span><br><span class="line">    kern_return_t result = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);</span><br><span class="line">    if (result != KERN_SUCCESS)</span><br><span class="line">        return 0;</span><br><span class="line">    return vmInfo.phys_footprint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、为什么关注内存使用"><a href="#4、为什么关注内存使用" class="headerlink" title="4、为什么关注内存使用"></a>4、为什么关注内存使用</h5><ul>
<li>内存问题影响最大是OOM，即Out of Memory，指的是 App 占用的内存达到iOS系统对单个App占用内存上限时，而被系统强杀的现象，这是一种由iOS的Jetsam机制导致的奔溃，无法通过信号捕获到。</li>
<li>对于监控OOM没有很好的办法，目前比较可行的办法是：<strong>定时监控内存使用，当接近内存使用上限时，dump 内存信息，获取对象名称、对象个数、各对象的内存值，并在合适的时机上报到服务器</strong>。</li>
<li>App中会使用很多单例，这些单例常驻内存，需要关注大单例；大图片解码会造成内存使用飙升，这个也需要关注；还有些取巧的方案，比如预创建webview对象甚至预创建ViewController对象，采用此类做法，需要关注对内存造成的压力。</li>
</ul>
<h4 id="四、FPS监控"><a href="#四、FPS监控" class="headerlink" title="四、FPS监控"></a>四、FPS监控</h4><h5 id="1、FPS和CADisplayLink"><a href="#1、FPS和CADisplayLink" class="headerlink" title="1、FPS和CADisplayLink"></a>1、FPS和CADisplayLink</h5><ul>
<li><code>FPS</code>是<code>Frames Per Second</code> ，意思是每秒帧数，也就是我们常说的“刷新率（单位为Hz）。FPS低(小于50)表示App不流畅，App需要优化，iOS手机屏幕的正常刷新频率是每秒60次，即<code>FPS</code>值为60。</li>
<li><code>CADisplayLink</code>是和屏幕刷新频率保存一致，它是<code>CoreAnimation</code>提供的另一个类似于<code>NSTimer</code>的类，它总是在屏幕完成一次更新之前启动，<code>CADisplayLink</code>有一个整型的<code>frameInterval</code>属性，指定了间隔多少帧之后才执行。默认值是1，意味着每次屏幕更新之前都会执行一次。</li>
</ul>
<h5 id="2、FPS监控实现"><a href="#2、FPS监控实现" class="headerlink" title="2、FPS监控实现"></a>2、FPS监控实现</h5><ul>
<li>注册CADisplayLink 得到屏幕的同步刷新率，记录1s(<strong>useTime</strong>,可能比1s大一丢丢)时间内刷新的帧数（<strong>total</strong>），计算<strong>total/useTime</strong>得到1s时间内的帧数，即FPS值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    //注意CADisplayLink的处理循环引用问题</span><br><span class="line">    self.displayLink = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(updateFPSCount:)];</span><br><span class="line">    [self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行帧率和屏幕刷新率保持一致</span><br><span class="line">- (void)updateFPSCount:(CADisplayLink *)displayLink &#123;</span><br><span class="line">    </span><br><span class="line">    if (self.lastTimeStamp == 0) &#123;</span><br><span class="line">        self.lastTimeStamp = self.displayLink.timestamp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.total++;</span><br><span class="line">        // 开始渲染时间与上次渲染时间差值</span><br><span class="line">        NSTimeInterval useTime = self.displayLink.timestamp - self.lastTimeStamp;</span><br><span class="line">        //小于1s立即返回</span><br><span class="line">        if (useTime &lt; 1)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        self.lastTimeStamp = self.displayLink.timestamp;</span><br><span class="line">        // fps 计算</span><br><span class="line">        NSInteger fps = self.total / useTime;</span><br><span class="line">        NSLog(@&quot;self.total = %@,useTime = %@,fps = %@&quot;,@(self.total),@(useTime),@(fps));</span><br><span class="line">        self.total = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：很多团队非常相信(甚至迷信)FPS值，认为FPS值(大于50)就代表不卡顿，这点我是不认可。下面我列举遇到的2个非常典型的Case。</p>
<h5 id="3、错信FPS值Case1"><a href="#3、错信FPS值Case1" class="headerlink" title="3、错信FPS值Case1"></a>3、错信FPS值Case1</h5><ul>
<li>同学A在做频繁绘制需求时, 重写UIView的<code>drawRect:</code>方法，在模拟器上频繁调用setNeedsDisplay来触发<code>drawRect:</code>方法，FPS值还稳定在50以上，但是真机上去掉帧很厉害。我认为这里犯了两个错误。</li>
<li>错误1：<code>drawRect:</code>是利用CPU绘制的，性能并不如GPU绘制，对于频繁绘制的绘制需求，不应该考虑使用重写<code>drawRect:</code>这种方式，推荐<code>CAShapeLayer+UIBezierPath</code>。</li>
<li>错误2：不应该关注模拟器FPS来观察是否发生卡顿，模拟器使用的是Mac的处理器，比手机的ARM性能要强，所以造成在模拟器上FPS比较理想，真机上比较差。</li>
</ul>
<h5 id="4、错信FPS值Case2"><a href="#4、错信FPS值Case2" class="headerlink" title="4、错信FPS值Case2"></a>4、错信FPS值Case2</h5><ul>
<li>同学B在列表滑动时候，观察iPhone 6 plus真机上FPS的值稳定在52左右，感觉不错，但是肉眼明显感觉到卡顿。</li>
<li>是FPS错了吗？我认为没错，是我们对FPS的理解错了；因为FPS代表的是<strong>每秒帧数</strong>，这是一个平均值，假如前0.5s播放了2帧，后面0.5s播放了58帧，从结果来看，FPS的值依旧是60。但是实际上，它的确发生了卡顿。</li>
</ul>
<h5 id="5、为什么关注FPS"><a href="#5、为什么关注FPS" class="headerlink" title="5、为什么关注FPS"></a>5、为什么关注FPS</h5><ul>
<li>虽然列举了两个错信FPS的Case，但是FPS依旧是一个很重要的指标，来关注页面的卡顿情况。</li>
<li>和使用监控RunLoop状态来发现卡顿问题不同，FPS关注的是滑动场景下，FPS偏低的场景。</li>
<li>而监控RunLoop状态来发现卡顿问题更加关注的是：在一段时间内无法进行用户操作的场景，这类卡顿对用户的伤害非常大，是通过日志很难发现，需要优先解决的问题</li>
</ul>
<h4 id="五、卡顿监控"><a href="#五、卡顿监控" class="headerlink" title="五、卡顿监控"></a>五、卡顿监控</h4><h5 id="1、卡顿和RunLoop"><a href="#1、卡顿和RunLoop" class="headerlink" title="1、卡顿和RunLoop"></a>1、卡顿和RunLoop</h5><ul>
<li>卡顿监控的本质是，监控主线程做了哪些事；线程的消息事件依赖<strong>RunLoop</strong>，通过监听RunLoop的状态，从而判断是否发生卡顿。</li>
<li>RunLoop在iOS中是由CFRunLoop实现的，它负责监听输入源，进行调度处理的，这里的输入源可以是输入设备、网络、周期性或者延迟时间、异步回调。RunLoop接收两种输入源：一种是来<strong>自另一个线程或者来自不同应用的异步消息</strong>；另一个事<strong>来自预定时间或重复间隔的同步事件</strong>。</li>
<li>当有事情处理，Runloop唤起线程去处理，没有事情处理，让线程进入休眠。基于此，我们可以把大量占用CPU的任务(图片加载、数据文件读写等) ，放在空闲的非主线程执行，就可以避免影响主线程滑动过程中的体验(主线程滑动时，RunLoop处在UITrackingRunLoopMode模式)</li>
</ul>
<h5 id="2、如何判断卡顿"><a href="#2、如何判断卡顿" class="headerlink" title="2、如何判断卡顿"></a>2、如何判断卡顿</h5><ul>
<li>已知的RunLoop的7个状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//RunLoop的状态</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">     kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">     kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">     kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">     kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">     kCFRunLoopAllActivities = 0x0FFFFFFFU // loop 所有状态改变</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于<code>kCFRunLoopBeforeSources之后</code>需要处理Source0，<code>kCFRunLoopAfterWaiting之后</code>需要处理timer、dispatch 到 main_queue 的 block和Source1，所以可以认为<code>kCFRunLoopBeforeSources</code>和<code>kCFRunLoopAfterWaiting</code>。因为<code>kCFRunLoopBeforeSources</code>之后和<code>kCFRunLoopAfterWaiting</code>之后是事情处理的主要时间段。</li>
<li><p>dispatch_semaphore_t信号量机制特性：信号量到达、或者 超时会继续向下进行，否则等待；如果超时则返回的结果必定不为0，否则信号量到达结果为0。</p>
</li>
<li><p>主线程卡顿发生是因为要处理大量的事情。这就意味着<strong>主线程在消耗时间在处理繁重的事件，导致信号超时了</strong>(dispatch_semaphore_signal不能及时执行)，<strong>如果此时发现当前的RunLoop的状态是kCFRunLoopBeforeSources或kCFRunLoopAfterWaiting，就认为主线程长期停留在这两个状态上，此时就判定卡顿发生。</strong></p>
</li>
</ul>
<h5 id="3、卡顿监控的实现"><a href="#3、卡顿监控的实现" class="headerlink" title="3、卡顿监控的实现"></a>3、卡顿监控的实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">//  QSMainThreadMonitor.h</span><br><span class="line">@interface QSMainThreadMonitor : NSObject</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line"></span><br><span class="line">- (void)beginMonitor;</span><br><span class="line"></span><br><span class="line">- (void)stopMonitor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  QSMainThreadMonitor.m</span><br><span class="line">@interface QSMainThreadMonitor()</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong) dispatch_semaphore_t semaphore;</span><br><span class="line">@property (nonatomic,assign) CFRunLoopObserverRef observer;</span><br><span class="line">@property (nonatomic,assign) CFRunLoopActivity runloopActivity;</span><br><span class="line">@property (nonatomic,strong) dispatch_queue_t monitorQueue;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation QSMainThreadMonitor</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static QSMainThreadMonitor *monitor = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        monitor = [[QSMainThreadMonitor alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return monitor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.monitorQueue = dispatch_queue_create(&quot;com.main.thread.monitor.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)beginMonitor&#123;</span><br><span class="line">    </span><br><span class="line">    if (self.observer) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">     __block int timeoutCount = 0;</span><br><span class="line">    </span><br><span class="line">    //创建观察者并添加到主线程</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL,NULL&#125;;</span><br><span class="line">    self.observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context);</span><br><span class="line">    //将self.observer添加到主线程RunLoop的Common模式下观察</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), self.observer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    self.semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    dispatch_async(self.monitorQueue, ^&#123;</span><br><span class="line">        while (YES) &#123;</span><br><span class="line">            long result = dispatch_semaphore_wait(self.semaphore, dispatch_time(DISPATCH_TIME_NOW, 2 * NSEC_PER_SEC));</span><br><span class="line">            if (result != 0 &amp;&amp; self.observer) &#123;</span><br><span class="line">                //超时判断</span><br><span class="line">                if (self.runloopActivity == kCFRunLoopBeforeSources || self.runloopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    if (++timeoutCount &lt; 1) &#123;</span><br><span class="line">                        NSLog(@&quot;--timeoutCount--%@&quot;,@(timeoutCount));</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //出现卡顿、进一步处理</span><br><span class="line">                    NSLog(@&quot;--timeoutCount 卡顿发生--&quot;);</span><br><span class="line">                    // todo，eg:获取堆栈信息并上报</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                timeoutCount = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopMonitor&#123;</span><br><span class="line">    </span><br><span class="line">    if (!self.observer) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopRemoveObserver(CFRunLoopGetMain(), self.observer, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(self.observer);</span><br><span class="line">    self.observer = NULL;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -Private Method</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 观察者回调函数</span><br><span class="line"> */</span><br><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</span><br><span class="line">    //每一次监测到Runloop状态变化调用</span><br><span class="line">    QSMainThreadMonitor *monitor = (__bridge QSMainThreadMonitor *)info;</span><br><span class="line">    monitor.runloopActivity = activity;</span><br><span class="line">    if (monitor.semaphore) &#123;</span><br><span class="line">        dispatch_semaphore_signal(monitor.semaphore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="4、卡顿时间阈值说明"><a href="#4、卡顿时间阈值说明" class="headerlink" title="4、卡顿时间阈值说明"></a>4、卡顿时间阈值说明</h5><ul>
<li>这里卡顿时间阈值是2s，连续1次超时且RunLoop的状态处于<code>kCFRunLoopBeforeSources</code>或<code>kCFRunLoopAfterWaiting</code> 状态就认为卡顿。</li>
<li>利用的RunLoop实现的卡顿方案，主要是针对那些在一段时间内无法进行用户操作的场景，这类卡顿对用户的伤害非常大，是通过日志很难发现，需要优先解决的问题。</li>
<li><strong>卡顿时间阈值</strong>(<em>timeoutThreshold</em>)和<strong>超时时间次数</strong>(<em>timeoutCount</em>)可以通服务器下发控制，用来控制上报卡顿情况的场景。</li>
</ul>
<h4 id="六、电量监控"><a href="#六、电量监控" class="headerlink" title="六、电量监控"></a>六、电量监控</h4><h5 id="1、手动查看电量"><a href="#1、手动查看电量" class="headerlink" title="1、手动查看电量"></a>1、手动查看电量</h5><ul>
<li>我们可以通过手机的<strong>设置-电池</strong>查看过去一段时间(24小时或2天)查看Top耗电量的App；</li>
<li>对于用户来说，还有更直接的方式，使用某App时候，手机状态栏右上角电池使用量嗖嗖往下掉或手机发热，那么基本可以判断这个App耗电太快，赶紧卸了。</li>
<li>对于开发者来说，可以通过Xcode左边栏的Energy Impact查看电量使用，蓝色表示–合理,黄色–表示比较耗电，红色–表示仅仅轻度使用你的程序,就会很耗电。</li>
<li>还可以使用手机<strong>设置-开发者-Logging-Energy</strong>的startRecording和stopRecording来记录一段时间(3-5minutes)某App的耗电量情况。导入Instrument来分析具体耗电情况。</li>
</ul>
<h5 id="2、电量监控方案1"><a href="#2、电量监控方案1" class="headerlink" title="2、电量监控方案1"></a>2、电量监控方案1</h5><ul>
<li><p>利用<code>UIDevice</code> 提供了获取设备电池的相关信息，包括当前电池的状态以及电量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//开启电量监控</span><br><span class="line">[UIDevice currentDevice].batteryMonitoringEnabled = YES;</span><br><span class="line">//监听电量使用情况</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserverForName:UIDeviceBatteryLevelDidChangeNotification object:nil queue:[NSOperationQueue mainQueue]</span><br><span class="line">         usingBlock:^(NSNotification *notification) &#123;</span><br><span class="line">             // Level has changed</span><br><span class="line">             NSLog(@&quot;&quot;);</span><br><span class="line">             //UIDevice返回的batteryLevel的范围在0到1之间。</span><br><span class="line">             NSUInteger batteryLevel = [UIDevice currentDevice].batteryLevel * 100;</span><br><span class="line">             NSLog(@&quot;[Battery Level]: %@&quot;, @(batteryLevel));</span><br><span class="line">         &#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>说明</strong>：使用 <code>UIDevice</code> 可以非常方便获取到电量，但是经测试发现，在 iOS 8.0 之前，<code>batteryLevel</code> 只能精确到5%，而在 <code>iOS 8.0</code> 之后，精确度可以达到1%</p>
<h5 id="3、电量监控方案2"><a href="#3、电量监控方案2" class="headerlink" title="3、电量监控方案2"></a>3、电量监控方案2</h5><ul>
<li>利用iOS系统私有框架<code>IOKit</code>, 通过它可以获取设备电量信息，精确度达到1%。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;IOPSKeys.h&quot;</span><br><span class="line">#import &quot;IOPowerSources.h&quot;</span><br><span class="line"></span><br><span class="line">-(double) getBatteryLevel&#123;</span><br><span class="line">    // 返回电量信息</span><br><span class="line">    CFTypeRef blob = IOPSCopyPowerSourcesInfo();</span><br><span class="line">    // 返回电量句柄列表数据</span><br><span class="line">    CFArrayRef sources = IOPSCopyPowerSourcesList(blob);</span><br><span class="line">    CFDictionaryRef pSource = NULL;</span><br><span class="line">    const void *psValue;</span><br><span class="line">    // 返回数组大小</span><br><span class="line">    int numOfSources = CFArrayGetCount(sources);</span><br><span class="line">    // 计算大小出错处理</span><br><span class="line">    if (numOfSources == 0) &#123;</span><br><span class="line">        NSLog(@&quot;Error in CFArrayGetCount&quot;);</span><br><span class="line">        return -1.0f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算所剩电量</span><br><span class="line">    for (int i=0; i&lt;numOfSources; i++) &#123;</span><br><span class="line">        // 返回电源可读信息的字典</span><br><span class="line">        pSource = IOPSGetPowerSourceDescription(blob, CFArrayGetValueAtIndex(sources, i));</span><br><span class="line">        if (!pSource) &#123;</span><br><span class="line">            NSLog(@&quot;Error in IOPSGetPowerSourceDescription&quot;);</span><br><span class="line">            return -1.0f;</span><br><span class="line">        &#125;</span><br><span class="line">        psValue = (CFStringRef) CFDictionaryGetValue(pSource, CFSTR(kIOPSNameKey));</span><br><span class="line"></span><br><span class="line">        int curCapacity = 0;</span><br><span class="line">        int maxCapacity = 0;</span><br><span class="line">        double percentage;</span><br><span class="line"></span><br><span class="line">        psValue = CFDictionaryGetValue(pSource, CFSTR(kIOPSCurrentCapacityKey));</span><br><span class="line">        CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &amp;curCapacity);</span><br><span class="line"></span><br><span class="line">        psValue = CFDictionaryGetValue(pSource, CFSTR(kIOPSMaxCapacityKey));</span><br><span class="line">        CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &amp;maxCapacity);</span><br><span class="line"></span><br><span class="line">        percentage = ((double) curCapacity / (double) maxCapacity * 100.0f);</span><br><span class="line">        NSLog(@&quot;curCapacity : %d / maxCapacity: %d , percentage: %.1f &quot;, curCapacity, maxCapacity, percentage);</span><br><span class="line">        return percentage;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：</p>
<ul>
<li>因为IOKit.framework是私有类库，使用的时候，需要通过动态引用的方式，没有具体实践，UIDevice获取的方案在iOS 8.0` 之后，精确度可以达到1%, 已经满足项目需要(我们项目最低支持iOS 9)。</li>
</ul>
<h5 id="4、耗电量大的操作"><a href="#4、耗电量大的操作" class="headerlink" title="4、耗电量大的操作"></a>4、耗电量大的操作</h5><ul>
<li><p>CPU使用率高的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程过多 (控制合适的线程数)</span><br><span class="line">定位   (按需使用，降低频次)</span><br><span class="line">CPU任务繁重  (使用轻量级对象，缓存计算结果，对象复用等)</span><br><span class="line">频繁网络请求(避免无效冗余的网络请求)</span><br></pre></td></tr></table></figure>
</li>
<li><p>I/O操作频繁的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接读写磁盘文件 (合理利用内存缓存，碎片化的数据在内存中聚合，合适时机写入磁盘)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="七、End"><a href="#七、End" class="headerlink" title="七、End"></a>七、End</h4><h5 id="1、总结"><a href="#1、总结" class="headerlink" title="1、总结"></a>1、总结</h5><ul>
<li><p>对APP的质量指标的监控，是为了更早地发现问题；发现问题是为了更好地解决问题。所以监控不是终点，是起点。</p>
</li>
<li><p>在17年时候，在简书中写了<a href="https://www.jianshu.com/p/3261493e6d9e" target="_blank" rel="noopener">iOS实录14：浅谈iOS Crash（一）</a>和 <a href="https://www.jianshu.com/p/33ee5e7d312c" target="_blank" rel="noopener">iOS实录15：浅谈iOS Crash（二）</a>两篇文章；时隔两年之后，书写此文，是为了纪念过去大半年时候在App质量监控上花的努力。</p>
</li>
<li>文章篇幅有限，没有介绍具体的优化办法。</li>
</ul>
<h5 id="2、推荐的阅读资料"><a href="#2、推荐的阅读资料" class="headerlink" title="2、推荐的阅读资料"></a>2、推荐的阅读资料</h5><p><a href="https://juejin.im/entry/595356e5f265da6c43670373" target="_blank" rel="noopener">iOS 性能监控方案 Wedjat（上篇）</a></p>
<p><a href="https://www.jianshu.com/p/f0dc653d04ca" target="_blank" rel="noopener">教你开发省电的 iOS app</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">南华coder</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://buaa0300/nanhuacoder.com/2019/04/16/iOS-AppMonitor/">http://buaa0300/nanhuacoder.com/2019/04/16/iOS-AppMonitor/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://buaa0300/nanhuacoder.com">南华coder的空间</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/APM/">APM</a><a class="post-meta__tags" href="/tags/Monitor/">Monitor</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/17/iOS-OOM/"><i class="fa fa-chevron-left">  </i><span>OOM问题小记</span></a></div><div class="next-post pull-right"><a href="/2019/04/15/iOS-NSLog/"><span>捕获NSLog日志小记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 南华coder</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>