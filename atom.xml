<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南华coder的空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://buaa0300/nanhuacoder.com/"/>
  <updated>2018-01-28T09:24:11.776Z</updated>
  <id>http://buaa0300/nanhuacoder.com/</id>
  
  <author>
    <name>南华coder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>启动优化</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/28/launchOPt/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/28/launchOPt/</id>
    <published>2018-01-28T09:22:36.000Z</published>
    <updated>2018-01-28T09:24:11.776Z</updated>
    
    <content type="html"><![CDATA[<p>目前iOS优化主要包括三方面：<strong>卡顿优化</strong>、<strong>启动优化</strong>和<strong>瘦身优化</strong>，本文简单说下<strong>启动优化</strong></p><blockquote><h4 id="一、启动时间"><a href="#一、启动时间" class="headerlink" title="一、启动时间"></a>一、启动时间</h4></blockquote><ul><li><p>如果你的App启动超过20s内，是时候考虑换个工作了(<em>开个玩笑</em>)；启动优化是<strong>基于当下的业务复杂度和代码复杂度的最优处理</strong>。</p></li><li><p><strong>App总启动时间</strong> = t1(main函数之前的加载时间) + t2(main函数之后的加载时间)</p></li><li><p><strong>t1</strong> = 系统dylib(动态链接库)和自身App可执行文件的加载时间</p></li><li><strong>t2</strong> = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</li></ul><blockquote><h4 id="二、main函数之前的优化"><a href="#二、main函数之前的优化" class="headerlink" title="二、main函数之前的优化"></a>二、main函数之前的优化</h4></blockquote><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><ul><li><p><strong>加载过程</strong>：先加载<strong>可执行文件</strong>；然后<strong>加载dyld</strong>(dynamic link editor)动态链接器；然后dyld从可执行文件的依赖开始，递归加载所有依赖的动态链接库。</p></li><li><p><strong>动态链接库</strong>包括：系统的framework、加载OC Runtime的libobjc、系统级别的libSystem、如libdispatch(GCD)和libsystem_blocks(Block)。</p></li><li><p><strong>Apple不允许使用自己的动态库</strong>，否则无法过审；只能选择<strong>静态库</strong>的方式，第三方登录、分享都使用该类方式；链接时会被完整的复制到可执行文件中；</p></li><li><p>相比<strong>静态库</strong>而言，<strong>动态链接库</strong>在程序运行时才记载到内存，不会增加可执行文件的体积，但是会增加加载时间；而<strong>静态库</strong>虽然有利于优化加载速度，但是会增加包的体积。</p></li></ul><h5 id="2、优化思路"><a href="#2、优化思路" class="headerlink" title="2、优化思路"></a>2、优化思路</h5><ul><li><p>减少不必要的framework，因为动态链接比较耗时；</p></li><li><p>检查framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查；</p></li><li><p>合并或者删减一些OC类；删减一些无用的静态变量；删减没有被调用到或者已经废弃的方法；</p></li><li><p>将不必须在+load方法中做的事情延迟到+initialize中；</p></li><li><p>尽量不要用C++虚函数(创建虚函数表有开销)；</p></li></ul><blockquote><h4 id="三、main函数之后的优化"><a href="#三、main函数之后的优化" class="headerlink" title="三、main函数之后的优化"></a>三、main函数之后的优化</h4></blockquote><h5 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h5><ul><li>这部分主要是服务初始化、闪屏（广告或引导）和首页UI渲染等工作；</li></ul><h5 id="2、优化思路-1"><a href="#2、优化思路-1" class="headerlink" title="2、优化思路"></a>2、优化思路</h5><ul><li><p><strong>视图</strong>：使用代码创建首页视图。</p></li><li><p><strong>服务初始化</strong>：团队间沟通优化业务逻辑，如，延迟某些服务的初始化；合并某些网络请求或减少启动时网络请求个数；</p></li><li><p><strong>其他</strong>：减少NSLog输出，因为其会隐似创建个NSCalender，比较耗时；网络请求和数据读取等耗时操作放在子线程；图片子线程解码等。</p></li></ul><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote><ul><li><p>一个比较靠谱团队，启动这块耗时不会太糟糕，动不动就优化效果显著，要么是太牛逼，要么是团队太坑；做启动优化这块，需要平常心和耐心。</p></li><li><p><strong>main函数之后优化空间比较大，主要在业务上</strong>；所以要先需要熟悉业务，优化之前和各方沟通好，如XX提供的SDK能否延迟初始化，XXX效果设计团队能否接受；XXXX处理会不会给其他团队人员的工作带来困扰….</p></li><li><p>网络上有很多团队分享了启动优化经验，大都是基于自身业务特点的优化总结；想系统了解，还是推荐看看<a href="https://techblog.toutiao.com/2017/01/17/iosspeed/" target="_blank" rel="noopener">今日头条iOS客户端启动速度优化</a>(<em>我的优化知识也是来源于此</em>)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前iOS优化主要包括三方面：&lt;strong&gt;卡顿优化&lt;/strong&gt;、&lt;strong&gt;启动优化&lt;/strong&gt;和&lt;strong&gt;瘦身优化&lt;/strong&gt;，本文简单说下&lt;strong&gt;启动优化&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、启
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈瘦身优化</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/27/app-thinning/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/27/app-thinning/</id>
    <published>2018-01-27T09:39:47.000Z</published>
    <updated>2018-01-27T09:41:37.704Z</updated>
    
    <content type="html"><![CDATA[<p>目前iOS优化主要包括三方面：<strong>卡顿优化</strong>、<strong>启动优化</strong>和<strong>瘦身优化</strong>，本文简单说下<strong>瘦身优化</strong>。</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><h5 id="1、App-Thinning"><a href="#1、App-Thinning" class="headerlink" title="1、App Thinning"></a>1、App Thinning</h5><p>在iOS 9时候，苹果推出的App Thinning三件套：<strong>App Slicing</strong>、<strong>On Demand Resouces</strong>、<strong>Bitcode</strong>；</p><table><thead><tr><th>App Thinning</th><th>理想</th><th>现实</th></tr></thead><tbody><tr><td><strong>App Slicing</strong></td><td>将App Bundle资源根据不同的设备特性分为不同的版本。对于图片资源，会根据设备所需图片分辨率不同分发给对应设备所需对应的图片资源。</td><td>主要是图片资源的Slicing，我们有自己的方案，没有采用</td></tr><tr><td><strong>On Demand Resources</strong></td><td>App的资源只有要使用时才下载，如果其他资源需要空间这些资源可以被移除</td><td>更适合游戏类App，项目没有使用</td></tr><tr><td><strong>Bitcode</strong></td><td>Bitcode可以作为中间产物一起提交AppStore。包含Bitcode配置的程序将会在AppStore上被编译和链接。Bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到AppStore上</td><td>使用BitCode的要求所有代码都支持BitCode，改动项目较大，没有使用</td></tr></tbody></table><p><strong>说明</strong>：我没有使用App Thinning，App Thinning真正带来的效果如何，不好评估。</p><h5 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h5><ul><li><p>安装包主要组成：<strong>二进制代码文件</strong>、<strong>资源文件</strong>和<strong>配置文件</strong>；</p></li><li><p>主要针对<strong>二进制代码文件</strong>和<strong>资源文件</strong>的优化；其中资源文件中最多的是图片文件。</p><p>  <strong>说明</strong>：简单来说，瘦身优化就是为了<strong>减少图片体积</strong>、<strong>减少二进制代码文件</strong>。</p></li></ul><blockquote><h4 id="二、图片体积优化"><a href="#二、图片体积优化" class="headerlink" title="二、图片体积优化"></a>二、图片体积优化</h4></blockquote><h5 id="1、常规手段"><a href="#1、常规手段" class="headerlink" title="1、常规手段"></a>1、常规手段</h5><ul><li><p><strong>及时清理旧的图片资源</strong>。使用类似<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a> 清理旧的图片文件。</p></li><li><p>引入项目中的图片记得<strong>压缩</strong>。</p><p><strong>说明</strong>：LSUnusedResources的思路是，先获取图片文件(imageset, jpg, png, gif)集合A，然后搜索代码文件中所有字符串名称得到B，然后从A集合中排除集合B就得到未使用的图片资源。</p></li></ul><h5 id="2、方案替换"><a href="#2、方案替换" class="headerlink" title="2、方案替换"></a>2、方案替换</h5><ul><li><p><strong>PNG切图的替换方案</strong>，如<strong>PDF矢量图</strong>来代替大部分简单的png切图；然后在代码中自己解码并展示出来，一套PDF矢量图可以等效大部分2x和3x的png图片；如<strong>iconfont</strong>代替项目中纯色小图标，也省去很多@2x和@3x的图片切图。</p><p><strong>说明</strong>：PNG切图不可能被完全替换，在表现颜色丰富图片时候，PNG效果很不错。</p></li><li><p>详见<a href="https://buaa0300.github.io/2018/01/13/imageOptimize/" target="_blank" rel="noopener">浅谈iOS图片优化</a></p></li></ul><h5 id="3、图片文件去重"><a href="#3、图片文件去重" class="headerlink" title="3、图片文件去重"></a>3、图片文件去重</h5><ul><li><p><strong>重复图片</strong>文件遇到的情况不多(重复引入)，但是发现难度大。提供一种思路：</p><pre><code>1）遍历图片文件，计算每个文件的MD5值，然后以MD5值为key，文件路径存入key对应的数组；2）遍历字典values，将value的数组大小大于1的路径输出，这样就找到重复图片的路径了。</code></pre><p>  <strong>说明</strong>：也可以使用<strong>感知哈希算法</strong>去计算图片见的<strong>海明距离</strong>，找出相似图片，看看这些图片是否可以被整合或清理。</p></li></ul><blockquote><h4 id="三、二进制代码文件优化"><a href="#三、二进制代码文件优化" class="headerlink" title="三、二进制代码文件优化"></a>三、二进制代码文件优化</h4></blockquote><h5 id="1、常规手段-1"><a href="#1、常规手段-1" class="headerlink" title="1、常规手段"></a>1、常规手段</h5><ul><li><p><strong>及时下线不需要的功能</strong>，如完成使命的ABTest代码、被产品抛弃的功能代码等。</p></li><li><p><strong>功能合并</strong>，相似功能的代码，只需维护一份就可以了。如定制通用UI组件，大家可以有类似需求，可以给通用UI组件的开发提，没必要自己单独实现。</p></li><li><p><strong>保持好的开发习惯</strong>；如 同质第三方库(如AFNetworking和ASIHttpRequest,)选一个就可以了；不要因为引入一个功能，引入很多类文件。</p></li><li><p><strong>建议预警机制</strong>，监控每个版本的体积大小，体积图片突然变大，要去找原因。</p></li></ul><h5 id="2、其他"><a href="#2、其他" class="headerlink" title="2、其他"></a>2、其他</h5><ul><li>使用工具分析冗余的代码，如AppCode工具，<strong>其分析结果只是作为参考</strong>。</li></ul><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote><ul><li><p>保持良好的开发习惯，有一定的意识，一般不会把App体积弄得很离谱；</p></li><li><p>如果是之前的技术债造成的，也不用担心，先从图片优化开发(<strong>见效显著</strong>)，二进制方面优化慢慢来，熟悉代码后再动手吧。</p></li><li><p>头条的<a href="https://techblog.toutiao.com/2016/12/27/iphone/" target="_blank" rel="noopener">iPhone安装包的优化</a>值得学习了解下。</p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前iOS优化主要包括三方面：&lt;strong&gt;卡顿优化&lt;/strong&gt;、&lt;strong&gt;启动优化&lt;/strong&gt;和&lt;strong&gt;瘦身优化&lt;/strong&gt;，本文简单说下&lt;strong&gt;瘦身优化&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈卡顿优化</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/26/kadunyouhua/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/26/kadunyouhua/</id>
    <published>2018-01-26T15:23:05.000Z</published>
    <updated>2018-01-28T02:43:08.139Z</updated>
    
    <content type="html"><![CDATA[<p>目前iOS优化主要包括三方面：<strong>卡顿优化</strong>、<strong>启动优化</strong>和<strong>瘦身优化</strong>，本文简单说下<strong>卡顿优化</strong>。</p><blockquote><h4 id="一、卡顿"><a href="#一、卡顿" class="headerlink" title="一、卡顿"></a>一、卡顿</h4></blockquote><h5 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h5><ul><li><p>iOS设备使用双缓存，以<strong>60HZ</strong>的频率刷新屏幕，这就意味着，在<strong>1/60s(16.67ms)</strong>内要将完成<strong>下一帧</strong>的图片的绘制，并存在缓存区中；</p></li><li><p>在这1/60s(16.67ms)内，<strong>CPU要计算显示内容</strong>，然后将这些内容交给<strong>GPU去变换、合成和渲染</strong>，GPU把渲染后的内容提交到帧缓存区，等待更新信号；</p></li><li><p>如果在1/60s(16.67ms)不能完成这些工作，这帧内容就会被丢弃，显示屏还保存之前的内容，也就是常说的<strong>丢帧</strong>了，这也是<strong>卡顿的原因</strong>。</p></li><li><p>简单说，卡顿优化就是为了，<strong>优化CPU和GPU的使用情况</strong>。</p></li></ul><h5 id="2、卡顿监控"><a href="#2、卡顿监控" class="headerlink" title="2、卡顿监控"></a>2、卡顿监控</h5><ul><li><p><strong>主线程卡顿监控</strong>。通过子线程监测主线程的 RunLoop，判断两个状态区域之间的耗时是否达到一定阈值，发现卡顿还可以抓取堆栈信息，上报到服务器，便于准确定位和优化。</p></li><li><p><strong>FPS监控</strong>，利用CADisplayLink(和屏幕刷新频率相同)，过记录两次刷新时间间隔，计算出当前的 FPS。</p><p><strong>说明</strong>：卡顿监控很有意义，要么自己做，要么用第三方的，如腾讯的bugly。</p><p>参考：<a href="http://mrpeak.cn/blog/ui-detect/" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a></p></li></ul><blockquote><h4 id="二、CPU方面优化"><a href="#二、CPU方面优化" class="headerlink" title="二、CPU方面优化"></a>二、CPU方面优化</h4></blockquote><p>CPU做计算显示的内容，主要包括：视图创建、视图布局、图片解码、文本绘制、图像绘制等。</p><h5 id="1、视图创建"><a href="#1、视图创建" class="headerlink" title="1、视图创建"></a>1、视图创建</h5><ul><li><p><strong>对象复用</strong>，复用对象的代价比创建新对象的成本要低；比较典型的是：<strong>UITableViewCell对象的复用</strong>，需要UITableViewCell对象，先从缓存池取，如果取不到，才去创建新对象；</p></li><li><p><strong>选择轻量级对象</strong>：不响应触摸事件的视图，不使用UIView，优先使用CAShapeLayer(硬件加速、渲染快）。</p></li><li><p><strong>数据对象的缓存</strong>：比较典型的是，解码图像的缓存和cell高度的缓存；前者避免图片重复解码，后者避免Cell高度重复计算。</p></li></ul><h5 id="2、视图布局"><a href="#2、视图布局" class="headerlink" title="2、视图布局"></a>2、视图布局</h5><ul><li><p>不使用Autolayout（布局计算在主线程），视图复杂后，性能不佳；可以使用代码创建View，使用frame布局；要注意<strong>frame值要取整</strong>，避免像素不对齐；</p></li><li><p>尽量减少视图的数量、层级数量、层级调整、视图添加和删除操作；</p></li><li><p>尽量减少不必要的属性修改，如CALayer相关的属性(如frame、bounds、transform、center等），修改会引起隐式动画。</p></li></ul><h5 id="3、图片解码"><a href="#3、图片解码" class="headerlink" title="3、图片解码"></a>3、图片解码</h5><ul><li>子线程解码图片，然后在主线程展示解码后的位图（位图结果记得缓存）。</li></ul><h5 id="4、文本绘制"><a href="#4、文本绘制" class="headerlink" title="4、文本绘制"></a>4、文本绘制</h5><ul><li><strong>文本的宽高计算和绘制</strong>会占用资源，可以在子线程计算和绘制，然后在主线程显示；这适用于大量文本显示的处理，如果只是2-3行文本显示，没必要选择这么做。</li></ul><h5 id="5、图像绘制"><a href="#5、图像绘制" class="headerlink" title="5、图像绘制"></a>5、图像绘制</h5><ul><li><p>图片的绘制可以放到子线程中做，因为CG绘制是线程安全的；将图片绘制到画布上，然后将图片显示到视图中。</p><p><strong>总结</strong>：因为<strong>主线程占用CPU高、子线程占用CPU低</strong>；优化时，把不是必须要在主线程中做的事情 放在子线程中做，但是要防止线程爆炸，参考<a href="https://www.jianshu.com/p/5d51a367ed62" target="_blank" rel="noopener">GCD小结之控制最大并发数</a>。</p></li></ul><blockquote><h4 id="三、GPU方面优化"><a href="#三、GPU方面优化" class="headerlink" title="三、GPU方面优化"></a>三、GPU方面优化</h4></blockquote><p>GPU接收提交的纹理(Texture) 和顶点数据信息，应用变换(transform)、混合并渲染等，然后输出到屏幕上。</p><h5 id="1、纹理的渲染"><a href="#1、纹理的渲染" class="headerlink" title="1、纹理的渲染"></a>1、纹理的渲染</h5><ul><li><p>GPU的消耗主要在：所有Bitmap由内存提交到显存、绑定为GPU Texture；GPU的调整；渲染Texture等。尽量避免短时间显示大量图片，否则会造成CPU使用率低，而GPU使用率飙升；可以合成多张图片，做一张显示。</p></li><li><p>尽量避免图片过大，超过GPU的最大纹理尺寸，需要CPU进行预处理，带来CPU和GPU的格外消耗。在网络环境中，遇到下载特大高清图时，SDWebImage的处理是，<strong>将大的原图裁剪成指定大小的小图，然后拼成大图</strong> 思路类似异步绘制内容的图层CATiledLayer，不加载全部图片，而是将大图分解成小图片，然后再载入显示。</p></li></ul><h5 id="2、视图混合"><a href="#2、视图混合" class="headerlink" title="2、视图混合"></a>2、视图混合</h5><ul><li><p><strong>尽量减少视图的数量和层级</strong>，多视图叠加在一起显示时，GPU需要混合计算，视图的数量和层级越深，GPU的消耗越大；</p></li><li><p>视图尽量<strong>不使用透明的背景色</strong>，避免像素混合计算(视图默认不透明 opaque=YES)；尽量<strong>使用不透明的图片</strong>，避免像素混合计算</p></li><li><p>UILabel显示中文时，记得<strong>masksToBounds = YES</strong>，避免混合计算</p></li></ul><h5 id="3、离屏渲染"><a href="#3、离屏渲染" class="headerlink" title="3、离屏渲染"></a>3、离屏渲染</h5><ul><li><p>GPU屏幕渲染分为当前<strong>屏幕渲染</strong>(On-Screen Rendering)和<strong>离屏渲染</strong>(Off-Screen Rendering)，<strong>离屏渲染</strong>需要在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作，其中涉及到的<strong>创建新缓冲区</strong>、<strong>上下文切换</strong>都很消耗GPU资源。</p></li><li><p>容易触发离屏渲染最多的四个场景，<strong>圆角处理</strong>（RoundCorner）、<strong>阴影处理</strong>(Shadow)、<strong>遮罩</strong>(Mask)和Group Opacity（组不透明）；</p></li><li><p><strong>圆角处理</strong>可以采用绘制方式，可以参考<a href="https://www.jianshu.com/p/a38a7c7bccbb" target="_blank" rel="noopener">网络图片的优化显示</a>；<strong>阴影处理</strong>可以通过设置shadowPath来避免；Mask没啥好办法; GroupOpacity处理是<strong>关闭layer的allowsGroupOpacity 属性</strong>；</p></li><li><p><strong>离屏渲染不可避免情况下</strong>，设置<strong>shouldRasterize=YES</strong>（启动光栅化)，可以将layer光栅化为Bitmap, layer的阴影等效果也会被缓存到Bitmap中，减少离屏渲染次数，减少GPU消耗。</p></li></ul><p><strong>说明</strong>：还有种<strong>CPU渲染</strong>的说法，重写了drawRect方法，或使用Core Graphics绘制都会触发；虽然其性能可能还不如GPU的离屏渲染，但是可以在子线程中做CPU渲染，然后在主线程显示。</p><h5 id="4、像素不对齐"><a href="#4、像素不对齐" class="headerlink" title="4、像素不对齐"></a>4、像素不对齐</h5><ul><li>图片显示前，在子线程中可以按目标显示大小裁剪，使图片符合展示大小，避免拉伸缩放(像素不对齐)。</li></ul><blockquote><h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4></blockquote><ul><li><p>优化工作视具体业务来做，没必要过早优化；</p></li><li><p>如果没做过优化方面工作的同学，可以仔细阅读<strong>ibireme</strong>的<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a>，后续很多团队的分享经验都没有跳出ibireme的框架。</p></li><li><p>iOS图片优化是个值得注意的点，不管是在卡顿优化、还是在App瘦身，可以参考我的一点见解<a href="https://buaa0300.github.io/2018/01/13/imageOptimize/" target="_blank" rel="noopener">浅谈iOS图片优化</a>。</p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前iOS优化主要包括三方面：&lt;strong&gt;卡顿优化&lt;/strong&gt;、&lt;strong&gt;启动优化&lt;/strong&gt;和&lt;strong&gt;瘦身优化&lt;/strong&gt;，本文简单说下&lt;strong&gt;卡顿优化&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>组件化学习笔记</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/21/zujianhua/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/21/zujianhua/</id>
    <published>2018-01-21T13:29:49.000Z</published>
    <updated>2018-01-26T15:38:54.709Z</updated>
    
    <content type="html"><![CDATA[<p>没有做过组件化，先自行了解下</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><h5 id="1、为什么用组件化"><a href="#1、为什么用组件化" class="headerlink" title="1、为什么用组件化"></a>1、为什么用组件化</h5><ul><li><p><strong>业务快速发展、复杂的业务场景、团队的快速扩展等</strong>带来的变革诉求，希望通过<strong>组件化</strong>来提高团队的协作能力、减低开发成本，提高开发质量。</p></li><li><p>组件化直接效果：代码解耦，功能模块化；代码的复用性高；代码管理更加科学。</p></li><li><p>从<strong>蘑菇街</strong>(<a href="https://www.jianshu.com/p/cdf94a963c27" target="_blank" rel="noopener">蘑菇街 App 的组件化之路</a>)、<strong>支付宝(<a href="http://www.sohu.com/a/129493438_536622" target="_blank" rel="noopener">从支付宝红包揭秘亿级APP的移动开发</a>)</strong>等团队公开的信息来看：业务的增加、开发团队的扩张、快速迭代的要求，催生组件化方案(<em>可能有更好的架构方案</em>)快速落地。</p></li></ul><h5 id="2、为什么还不用组件化"><a href="#2、为什么还不用组件化" class="headerlink" title="2、为什么还不用组件化"></a>2、为什么还不用组件化</h5><ul><li><p>虽然组件化的风吹了好几年了，但是依然很多团队没有使用组件化方案；主要还是开发资源有限，组件化的改造成本较高，收益相对不大。</p></li><li><p>蘑菇街和支付宝等团队实现组件化方案，一是业务发展的必然选择；二是其技术沉淀深，能为自己和兄弟团队打造出质量上乘的组件化服务。</p></li></ul><h5 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h5><ul><li>组件化是趋势，是大中型App团队的选择。</li></ul><blockquote><h4 id="二、组件化四要素"><a href="#二、组件化四要素" class="headerlink" title="二、组件化四要素"></a>二、组件化四要素</h4></blockquote><p>完成组件化，先考虑四要素。</p><h5 id="1、组件拆分"><a href="#1、组件拆分" class="headerlink" title="1、组件拆分"></a>1、组件拆分</h5><ul><li><p>首先需要对原有的<strong>基础模块</strong>，如网络模块、存储模块、网络图片加载模块、日志上报模块从原有代码中独立出来，用Cocoapods或Submodule管理起来。（<em>这部分相对简单</em>）</p></li><li><p><strong>业务模块</strong>的拆分比较麻烦，这部分代码的规范性不强，文件之间的引用乱且杂，且代码阅读性较差，是个坑多的地方。</p></li><li><p>除了业务模块之外，还有一块代码是<strong>重灾区</strong>，是<strong>AppDelegate的初始化部分</strong>；这里包含太多的逻辑，如SDK和基础模块的初始化，参数设置，注册通知，网络请求等等。我的想法是：将不同的工作分配到不同的Category中，使其职责明确清晰。</p></li></ul><h5 id="2、组件间通信"><a href="#2、组件间通信" class="headerlink" title="2、组件间通信"></a>2、组件间通信</h5><p>组件之前的通信，更多是指业务组件之间的通信吧。目前蘑菇街团队公开的方案是：<strong>URLRouter</strong>、<strong>Protocol Class Binding</strong>这两类方案。</p><h5 id="2-1-URLRouter"><a href="#2-1-URLRouter" class="headerlink" title="2-1 URLRouter"></a>2-1 URLRouter</h5><ul><li><p><strong>简介</strong>：蘑菇街团队实现<a href="https://github.com/meili/MGJRouter" target="_blank" rel="noopener">MGJRouter</a>库，可以根据URL处理执行对应的Block；其核心在于，先注册URL 和 <strong>服务Block</strong> &amp; <strong>参数字典</strong>的对应关系（<em>保存在router字典中</em>），然后利用URL找到对应的Block，将参数字典交给Block，唤起对应的服务。</p><pre><code>  // 注册 [MGJRouter registerURLPattern:@&quot;mgj://foo/bar&quot; toHandler:^(NSDictionary *routerParameters) {[self appendLog:[NSString stringWithFormat:@&quot;routerParameters:%@&quot;, routerParameters]]; }]; //传参 [MGJRouter openURL:@&quot;mgj://foo/bar&quot; withUserInfo:@{@&quot;param1&quot;:@&quot;hello world&quot;} completion:nil]; //同步获取object NSNumber *orderCount = [MGJRouter objectForURL:@&quot;mgj://cart/ordercount&quot;]</code></pre></li><li><p><strong>优势</strong>：解耦方便；各个组件依赖MGJRouter就可以；打破组件间的相关依赖关系；</p></li><li><p><strong>不足</strong>：组件本身依赖中间件，但是分散注册又使得<strong>耦合较多</strong>。<br>需要专门维护URL(<em>蘑菇街使用后台维护，自动生成URL短链的方式</em>)；</p></li></ul><h5 id="2-2-Protocol-Class-Binding（协议和类绑定"><a href="#2-2-Protocol-Class-Binding（协议和类绑定" class="headerlink" title="2-2 Protocol Class Binding（协议和类绑定)"></a>2-2 Protocol Class Binding（协议和类绑定)</h5><ul><li><p><strong>简介</strong>：可以看做是蘑菇街团队URLRouter的升级方案。其核心在于，为组件定义Protocol，Protocol指定返回的数据，然后在组件中新建Class实现Protocol，如此将Protocol和Class关联起来。</p><pre><code> //以购物车组件为例//1、组件定义MGJCart，执行返回订单数方法 @protocol MGJCart &lt;NSObject&gt; + (NSInteger)orderCount; @end//2、MGJCartImpl 实现MGJCart ，实现略 //3、关联[ModuleManager registerClass:MGJCartImpl forProtocol:@protocol(MGJCart)]，//4、获取MGJCartImpl，接下来可以访问到参数了[ModuleManager classForProtocol:@protocol(MGJCart)]</code></pre></li><li><p><strong>优势</strong>：把公共的协议统一放到同一文件中，组件依赖该文件即可。</p></li></ul><h5 id="3、组件的单元测试"><a href="#3、组件的单元测试" class="headerlink" title="3、组件的单元测试"></a>3、组件的单元测试</h5><p>每一个组件都需要提供单元测试，保证代码质量。</p><p><em>实践后，再来补充</em></p><h5 id="4、组件开发、集成、发版"><a href="#4、组件开发、集成、发版" class="headerlink" title="4、组件开发、集成、发版"></a>4、组件开发、集成、发版</h5><p><em>实践后，再来补充</em></p><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote><ul><li><p>个人认为，<strong>组件化</strong>是<strong>业务、团队快速扩张</strong>下的新的<strong>合作分工方式</strong>；</p></li><li><p>虽然我们团队还没有这类变革诉求，但是我们能够要在各个垂直、细分领域打开局面，形成自己的<strong>产品矩阵</strong>，组件化方案或类组件化方案是必须要有人去踩坑的。</p><p>参考文章：<a href="https://www.jianshu.com/p/48fbcbb36c75" target="_blank" rel="noopener">iOS App组件化开发实践</a></p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;没有做过组件化，先自行了解下&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h5 id=&quot;1、为什么用组件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>速览FLAnimatedImage库笔记</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/14/read-FLAnimatedImage/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/14/read-FLAnimatedImage/</id>
    <published>2018-01-14T04:05:17.000Z</published>
    <updated>2018-01-14T04:08:50.080Z</updated>
    
    <content type="html"><![CDATA[<p>FLAnimatedImage库很不错，分享下我的学习笔记</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><ul><li><p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>处理网络GIF播放，是在<a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>基础上做的。</p></li><li><p><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>就主要的类是：<strong>FLAnimatedImage类</strong>和<strong>FLAnimatedImageView类</strong>。<strong>FLAnimatedImage</strong>看做个生产者，负责将GIF图片转换成一帧帧图片，提供给<strong>FLAnimatedImageView</strong>；后者可以看做是消费者，将一帧帧图片刷新显示到屏幕中。</p></li><li><p><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>中涉及一些<strong>线程安全</strong>、<strong>weakProxy</strong>、<strong>内存警告处理</strong>还是很值得借鉴的。</p></li></ul><blockquote><h4 id="二、FLAnimatedImage-类"><a href="#二、FLAnimatedImage-类" class="headerlink" title="二、FLAnimatedImage 类"></a>二、FLAnimatedImage 类</h4></blockquote><p>重要的两个方法，分别是<strong>initWithAnimatedGIFData:方法</strong> 和  <strong>imageLazilyCachedAtIndex:方法</strong></p><h5 id="1、initWithAnimatedGIFData-方法"><a href="#1、initWithAnimatedGIFData-方法" class="headerlink" title="1、initWithAnimatedGIFData: 方法"></a>1、initWithAnimatedGIFData: 方法</h5><ul><li><p>其一、获取<strong>GIF图片的信息</strong>，包括图片大小、图片帧数、首帧图片、每帧图片的属性信息(播放时间)、循环播放次数，最大缓存帧个数等。其中<strong>最大缓存帧个数</strong>是根据图片大小获得 或者 手动指定。</p></li><li><p>其二、设置个弱代理(weakProxy)，用来<strong>防止循环引用</strong>用的。</p></li><li><p>其三、将自己添加<strong>allAnimatedImagesWeak</strong>对象中（添加操作使用@synchronized保证线程安全），这是一个NSHashTable对象，当哈希表中的FLAnimatedImage对象的引用计数是0时，表中会清除该对象。</p><p><strong>说明</strong>：线程同步中，一说<strong>同步锁</strong>，很多人直觉反应，性能最差，不用；但是FLAnimatedImage库和SDWebImage都在用，应该是其<strong>使用方便</strong>所致；其本身实现很有意思，利用对象的内存地址去获取互斥锁；还添加了异常处理，如果同步某对象抛出异常时，还会释放掉锁。</p></li></ul><h5 id="2、imageLazilyCachedAtIndex-方法"><a href="#2、imageLazilyCachedAtIndex-方法" class="headerlink" title="2、imageLazilyCachedAtIndex:方法"></a>2、imageLazilyCachedAtIndex:方法</h5><ul><li><p>通过<strong>imageLazilyCachedAtIndex:方法</strong>将帧每一帧图片给FLAnimatedImageView对象展示。</p></li><li><p>根据<strong>当前的帧号</strong>(index)和<strong>当前缓存帧数</strong>(frameCacheSizeCurrent)获取接下来需要缓存的帧图片，并异步绘制出位图，并保存在内存缓存中。</p><p><strong>说明</strong>：都是提前绘制后面需要展示的图片，第一帧图片在init方法时就获得了。</p></li></ul><h5 id="3、内存警告的处理"><a href="#3、内存警告的处理" class="headerlink" title="3、内存警告的处理"></a>3、内存警告的处理</h5><ul><li><p>位图比较大，将位图缓存在内存中，即使FLAnimatedImage做了优化，当时GIF较大，或多张GIF同时播放，内存的压力会很大，很大概率收到内存警告。</p></li><li><p><strong>allAnimatedImagesWeak</strong>保存所有的FLAnimatedImage对象，收到内存警告时，通知所有FLAnimatedImage对象，当前只允许缓存一帧图片；如果接下来没有新的内存警告，慢慢恢复到定义的缓存的图片帧数；但是如果内存警告次数超过三次，以后只能缓存一帧图片。</p></li><li><p>在内存警告处理中，使用了些<strong>延迟执行</strong>的方法，防止循环引用，使用了弱代理(weakProxy)。</p></li><li><p>weakProxy是FLWeakProxy 对象；FLWeakProxy是NSProxy类子类，持有一个 weak 对象的代理，利用消息转发机制将消息的处理交给weak 对象；用来避免循环引用的一种方法，具体可以看我之前写的<a href="https://www.jianshu.com/p/5068b6f02238" target="_blank" rel="noopener">解决NSTimer/CADisplayLink的循环引用</a>。</p></li></ul><blockquote><h4 id="三、FLAnimatedImageView"><a href="#三、FLAnimatedImageView" class="headerlink" title="三、FLAnimatedImageView"></a>三、FLAnimatedImageView</h4></blockquote><h5 id="1、CADispalyLink"><a href="#1、CADispalyLink" class="headerlink" title="1、CADispalyLink"></a>1、CADispalyLink</h5><ul><li><p>CADispalyLink是个和屏幕刷新率相同的定时器，将帧图片刷新显示在屏幕上。</p></li><li><p>使用FLWeakProxy这类弱引用代理，打破循环引用；</p></li><li><p>多个处理器情况下，CADispalyLink对象默认以NSRunLoopCommonModes添加到Runloop上，避免因为列表滑动不刷新显示。</p></li><li><p>CADispalyLink的刷新时间是：每帧图片播放时间的最大公约数；因为不能保证每帧图片的播放时间是一样的，取他们的最大公约数，使得每一帧都尽可能获得其播放时间。当然也可以暴力使用平均停留时间作为CADispalyLink的刷新时间。</p></li></ul><blockquote><h4 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h4></blockquote><ul><li><p>这是之前阅读FLAnimatedImage库的笔记整理，一是本着学习的目的，二是为了评估 <strong>在列表页缩放裁剪播放n张GIF图的需求</strong>的可行性；</p></li><li><p>将<strong>GIF图片的裁剪和合成小GIF图</strong>的重任交给客户端，本身就很冒险；裁剪过程中，GIF图片的帧数多，GIF图片多，对内存的挑战是很大的，在列表中下发小的GIF图播放比较好（后台表示压力大）。</p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FLAnimatedImage库很不错，分享下我的学习笔记&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码自动生成笔记</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/13/generateCode/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/13/generateCode/</id>
    <published>2018-01-13T12:05:09.000Z</published>
    <updated>2018-01-13T12:07:46.247Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，使用脚本语言(Ruby或Python)生成些Objective-C代码，提高代码生产力。</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><ul><li><p>使用脚本生成简单的Objective-C代码，这件工作并不复杂；</p></li><li><p>先介绍<strong>Xcode自动运行脚本相关设置</strong>和 <strong>自动添加类文件到项目</strong>；</p></li><li><p>最后介绍一个使用Ruby生成Objective-C代码的<strong>实例</strong>；</p></li></ul><blockquote><h4 id="二、Xcode自动运行脚本"><a href="#二、Xcode自动运行脚本" class="headerlink" title="二、Xcode自动运行脚本"></a>二、Xcode自动运行脚本</h4></blockquote><p><strong>目标</strong>：在运行项目时自动运行脚本。考虑到可能在项目中引入比较多的脚本，建议在项目的根路径下新建一个存放脚本的文件夹；在这个文件夹中，集中管理脚本。推荐两个比较常见的设置自动运行脚本的办法。</p><h5 id="方法1：External-Build-System-外部编译系统"><a href="#方法1：External-Build-System-外部编译系统" class="headerlink" title="方法1：External Build System(外部编译系统)"></a>方法1：External Build System(外部编译系统)</h5><p>具体步骤分为以下 5 步</p><h6 id="1）新建External-Build-System"><a href="#1）新建External-Build-System" class="headerlink" title="1）新建External Build System"></a>1）新建External Build System</h6><p>在工程下添加一个<strong>target</strong>：选择Cross-platform &gt; Other &gt; External Build System，取名为CodeGenerator。</p><h6 id="2）新建shell脚本文件"><a href="#2）新建shell脚本文件" class="headerlink" title="2）新建shell脚本文件"></a>2）新建shell脚本文件</h6><p>在工程的根路径下新建一个<strong>ToolScripts</strong>文件夹，新建脚本文件，名为start.sh</p><h6 id="3）设置CodeGenerator"><a href="#3）设置CodeGenerator" class="headerlink" title="3）设置CodeGenerator"></a>3）设置CodeGenerator</h6><p>选择Targets &gt; CodeGenerator &gt;Info &gt; External Build Tool Configuration，<strong>Build Tools</strong>中填入start.sh所在的路径；<strong>Directory</strong>中填入存放所有脚本的文件夹，本例中是ToolScripts所在的位置。如果编译失败，请检查这里Directory的设置，修改成对应的位置。</p><h6 id="4）添加运行依赖"><a href="#4）添加运行依赖" class="headerlink" title="4）添加运行依赖"></a>4）添加运行依赖</h6><p>选择Targets &gt; QSRunScriptDemo &gt; Build Phase &gt; Target Dependencies,添加运行依赖。</p><h6 id="5）编译运行"><a href="#5）编译运行" class="headerlink" title="5）编译运行"></a>5）编译运行</h6><p>编译运行，选择Show the report navigator -&gt; build，可以看到对应的日志输出。</p><h5 id="方法2：项目中直接添加脚本执行"><a href="#方法2：项目中直接添加脚本执行" class="headerlink" title="方法2：项目中直接添加脚本执行"></a>方法2：项目中直接添加脚本执行</h5><p>具体步骤分为以下 4 步</p><h6 id="1）新建shell脚本文件"><a href="#1）新建shell脚本文件" class="headerlink" title="1）新建shell脚本文件"></a>1）新建shell脚本文件</h6><p>在工程的根路径下新建一个<strong>ToolScripts</strong>文件夹，新建脚本文件，名为start.sh，这步骤和方法1一样。</p><h6 id="2）添加Run-Script"><a href="#2）添加Run-Script" class="headerlink" title="2）添加Run Script"></a>2）添加Run Script</h6><p>选择Targets &gt; QSRunScriptDemo &gt; Build Phase中添加 New Run Script Phase 即可。</p><h6 id="3）设置Run-Script"><a href="#3）设置Run-Script" class="headerlink" title="3）设置Run Script"></a>3）设置Run Script</h6><p>在Run Script中设置执行start.sh命令即可。</p><h6 id="4）编译运行"><a href="#4）编译运行" class="headerlink" title="4）编译运行"></a>4）编译运行</h6><p>编译运行，选择Show the report navigator -&gt; build，可以看到对应的日志输出。</p><h5 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h5><ul><li><p>我们并没有直接设置<strong>执行Ruby 或 Python 代码</strong>，是因为这两类脚本可能并存在项目中，编译前执行shell脚本，在shell脚本中定义执行Ruby 或 Python脚本。</p></li><li><p>接下来介绍如何将生成的类文件自动添加到项目中。</p></li></ul><blockquote><h4 id="三、自动添加类文件到项目"><a href="#三、自动添加类文件到项目" class="headerlink" title="三、自动添加类文件到项目"></a>三、自动添加类文件到项目</h4></blockquote><p><strong>目标</strong>：将通过Ruby 脚本来生成类文件自动添加到项目。（手动添加也可以，但是我想偷点懒）</p><h5 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h5><ul><li><p>在Xcode项目中，我们手动添加和删除类文件，其实是在修改<strong>project.pbxproj</strong>文件。</p></li><li><p>Cocoapods提供了一个可以创建和修改 Xcode 工程文件的工具：<a href="https://github.com/CocoaPods/Xcodeproj" target="_blank" rel="noopener">Xcodeproj</a>，该工具中有<strong>Ruby 的开源库xcodeproj</strong>，可以帮助我们实现<strong>自动添加类文件到项目</strong>。（Cocoapods也是通过它自动添加文件到到项目）</p></li><li><p>我们可以通过<strong>安装Cocoapods实现安装ruby的xcodeproj库</strong>；当然也可以<strong>直接安装</strong>，执行命令gem install xcodeproj即可。无论是选择哪种方案，都需要注意使用正确的ruby源。</p></li><li><p>因为一直在使用<strong>Cocoapods</strong>，恰好在升级系统到<strong>macOS 10.13</strong>后，发现使用xcodeproj库有问题，原因是Cocoapods版本过旧，需要升级Cocoapods，升级过程中，要注意现在“taobao Gems 源已停止维护”，使用 ruby-china 提供镜像服务。下面以安装Cocoapods为例：</p><pre><code>sudo gem update --system    //升级gem，很有必要gem sources --remove https://rubygems.org/gem sources --remove https://ruby.taobao.org/       //如果安装了淘宝的镜像gem sources -a https://gems.ruby-china.org/          //保证只使用ruby-china镜像gem sources -l                                       //查看更换源结果，保证只有ruby-china镜像sudo gem uninstall cocoapods                           //如果有旧的CocoaPods，先卸载sudo gem install -n /usr/local/bin cocoapods          //安装最新的</code></pre></li></ul><h5 id="2、主要代码实现"><a href="#2、主要代码实现" class="headerlink" title="2、主要代码实现"></a>2、主要代码实现</h5><pre><code>#添加类文件到项目def add_files_to_projects(oc_file_paths,group_path)  #1、获取.xcodeproj  xcodeproj_path = File.expand_path File.join(__dir__, &quot;../&quot;, &quot;QSRunScriptDemo.xcodeproj&quot;)  project = Xcodeproj::Project.open(xcodeproj_path)  #2、获取target  target = project.targets.first  #3、创建group  generator_group = project.main_group.find_subpath(group_path, true)  generator_group.clear  generator_group.set_source_tree(&apos;SOURCE_ROOT&apos;)  #4、向group中添加文件  file_refs = []  oc_file_paths.each do |f|      unless generator_group.find_file_by_path(f)          file_ref = generator_group.new_reference(f)          file_refs &lt;&lt; file_ref      end  end  #5、将文件加入 Build Phases  target.add_file_references(file_refs)  #6、保存 project  project.saveend</code></pre><blockquote><h4 id="四、自动生成Objective-C代码实例"><a href="#四、自动生成Objective-C代码实例" class="headerlink" title="四、自动生成Objective-C代码实例"></a>四、自动生成Objective-C代码实例</h4></blockquote><p>#####1、输入：txt模板（文件名user_model.txt） #####</p><pre><code>varchar,nameint,agevarchar,addressvarchar,password</code></pre><p><strong>说明</strong>：文件名和OC类名相关，文本内每一行描述属性类型和名称。</p><p>#####2、执行脚本（自动执行） #####</p><p>在start.sh文件中输入执行脚本命令</p><pre><code>ruby generator_model/model_generator.rb</code></pre><p>#####3、输出：OC类文件及代码 #####</p><pre><code>// QSUserModel.h文件// Generated by Ruby.  DO NOT EDIT!//  Copyright © 2017年 shaoqing. All rights reserved.#import &lt;UIKit/UIKit.h&gt;@interface QSUserModel : NSObject@property (nonatomic,copy)NSString *name;@property (nonatomic,assign)NSInteger age;@property (nonatomic,copy)NSString *address;@property (nonatomic,copy)NSString *password;@end//QSUserModel.m文件// Generated by Ruby.  DO NOT EDIT!//  Copyright © 2017年 shaoqing. All rights reserved.#import &quot;QSUserModel.h&quot;@implementation QSUserModel@end</code></pre><p><strong>说明</strong>：类名QSUserModel，根据模板文件名而来；属性定义根据模板内容而来。</p><p>#####4、总结 #####</p><ul><li><p>通过ruby脚本，实现了根据模板实现了<strong>自动生成Model类</strong>和<strong>自动添加文件到项目</strong>。</p></li><li><p>在iOS项目中，脚本生成代码这类做法，不单单是帮助iOS开发减少重复工作量，从更广的范围来看，其实是为了让跨团队，跨部门的合作更加高效，更好地达成目标。</p></li><li><p>本例只是一个简单例子，主要为了说清思路，设计比较粗糙；在实际工程中，模板中需要定义的信息很多，txt并不是一个很好的选择；ruby脚本还需要更多完善的地方。</p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS开发中，使用脚本语言(Ruby或Python)生成些Objective-C代码，提高代码生产力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈iOS图片优化</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/13/imageOptimize/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/13/imageOptimize/</id>
    <published>2018-01-13T11:40:12.000Z</published>
    <updated>2018-01-26T15:27:54.543Z</updated>
    
    <content type="html"><![CDATA[<p>根据我自己的经验，说一下我对图片优化的理解。</p><blockquote><h4 id="一、他山之石"><a href="#一、他山之石" class="headerlink" title="一、他山之石"></a>一、他山之石</h4></blockquote><h5 id="1、图片的加载步骤"><a href="#1、图片的加载步骤" class="headerlink" title="1、图片的加载步骤"></a>1、图片的加载步骤</h5><p>从磁盘中加载图片，并通过UIImageVIew显示在屏幕上，需要经过以下步骤：</p><pre><code>1、从磁盘拷贝数据到内核缓冲区2、从内核缓冲区复制数据到用户空间3、生成UIImageView，把图像数据赋值给UIImageView4、如果图像数据为未解码的PNG/JPG，解码为位图数据5、CATransaction捕获到UIImageView layer树的变化6、主线程Runloop提交CATransaction，开始进行图像渲染  6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。  6.2 GPU处理位图数据，进行渲染。</code></pre><p><strong>说明1</strong>：这部分摘抄自<a href="http://blog.cnbang.net/tech/2578/" target="_blank" rel="noopener">iOS图片加载速度极限优化—FastImageCache解析</a>，它介绍了<a href="https://github.com/path/FastImageCache" target="_blank" rel="noopener">FastImageCache</a>极限优化的手段。</p><h5 id="2、FastImageCache的优化手段"><a href="#2、FastImageCache的优化手段" class="headerlink" title="2、FastImageCache的优化手段"></a>2、FastImageCache的优化手段</h5><p><em>优化有三</em>：</p><ul><li><p>使用<strong>mmap这样的内存映射方案</strong>，将文件映射进内存；比普通的<strong>read()读取</strong>少了一次内存拷贝（内核缓存区拷贝到用户内存空间）</p></li><li><p><strong>图像子线程解码</strong>，将耗时的解码工作从主线程移到了子线程; <strong>缓存解码后的位图数据</strong>到磁盘，避免重复解码。</p></li><li><p><strong>字节对齐</strong>；生成字节对齐的数据，防止CoreAnimation在渲染时再拷贝一份数据。</p></li></ul><h5 id="3、FastImageCache的缺点"><a href="#3、FastImageCache的缺点" class="headerlink" title="3、FastImageCache的缺点"></a>3、FastImageCache的缺点</h5><p><em>缺点有三</em>：</p><ul><li><p>位图数据缓要保存在磁盘，<strong>占据空间大</strong>。</p></li><li><p><strong>接口不友好</strong>，需预定义好缓存的图像尺寸。FastImageCache无法像SDWebImage那样无缝接入UIImageView。</p></li><li><p>FastImageCache库已经快4年没有新的版本更新，很多项目使用SDWebImage这样的活跃库。</p></li></ul><h5 id="4、我的拙见"><a href="#4、我的拙见" class="headerlink" title="4、我的拙见"></a>4、我的拙见</h5><ul><li><p>在项目中，为了优化，直接颠覆原来的，风险很大；但是借鉴其他好的方法，对原有的进行优化，是个值得做的事情。</p></li><li><p>图片的优化，绕不开图片的<strong>解码</strong>、<strong>缓存</strong>和<strong>下载</strong>三大件。</p></li><li><p>优化工作需要考虑 <strong>低代价高回报</strong> 这件事。</p></li></ul><blockquote><h4 id="二、本地图片加载的优化"><a href="#二、本地图片加载的优化" class="headerlink" title="二、本地图片加载的优化"></a>二、本地图片加载的优化</h4></blockquote><h5 id="1、优化的目的"><a href="#1、优化的目的" class="headerlink" title="1、优化的目的"></a>1、优化的目的</h5><p><em>目的有三：</em></p><ul><li><p><strong>减少App包的大小</strong>；图片体积的暴增最大原因之一；可能是新业务引入大量图片资源。</p></li><li><p><strong>提高图片加载的性能</strong>；使用UIImage的方法imageNamed:方法加载图片，<strong>默认在主线程解码</strong>会拖累你的APP性能。可以考虑<strong>将图片的解码放在子线程</strong>。</p></li><li><p><strong>图像不失真</strong>；JPG或PNG格式的图片展示时，可能会失真。PNG比JPG好一些。</p></li></ul><h5 id="2、优化手段"><a href="#2、优化手段" class="headerlink" title="2、优化手段"></a>2、优化手段</h5><p><em>手段有三：</em></p><ul><li><p><strong>PNG图片虽好不作为唯一的选择</strong>，本地图片可以使用其他方案代替。如<strong>矢量图PDF</strong>、<strong>ICONFONT</strong>、<strong>CG绘制</strong>。（像运营类色彩比较丰富的图片，优先使用PNG图片）</p></li><li><p><strong>缓存的使用</strong>。无论是图片的解码，还是绘制CG图片，都是个耗时耗CPU的操作，将这些结果缓存(到内存中)下来，避免重复解码和绘制，是个好的选择，这里推荐<a href="https://github.com/ibireme/YYCache" target="_blank" rel="noopener">YYCache</a>这样的方案（线程安全、LRU淘汰算法）。</p></li><li><p><strong>及时清理旧的图片资源</strong>。使用类似<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a> 清理旧的图片文件。</p><p><strong>说明</strong>：导入项目中的图片记得压缩。</p></li></ul><blockquote><h4 id="三、网络图片的优化"><a href="#三、网络图片的优化" class="headerlink" title="三、网络图片的优化"></a>三、网络图片的优化</h4></blockquote><p>相比较本地图片，它面临复杂的网络环境、复杂的图片来源。</p><h5 id="1、优化目的"><a href="#1、优化目的" class="headerlink" title="1、优化目的"></a>1、优化目的</h5><p><em>目的有三：</em></p><ul><li><p><strong>异步下载</strong>，不阻塞主线程操作；</p></li><li><p>图片<strong>快速加载显示</strong>；</p></li><li><p><strong>良好的接口</strong>，让使用者用的<em>开心</em> ；（不必关心复杂的网络环境、图片加载性能等）</p></li></ul><h5 id="2、优化手段-1"><a href="#2、优化手段-1" class="headerlink" title="2、优化手段"></a>2、优化手段</h5><p><em>手段有三：</em></p><ul><li><p><strong>使用优秀的第三方库</strong>，如<a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>。关于SDWebImage我在简书上写了文章<a href="https://www.jianshu.com/p/f3cb4ea0d14c" target="_blank" rel="noopener">SDWebImage源码理解</a>,可以看看。</p></li><li><p><strong>使用压缩比高，质量小，失真小的图片格式</strong>，如Google的Webp、Tencent的SharpP格式，这两图片文件小，很适合在网络中传输，消耗的流量少，下载快,解码快（SharpP和webp的编码慢）。</p></li><li><p><strong>结合业务需要优化图片</strong>；网络环境获取图片比较复杂，且难以预测；对下载下来的图片进行<strong>裁剪</strong>（按显示的<em>目标大小</em>、<em>是否需要圆角</em>、<em>描边</em>、<em>阴影</em>等），能很大程度上避免<strong>图片像素不对齐</strong>(图片大小和显示大小不一致)、<strong>像素混合</strong>（图层透明）、<strong>离屏渲染</strong>（圆角和阴影等）等问题。</p><p>  <strong>参考</strong>：<a href="https://cloud.tencent.com/developer/article/1004404" target="_blank" rel="noopener">图片流量节省大杀器：基于 CDN 的 sharpP 自适应图片技术实践</a></p></li></ul><h5 id="3、一些小的优化手段"><a href="#3、一些小的优化手段" class="headerlink" title="3、一些小的优化手段"></a>3、一些小的优化手段</h5><ul><li><p>要从网络中获取的<strong>重要图片</strong>（如广告、运营相关的图片），要<strong>先校验图片的完整性</strong>，校验通过才去真正处理并显示，否则不处理。</p></li><li><p>纯显示的视图，CALayer代替UIImageVIew，可以减少GPU计算（去透明/像素对齐）</p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><ul><li><p>这篇文章算是对之前写的 <a href="https://www.jianshu.com/p/a38a7c7bccbb" target="_blank" rel="noopener">网络图片的优化显示</a> 和 <a href="https://www.jianshu.com/p/26402bc4ddac" target="_blank" rel="noopener">iOS中本地图片的缩放、裁剪和压缩</a>的<strong>补充</strong>和<strong>扩展</strong>吧。</p></li><li><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据我自己的经验，说一下我对图片优化的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、他山之石&quot;&gt;&lt;a href=&quot;#一、他山之石&quot; class=&quot;headerlink&quot; title=&quot;一、他山之石&quot;&gt;&lt;/a&gt;一、他山之石&lt;/h4&gt;&lt;/blockquote&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈代码混淆</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/04/codeConfuse/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/04/codeConfuse/</id>
    <published>2018-01-04T15:21:30.000Z</published>
    <updated>2018-01-04T15:43:01.510Z</updated>
    
    <content type="html"><![CDATA[<p>代码混淆的目的，是为了对抗<strong>反编译</strong>。</p><blockquote><h4 id="一、反编译工具"><a href="#一、反编译工具" class="headerlink" title="一、反编译工具"></a>一、反编译工具</h4></blockquote><p>虽然AppleStore会对App加壳保护，但是在越狱手机上，破壳App并非不可能，失去保护的App，可以利用工具去反编译；常见的反编译工具有： <strong>class-dump</strong> 和 <strong>Hopper Disassembler</strong>；</p><h5 id="1、class-dump简介"><a href="#1、class-dump简介" class="headerlink" title="1、class-dump简介"></a>1、class-dump简介</h5><ul><li><p>下载并安装<a href="https://link.jianshu.com/?t=http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">class-dump</a>，将class-dump复制到/usr/local/bin/目录下，使用下面命令可以反编译出头文件</p><pre><code>class-dump -H xxx.app -o /Users/xxxx/Desktop/heads </code></pre></li></ul><h5 id="2、Hopper-Disassembler简介"><a href="#2、Hopper-Disassembler简介" class="headerlink" title="2、Hopper Disassembler简介"></a>2、Hopper Disassembler简介</h5><ul><li><p>下载并安装<a href="http://xclient.info/s/hopper-disassembler.html?_=ccf82bf7d0f9ec485d8d0e11710f4561" target="_blank" rel="noopener">Hopper Disassembler</a></p><pre><code>//破解办法：将Hopper Disassembler v4.app移动至应用程序文件夹双击HopperV4Patcher，将应用程序中的Hopper Disassembler v4.app拖进HopperV4Patcher完成注册</code></pre></li><li><p>解压缩App文件，获得二进制文件，直接拖进Hopper Disassembler，选择点右上角的if(b)f(x)，就可以看到类名、方法、伪代码，字符串等信息。</p></li></ul><p><strong>说明</strong>：开发中，我们可以利用Xcode在debug下编译后产生的（.app）文件, 作为反编译练习的<strong>原材料</strong>。这个文件放在<strong>/Users/user name/Library/Developer/Xcode/DerivedData/ xx Project Name/Build/Products/Debug-iphonesimulator</strong>。</p><blockquote><h4 id="二、代码混淆"><a href="#二、代码混淆" class="headerlink" title="二、代码混淆"></a>二、代码混淆</h4></blockquote><h5 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h5><ul><li><p><strong>代码混淆</strong>： 主要是混淆重要的 <strong>方法名</strong> 、 <strong>类名</strong> 和 <strong>字符串常量</strong>。（大面积的混淆没有太大意义），手段主要是利用宏定义。</p></li><li><p><strong>宏定义</strong>的关键就是<strong>替换</strong>，将A替换成B；A可以是<strong>见名知意</strong>函数名、类名或字符串常量，B可以是<strong>百思不得其解</strong>的名字或 函数 等等。</p></li><li><p>利用宏定义，做到扰乱耳目，迷惑他人的目的。</p><p><strong>说明</strong>：具体宏方便的知识，可以参考<a href="https://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p></li></ul><h5 id="2、具体方案"><a href="#2、具体方案" class="headerlink" title="2、具体方案"></a>2、具体方案</h5><ul><li><p><strong>混淆方法名 和 类名</strong></p><pre><code>单段的selector，如func: ，可以通过#define func 来实现字符串替换。多段的selector，如a:b:c: ，可以通过分别#define a 、b、c 来实现字符串替换。</code></pre></li><li><p><strong>混淆字符串常量</strong></p><p>  代码中使用的都是密文（密文通过脚本生成）；OC中定义对应的 <strong>密文转成明文</strong> 方法；这样编译出来的只有字符串常量只有密文，反编译者难以根据字符串信息，去推敲逻辑。</p></li></ul><h5 id="3、方案实现"><a href="#3、方案实现" class="headerlink" title="3、方案实现"></a>3、方案实现</h5><ul><li>脚本实现方法名 、 类名 和 字符串常量的混淆，输入是想要混淆的对象，输出是 <strong>#define 要混淆的对象  混淆内容</strong>。混淆内容可以是随机字符串等难以理解的信息。</li></ul><ul><li>考虑到方便自己、恶心别人的目的，我们将混淆结果合并在一个.h中，在工程Prefix.pch的最前面#import这个.h文件。不导入也可以编译、导入则实现混淆。</li></ul><p><strong>脚本实现如下</strong>：</p><pre><code>#!/usr/bin/python # -*- coding: utf-8 -*-import sysimport osfrom random import Randomimport time;  import base64## 执行脚本命令：python Confuse.py## ***** 工具类 *****class Util(object):    def __init__(self, arg):        super(Util, self).__init__()        self.arg = arg    # 生成随机串    @classmethod    def randomString(self,randomlength=16):        str = &apos;&apos;        chars = &apos;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz&apos;        length = len(chars) - 1        random = Random()        for i in range(randomlength):            str += chars[random.randint(0, length)]        return str    @classmethod    def loadFileCotent(self,filePath):        contents = []        with open(filePath) as f:            line = f.readline()            while line:                contents.append(line.rstrip(&apos;\n&apos;))                 line = f.readline()        return contents    #加密（可以换成你想要的加密方法）    @classmethod    def encrypt(self,content):        res = &apos; &apos;.join([bin(ord(c)).replace(&apos;0b&apos;, &apos;&apos;) for c in content])        return base64.b64encode(res)    # 解密 (需要OC代码实现一份)    @classmethod    def decrypt(self,content):        return &apos;&apos;.join([chr(i) for i in [int(b, 2) for b in base64.b64decode(content).split(&apos; &apos;)]])#混淆函数名和方法名def confuseFunc(filePath):    originContents = Util.loadFileCotent(filePath)    confuseRes = &apos;&apos;    for i in range(0,len(originContents)):        outStr = &quot;#define &quot; + originContents[i] + &quot; &quot; + Util.randomString() + &quot;\n&quot;        confuseRes = confuseRes + outStr    #返回混淆结果    return confuseRes#混淆字符串def confuseText(filePath):    originContents = Util.loadFileCotent(filePath)    confuseRes = &apos;&apos;    for i in range(0,len(originContents)):        text = originContents[i]        text_encrypted = Util.encrypt(text)        # print &quot;decrypt&quot;,Util.decrypt(text_encrypted)        outStr = &quot;#define kKBParameter%sKey  QSString(@\&quot;%s\&quot;)\n&quot; %(text.capitalize(),text_encrypted)        confuseRes = confuseRes + outStr    #返回混淆结果    return confuseResconfuse_file_name =  &quot;QSConfuseHeader&quot;if __name__ == &apos;__main__&apos;:    fileContent = &apos;&apos;&apos;////  &apos;&apos;&apos; + confuse_file_name + &apos;&apos;&apos;//  XXProject////  Created on&apos;&apos;&apos; + time.asctime( time.localtime(time.time()) ) + &apos;&apos;&apos;!\n #ifndef &apos;&apos;&apos; + confuse_file_name + &apos;&apos;&apos;_h#define &apos;&apos;&apos; + confuse_file_name + &apos;&apos;&apos;_h\n\n&apos;&apos;&apos;    confuseFuncContent = confuseFunc(&quot;func_class.txt&quot;)    if len(confuseFuncContent) &gt; 0:        fileContent += &quot;\n//函数混淆\n&quot; + confuseFuncContent    confuseTextContent = confuseText(&quot;string.txt&quot;)    if len(confuseTextContent) &gt; 0:        fileContent += &quot;\n//字符串混淆\n&quot; + confuseTextContent    endFileContent = &quot;\n\n#endif /* &quot; + confuse_file_name + &quot;_h */&quot;    if len(fileContent) &gt; 0:        fileContent+= endFileContent        print fileContent        # 打开一个文件        outputFile = open(confuse_file_name + &quot;.h&quot;, &quot;wb&quot;)        outputFile.write(fileContent)        # 关闭打开的文件        outputFile.close()</code></pre><p>   <strong>说明1</strong>：目前需要混淆内容放在txt文件（需要混淆函数名和类名放在func_class.txt，需要混淆字符串常量放在string.txt中）；进一步做法是，给需要混淆的字符串打上标记，然后用脚本搜索这些需要混淆的对象，实现混淆；</p><p>  <strong>说明2</strong>：代码混淆需要考虑代码的可读性，建议做法是，对应混淆后的结果使用<strong>宏定义</strong>替换，类似于</p><pre><code>//QSString(x)是个宏方法，定义是解密实现，在OC中实现#define kKBParameterGoodKey  QSString(@&quot;MTEwMDExMSAxMTAxMTExIDExMDExMTEgMTEwMDEwMA==&quot;)</code></pre><p>  <strong>说明3</strong>：在脚本中，加密方法并非真正的加密，只是将字符串转成二进制，再Base64编码而已；这个根据自己业务需要增加真正的加密算法，对应的解密算法放在OC中实现。</p><p>  <strong>其他参考</strong><a href="http://blog.csdn.net/yiyaaixuexi/article/details/29201699" target="_blank" rel="noopener">iOS安全攻防（二十三）：Objective-C代码混淆</a></p><blockquote><h4 id="三、关键逻辑混淆"><a href="#三、关键逻辑混淆" class="headerlink" title="三、关键逻辑混淆"></a>三、关键逻辑混淆</h4></blockquote><p>提供两种方案</p><h5 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h5><ul><li><p>把函数名隐藏在结构体里，以函数指针成员的形式存储。</p></li><li><p>编译后，只留了下地址，去掉了名字和参数表，提高了逆向成本和攻击门槛。</p></li><li><p>具体参考<a href="http://blog.csdn.net/yiyaaixuexi/article/details/29210413" target="_blank" rel="noopener">iOS安全攻防（二十四）：敏感逻辑的保护方案（1）</a></p></li></ul><h5 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h5><ul><li><p>使用C/C++语言实现逻辑，这里利用到Objective-C 与 C/C++混编的知识。下面以C++为例，混编最需要注意的是<strong>OC 调用 C++</strong>和<strong>C++ 调用 OC</strong></p></li><li><p><strong>OC 调用 C++</strong>：这种情况比较简单，因为编译器做了优化，把 .m 文件直接改为 <strong>.mm</strong> ，然后直接用就好了。</p></li><li><p><strong>C++ 调用 OC</strong>：分为两种情况：1）完全的 C++ ，实现文件以 .cpp 结尾，里面不允许直接OC的方法；通过编写接口，间接调用 OC 方法，实际上 C++ 调用的是OC编译过后的 .o 文件；2）部分 C++ 部分 OC ，实现文件以 .mm 结尾，里面允许直接使用 OC 方法。</p></li></ul><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote><ul><li>代码混淆只是提高了破解的门槛和难度，不能百分百保证代码安全，但是如果不做这些，你的核心业务无疑在裸奔，这是很危险的事情。</li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码混淆的目的，是为了对抗&lt;strong&gt;反编译&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、反编译工具&quot;&gt;&lt;a href=&quot;#一、反编译工具&quot; class=&quot;headerlink&quot; title=&quot;一、反编译工具&quot;&gt;&lt;/a&gt;一、反编译工具&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈AES</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/03/AESIntro/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/03/AESIntro/</id>
    <published>2018-01-03T15:23:50.000Z</published>
    <updated>2018-01-03T15:29:50.396Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><ul><li><p><strong>对称加密</strong>比<strong>非对称加密</strong>要快。频繁的数据加密，优先考虑使用<strong>对称加密</strong>。</p></li><li><p>DES -&gt; 3DES -&gt; <strong>AES</strong>（Advanced Encryption Standard，高级加密标准）；目前对称加密使用<strong>AES</strong>为佳，它已经取代DES和3DES对称算法了。</p></li><li><p>AES是项目中使用较多的对称加密算法，本文简单介绍下AES。</p></li></ul><blockquote><h4 id="二、AES算法的重要组成"><a href="#二、AES算法的重要组成" class="headerlink" title="二、AES算法的重要组成"></a>二、AES算法的重要组成</h4></blockquote><h5 id="1、密钥长度（Key-Size）"><a href="#1、密钥长度（Key-Size）" class="headerlink" title="1、密钥长度（Key Size）"></a>1、密钥长度（Key Size）</h5><p>  AES算法规定密钥长度有三种：128bits、192bits和256 bits。其中<strong>128 bits的key可以满足大部分业务需求</strong>。</p><h5 id="2、加密模式（Cipher-Mode）"><a href="#2、加密模式（Cipher-Mode）" class="headerlink" title="2、加密模式（Cipher Mode）"></a>2、加密模式（Cipher Mode）</h5><p>   AES属于块加密（Block Cipher），加密数据块（Block）必须为<strong>128bits（16字节）</strong>；加密模式主要有以下<strong>六种</strong>模式：</p><p><strong>1) ECB (Electronic Codebook Book，电子密码本模式)</strong></p><ul><li><p><strong>简介</strong>：将数据分成若干块，分别对每块进行加密，最后将这些密文块组成最后的加密结果</p></li><li><p><strong>说明</strong>：最简单的模式，安全性较低。因为ECB的明文分组与密文分组是一一对应的关系，如果明文中存在多个相同的明文分组，其对应的密文分组也是相同的；<strong>不推荐使用</strong>。</p></li></ul><p><strong>2) CBC（Cipher Block Chaining，密码分组链接模式)</strong></p><ul><li><p><strong>简介</strong>：将数据分块后，每一块数据与上一块密文XOR（异或）后，再进行加密；</p></li><li><p><strong>说明</strong>：比较推荐使用的模式（但Apple已经不推荐使用CBC模式，建议使用<strong>GCM</strong>模式）。</p></li></ul><p><strong>3) CTR(Counter，计数器模式)</strong></p><ul><li><p><strong>简介</strong>：通过将<strong>逐次累加的计数器</strong>进行加密来生成密钥流的流密码；最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR得到的。</p></li><li><p><strong>说明</strong>：比较推荐使用的模式</p></li></ul><p><strong>4) CFB(Cipher FeedBack,密码反馈模式)</strong></p><ul><li><p><strong>简介</strong>：和CBC类似，加密模式和CBC类似，但其可以将块密码变为自同步的流密码。</p></li><li><p><strong>说明</strong>：不推荐使用的模式</p></li></ul><p><strong>5) OFB(Output FeedBack, 输出反馈模式)</strong></p><ul><li><p><strong>简介</strong>：将块密码变成同步的流密码，它产生密钥流的块，然后将其与明文块进行异或，得到密文。</p></li><li><p><strong>说明</strong>：不推荐使用的模式</p></li></ul><p><strong>6) GCM(Galois/Counter Mode,)</strong></p><ul><li><p><strong>简介</strong>：GCM中的G就是指GMAC(消息验证码)，C就是指CTR(计数器模式)</p></li><li><p><strong>说明</strong>：GCM可以提供对消息的加密和完整性校验，AES模式最好选择。</p></li></ul><p><strong>总结</strong>: 推荐先后顺序：<strong>GCM &gt; CTR &gt; CBC</strong>；详细内容可以参考<a href="https://xiaoxueying.gitbooks.io/graphic-cryptology/content/block_cipher_mode.html" target="_blank" rel="noopener">Block cipher mode</a>、<a href="http://blog.csdn.net/T0mato_/article/details/53160772" target="_blank" rel="noopener">AES-GCM加密算法</a></p><h5 id="3、填充方式（Padding）"><a href="#3、填充方式（Padding）" class="headerlink" title="3、填充方式（Padding）"></a>3、填充方式（Padding）</h5><p>  1）<strong>块加密</strong>要求对<strong>特定长度的数据块</strong>进行加密，因此<strong>CBC模式</strong>、<strong>ECB模式</strong>需要在最后一数据块加密前进行数据填充。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）。</p><p>  2）iOS SDK中提供了<strong>PKCS7Padding</strong>，Java提供了<strong>PKCS5Padding</strong>。原则上PKCS5Padding限制了填充的Block Size为8 字节（大于8 字节，填充和PKCS7Padding相同），而PKCS7Padding的Block Size可以为1到255字节; 填充值的算法（需要填充x个字节，填充的值就是x）都是一样的：</p><pre><code>value = k - (l mod k)  ,K = 块大小，l = 数据长度；假设k是16，I是5,那么value是11，也就是说，需要填充11个byte的 0x0B(十进制是11)</code></pre><p>  3）因为<strong>AES加密数据块</strong>Block Size规定为16字节(<em>128bits</em>), 大于8 字节(64 bits), 所以<strong>PKCS5Padding和PKCS7Padding填充效果</strong>是一样的。</p><p>  <strong>说明</strong>：数据块的长度如果是16倍数，padding长度为16，padding值为0x10。即在输入后面补齐16字节的0x10；如果数据块的长度不是16倍数，padding长度为16-L%16，padding值为16-L%16。即在输入后面补齐16-L%16的字节，值为16-L%16。</p><p>  4）平时使用最多的是PKCS7Padding，NoPadding、ISO10126Padding和ZeroPadding忽略不提。</p><h5 id="4、初始向量（Initialization-Vector）"><a href="#4、初始向量（Initialization-Vector）" class="headerlink" title="4、初始向量（Initialization Vector）"></a>4、初始向量（Initialization Vector）</h5><p>  CBC、CFB和OFB这些加密模式需要传入一个初始向量，其大小与Block Size相等；当不传入初始向量时，系统将默认使用一个全0的初始向量。</p><blockquote><h4 id="三、AES算法Python实现"><a href="#三、AES算法Python实现" class="headerlink" title="三、AES算法Python实现"></a>三、AES算法Python实现</h4></blockquote><p><strong>说明</strong>：使用Python的加密包<a href="https://pypi.python.org/pypi/pycrypto" target="_blank" rel="noopener">pycrypto</a> (下载后，执行<em>python setup.py build + python setup.py install</em>)，实现AES的ECB、CBC、CTR、CFB和OFB模式下的加密和解密；定义一个PaddingHelper类，实现PKCS7Padding；</p><pre><code>#!/usr/bin/python # -*- coding:utf-8 -*-import sysimport osimport base64from Crypto.Cipher import AESfrom Crypto.Util import Counter# ***** Padding Helper For AES *****class  PaddingHelper(object):    &quot;&quot;&quot;docstring for  Padding Helper&quot;&quot;&quot;    def __init__(self, arg):        super(PaddingHelper, self).__init__()        self.arg = arg    # 保证keyStr的长度是16    @classmethod    def validKeyStr(self,keyStr):            keySize = 16        if len(keyStr) &lt; keySize:            zeroCount = keySize - len(keyStr) % keySize              for i in range(0, zeroCount):                  keyStr = keyStr + &apos;\0&apos;         else:            return keyStr[0:keySize]        return keyStr      # 实现PKCS7Padding/PKCS7Padding    @classmethod    def PKCS7Padding(self,text,blockSize=16):            count = len(text)            mod_num = count % blockSize        add_num = blockSize - mod_num        return text + chr(add_num) * add_num        @classmethod    def MovePKCS7Pading(self,text,blockSize=16):        lastChar = text[-1]            paddingLen = ord(lastChar)        # 截取最后一部分填充快        lastChunk = text[-paddingLen:]        if lastChunk == chr(paddingLen) * paddingLen:            # 移除填充部分           return text[:-paddingLen]        return text     # AES PSK7/PSK5填充class AESUtil():    def __init__(self, key, model):        self.key = PaddingHelper.validKeyStr(key)        self.mode = model        self.iv = key   #初始向量初始化k，可以是别的值，但必须16字节    #加密函数，如果text不是16的倍数,那就补足为16的倍数    def encrypt(self, text):        if self.mode == AES.MODE_CTR:             # Create new AES CTR object #            cryptor = AES.new(self.key, self.mode, counter=Counter.new(128))        else:            cryptor = AES.new(self.key, self.mode, self.iv)        text = PaddingHelper.PKCS7Padding(text,16)        ciphertext = base64.b64encode(cryptor.encrypt(text))        return ciphertext    #解密后，去掉补足的空格用strip() 去掉    def decrypt(self, text):           if self.mode == AES.MODE_CTR:             # Create new AES CTR object #            cryptor = AES.new(self.key, self.mode, counter=Counter.new(128))        else:                cryptor = AES.new(self.key, self.mode, self.iv)        plainText = cryptor.decrypt(base64.b64decode(text))        return PaddingHelper.MovePKCS7Pading(plainText)if __name__ == &apos;__main__&apos;:    encrykey = &quot;0123456789abcdef&quot;    # plainText = &apos;1234567891234567&apos;    plainText = &apos;hello world&apos;    dict = {&quot;CBC模式&quot;: AES.MODE_CBC,             &quot;CFB模式&quot;: AES.MODE_CFB,             &quot;CTR模式&quot;: AES.MODE_CTR,            &quot;ECB模式&quot;: AES.MODE_ECB,            &quot;OFB模式&quot;: AES.MODE_OFB};    for key, value in dict.iteritems():        aes = AESUtil(encrykey,value)        encryptText = aes.encrypt(plainText)        print &quot;**********%s 加解密*******&quot; %(key)        print &quot;密文:&quot;,encryptText        print &quot;明文:&quot;,aes.decrypt(encryptText)</code></pre><p><strong>执行脚本的输出结果如下</strong></p><pre><code>**********ECB模式 加解密*******密文: gWm+1O9JqIdFWcWyANqt5w==明文: hello world**********CFB模式 加解密*******密文: GsZEtzHsqRLRjxfUU6T0Zg==明文: hello world**********CBC模式 加解密*******密文: wem0Upqsl5MBD0Z39jWO/g==明文: hello world**********OFB模式 加解密*******密文: GhcS5HH8im5yy3xtfAywYA==明文: hello world**********CTR模式 加解密*******密文: adUgVHVGk4Y3/LZatTZf6Q==明文: hello world</code></pre><blockquote><h4 id="四、AES算法使用说明"><a href="#四、AES算法使用说明" class="headerlink" title="四、AES算法使用说明"></a>四、AES算法使用说明</h4></blockquote><ul><li><p>对AES加密的结果，要使用<strong>Base64编码</strong>。因为其加密结果得到的字符串可能有不可见字符，保存和传输都有问题；把数据做Base64编码，统统变成可见字符。（Base64编码 将二进制流中每6个bit一组表示数据, 不足的部分补零,每两个0 用 一个 = 表示，把含有不可见字符串的信息用可见字符串表示出来 ）；对应的AES解密时，先要进行Base64解码</p></li><li><p>AES有很明显的优势：<strong>安全</strong>、<strong>加解密快</strong>（AES比RSA的加解密快1000倍）；但是劣势也明显，需重点保护<strong>密钥</strong>的安全；在实践中推荐组合使用<strong>AES</strong>和<em>*RSA</em>技术。</p></li><li><p>实践中<strong>常见的方案</strong>是：1）用AES来加密数据；2）AES的密钥通过<strong>伪随机数生成器</strong>生成；3）AES的密钥通过<strong>RSA公钥加密</strong>；4）最终将AES密钥的密文 和 数据的密文交给后台，后台利用对应的策略解密。</p></li><li><p>AES算法流程可以参考<a href="http://www.cnblogs.com/luop/p/4334160.html" target="_blank" rel="noopener">密码算法详解——AES</a></p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;对称加密&lt;/strong&gt;比&lt;str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈数据加密</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/01/dataEnctypt/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/01/dataEnctypt/</id>
    <published>2018-01-01T15:17:34.000Z</published>
    <updated>2018-01-03T15:23:25.008Z</updated>
    
    <content type="html"><![CDATA[<p><strong>导语：</strong>本文介绍常用的数据加密方式（不仅仅局限在iOS中使用）。</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><p>加密是用来避免攻击这盗取信息的一种手段，加密算法主要有三类：<strong>Hash算法</strong>、<strong>对称加密算法</strong> 和 <strong>非对称加密算法</strong>。</p><h5 id="1、Hash算法"><a href="#1、Hash算法" class="headerlink" title="1、Hash算法"></a>1、Hash算法</h5><ul><li><p><strong>Hash算法</strong> 把一个任意长度的字节串映射 为一定长度的十六进制的数字串；这个数字串称为<strong>哈希值</strong>。</p></li><li><p>Hash算法一种<strong>单向算法</strong>，不能通过这个Hash值重新获得目标信息；一般用来<strong>存储不可还原的密码</strong> 或 <strong>检验数据的完整性</strong>，常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA</p></li><li><p><strong>重点说明</strong>：MD2、MD4、MD5还有SHA-1都已经被碰撞攻击突破，Apple已经移除对MD5和SHA-1签名证书的信任，对于安全性较高的数据，建议使用<strong>SHA-2 Family</strong> 或其他能避免碰撞攻击的算法。</p></li></ul><h5 id="2、对称加密算法"><a href="#2、对称加密算法" class="headerlink" title="2、对称加密算法"></a>2、对称加密算法</h5><ul><li><p><strong>对称加密算法</strong>是指：加密和解密使用<strong>相同密钥</strong>的加密算法。对称加密算法的加解密的速度快，通常在大量数据加密时使用。</p></li><li><p>常见的对称加密算法有DES算法，3DES算法，TDEA算法，Blowfish算法，RC5算法，IDEA算法和AES算法。</p></li><li><p><strong>重点说明</strong>：DES 、3DES 已经被AES（Advanced Encryption Standard，高级加密标准）替代了；<strong>AES-ECB</strong>(电子密码本模式)最简单，安全性差，不建议使用，可以使用<strong>AES-CBC</strong>、<strong>AES-CTR</strong>、<strong>AES-GCM</strong>（Apple推荐的）；对称密钥的安全是必须要考虑并且解决的事情。</p></li></ul><h5 id="3、非对称加密"><a href="#3、非对称加密" class="headerlink" title="3、非对称加密"></a>3、非对称加密</h5><ul><li><p><strong>非对称加密算法</strong>是指：加密和解密使用<strong>不同密钥</strong>的加密算法，也称为公私钥加密，适合对少量数据的加密。</p></li><li><p>非对称加密算法的公钥是公开的，秘钥是自己保存的，比对称加密有更好的安全性，但是加解密速度要远远慢于对称加密；常见的非对称加密算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p></li><li><p><strong>重点说明</strong>：<strong>RSA</strong>是使用最广的非对称加密算法，但是小于1024位的RSA私钥很容易被分解攻击，出于安全的考虑，建议在项目中使用大于等于2048位的RSA私钥。</p></li></ul><blockquote><h4 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h4></blockquote><ul><li><p>对<strong>大量数据(较大量的上报信息)</strong>加密，建议使用AES；对于<strong>少量数据（手机号、邮箱等）</strong>加密，建议使用RSA；对于比较重要的<strong>资源下载（如运营活动图片、配置数据等）</strong>，对下载下来的数据，要校验hash值，防止数据被篡改，保证数据的完整性。</p></li><li><p>对于核心的业务功能的数据，仅仅靠一种加密算法是不够的，综合利用<strong>两三种加解密算法</strong>，实现业务目标的同时，<strong>提高被破解的难度</strong>。</p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;导语：&lt;/strong&gt;本文介绍常用的数据加密方式（不仅仅局限在iOS中使用）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>再见2017</title>
    <link href="http://buaa0300/nanhuacoder.com/2017/12/31/newStart/"/>
    <id>http://buaa0300/nanhuacoder.com/2017/12/31/newStart/</id>
    <published>2017-12-31T10:09:31.000Z</published>
    <updated>2018-01-01T15:18:36.152Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="再见2017"><a href="#再见2017" class="headerlink" title="再见2017"></a>再见2017</h4></blockquote><ul><li><p><strong>2017年</strong> 就这么匆匆而去，毕业工作快满2年了；从17年4月开始，断断续续在简书上写了些技术文章；而今回头看看，文章存在许多不足；最后两个月因为项目太忙(也有懒的原因)，几乎断更了。</p></li><li><p><strong>两年</strong>的时间，对于一个iOS Developer来说，不算短的时间，眼看要<strong>奔三</strong>了，带着2017的遗憾，怀着对2018年的美好憧憬，忐忑前行。</p></li><li><p>之前的文章大概写了6w字，依然保存在<a href="https://www.jianshu.com/u/7d197f08438f" target="_blank" rel="noopener">南华coder的简书</a>，新的文章将在这里继续。</p></li></ul><blockquote><h4 id="新的选择（Hex-Github）"><a href="#新的选择（Hex-Github）" class="headerlink" title="新的选择（Hex + Github）"></a>新的选择（Hex + Github）</h4></blockquote><p><strong>Hex</strong>是个不错的博客框架，结合Github，可以实现低成本(<em>学习成本和经济成本</em>) 、快速实现搭建个人博客的梦想。主要分以下几个步骤</p><h5 id="1、安装和建站"><a href="#1、安装和建站" class="headerlink" title="1、安装和建站"></a>1、安装和建站</h5><pre><code>//npm 安装 Hexo。npm install hexo-cli -g//初始化hexo文件夹hexo init &lt;folder&gt;//进入文件夹cd &lt;folder&gt;//新建所需要的文件npm install</code></pre><p>  <strong>新建完成后，指定文件夹的目录如下</strong>：</p><pre><code>.├── _config.yml (网站的配置信息，在此配置大部分的参数)├── package.json (应用程序的信息)├── scaffolds (模版文件夹, 新建文章时，Hexo根据 scaffold 来建立文件)├── source (资源文件夹)|   ├── _drafts|   └── _posts└── themes (主题文件夹, Hexo 会根据主题来生成静态页面)</code></pre><h5 id="2、配置-config-yml"><a href="#2、配置-config-yml" class="headerlink" title="2、配置_config.yml"></a>2、配置_config.yml</h5><pre><code># Sitetitle: 南华coder的空间subtitle:description: 曾经仗剑走天涯,如今沉醉代码忙author: 南华coderlanguage: zh-Hanstimezone:avatar: /uploads/avatar.jpeg</code></pre><p><strong>注意</strong>：冒号(:)后要有空格</p><h5 id="3、新建文件和本地发布"><a href="#3、新建文件和本地发布" class="headerlink" title="3、新建文件和本地发布"></a>3、新建文件和本地发布</h5><pre><code>// layout是文章的布局，默认是post，可以通过修改 _config.yml 中的   // default_layout 参数来指定默认布局; 默认以标题做为文件名称hexo new [layout] &lt;title&gt;//生成静态页面hexo generate //本地发布hexo server</code></pre><p><strong>注意</strong>：可以使用 hexo s -g 实现生成页面和本地部署，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 可以看到效果。</p><h5 id="4、部署到Github上"><a href="#4、部署到Github上" class="headerlink" title="4、部署到Github上"></a>4、部署到Github上</h5><pre><code># 修改_config.yml文件,添加Github仓库的地址deploy:  type: git  repo: https://github.com/buaa0300/buaa0300.github.io.git  branch: master // 生成页面 hexo g 或 hexo generate // 部署 hexo d 或 hexo deploy</code></pre><p><strong>说明</strong>：可以使用 hexo d -g 实现生成页面和部署</p><h5 id="5、主题"><a href="#5、主题" class="headerlink" title="5、主题"></a>5、主题</h5><p>Hexo还提供了许多主题，让你的页面看起来更漂亮，我选择比较大众化的<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a></p><pre><code>//下载cd themesgit clone https://github.com/iissnan/hexo-theme-next//修改根路径下的_config.yml (网站的配置信息）theme: hexo-theme-next//修改主题样式(themes/hexo-theme-next/_config.yml)# Muse是默认样式#scheme: Muse  #scheme: Mist#scheme: Piscesscheme: Gemini</code></pre><h5 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h5><p>其他详细内容可以参考<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a>、<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">手把手教你用Hexo+Github 搭建属于自己的博客</a></p><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>我是<a href="https://buaa0300.github.io/" target="_blank" rel="noopener">南华coder</a>，一名北漂的iOS程序猿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;再见2017&quot;&gt;&lt;a href=&quot;#再见2017&quot; class=&quot;headerlink&quot; title=&quot;再见2017&quot;&gt;&lt;/a&gt;再见2017&lt;/h4&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;2017年&lt;/str
      
    
    </summary>
    
    
  </entry>
  
</feed>
