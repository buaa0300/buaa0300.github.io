<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>南华coder的空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://buaa0300/nanhuacoder.com/"/>
  <updated>2019-03-23T07:42:53.870Z</updated>
  <id>http://buaa0300/nanhuacoder.com/</id>
  
  <author>
    <name>南华coder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Core Animation</title>
    <link href="http://buaa0300/nanhuacoder.com/2019/03/23/iOS17-core-aniamtion/"/>
    <id>http://buaa0300/nanhuacoder.com/2019/03/23/iOS17-core-aniamtion/</id>
    <published>2019-03-23T07:36:48.000Z</published>
    <updated>2019-03-23T07:42:53.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ul><li><p>iOS主要的<strong>绘图系统</strong>有UIKit、<strong>Core Animation</strong>、Core Graphics、OpenGL ES和Core Image等。</p></li><li><p>Core Animation并非是搞高端动画的库。它是一个用于管理视图排版、合成、渲染以及动画的基础 库，最终的渲染工作是交给Graphics Hardware(GPU)处理。</p></li><li><p><strong>UIKit 建立在 Core Animation 基础之上，在 Core Animation 之下是 OpenGL ES 和 Core Graphics，分别对应 GPU 和 CPU。</strong></p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/201701-e511da597e5f480b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p><p>​              </p><h3 id="二、Core-Animation-Pipeline（流水线）"><a href="#二、Core-Animation-Pipeline（流水线）" class="headerlink" title="二、Core Animation Pipeline（流水线）"></a>二、Core Animation Pipeline（流水线）</h3><p><img src="https://upload-images.jianshu.io/upload_images/201701-b91953f039c0ddf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p><p>Core Animation的<strong>绘制和渲染</strong>是通过<strong>Core Animation Pipeline</strong>实现，它以流水线的形式进行渲染，具体分为四个步骤：</p><h4 id="1）Commit-Transaction"><a href="#1）Commit-Transaction" class="headerlink" title="1）Commit Transaction"></a>1）Commit Transaction</h4><p>​      具体可以细分为四个阶段</p><ul><li><ul><li><strong>Layout</strong>: 构建视图层级，设置图层属性（如位置，背景色，边框等）</li></ul></li><li><ul><li><strong>Display</strong>: 图层的寄宿图片被绘制的阶段。绘制有可能涉及你的-drawRect:和-drawLayer:inContext:方法的调用路径。</li></ul></li><li><ul><li><strong>Prepare</strong>: 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</li></ul></li><li><ul><li><strong>Commit</strong>: 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</li></ul></li></ul><h4 id="2）Render-Server"><a href="#2）Render-Server" class="headerlink" title="2）Render Server"></a>2）Render Server</h4><p>​    负责渲染工作，会解析上一步Commit Transaction中提交的信息并<strong>反序列化成渲染树</strong>（render tree)，随后根据layer的各种属性生成绘制指令，并在下一次VSync(垂直同步)信号到来时调用OpenGL进行渲染。</p><h4 id="3）GPU"><a href="#3）GPU" class="headerlink" title="3）GPU"></a>3）GPU</h4><ul><li>GPU会等待显示器的VSync信号发出后才进行OpenGL渲染管线，将3D几何数据转化成2D的像素图像和光栅处理，随后进行新的一帧的渲染，并将其输出到缓冲区。</li></ul><h4 id="4）Display"><a href="#4）Display" class="headerlink" title="4）Display"></a>4）Display</h4><ul><li>从缓冲区中取出画面，并输出到屏幕上</li></ul><p><strong>说明1</strong>：开发者真正能做的，只是在<strong>Layout</strong>(布局)<strong>和Display</strong>(显示)环节</p><p><strong>说明2</strong>：</p><ul><li><p>某个视图的图层属性所做的修改，都是在当前Runloop结束之前，Core Animation才将修改提交；</p></li><li><p>因为Core Animation的Commit Transaction是在主线程完成的，虽然Core Animation也支持异步渲染，但是UIKit就是把这些个事情放在主线程做。</p></li></ul><blockquote><p>VSync（vertical sync）是指垂直同步，在玩游戏的时候在设置的时候应该会看见过这个选项，这个机制能够让显卡和显示器保持在一个相同的刷新率从而避免画面撕裂。在iOS中，屏幕具有60Hz的刷新率，这意味着它每秒需要显示60张不同的图片（帧），但GPU并没有一个确定的刷新率，在某些时候GPU可能被要求更强力的数据输出来确保渲染能力，这时候他们可能比屏幕刷新率（60Hz）更快，就会导致屏幕不能完整的渲染所有GPU给他的数据，因为它不够快，屏幕的上一帧还没渲染完，下一帧就已经到来了，这就导致画面的撕裂。</p><p>这个时候我们就要引入VSync了，简单来说它就是让显卡保持他的输出速率不高于屏幕的刷新率，启用了VSync后，GPU不再会给你可怜的60Hz屏幕每秒发送100帧了，它会增加每一帧的发送间隔，确保显示器能够有充足的时间去处理每一帧。</p></blockquote><h3 id="三、UIKit"><a href="#三、UIKit" class="headerlink" title="三、UIKit"></a>三、UIKit</h3><h4 id="1、UIKit不是线程安全的"><a href="#1、UIKit不是线程安全的" class="headerlink" title="1、UIKit不是线程安全的"></a>1、UIKit不是线程安全的</h4><ul><li>UIKit中，很多类中大部分的属性都被修饰为<strong>nonatomic</strong>，这意味着它们不能在多线程的环境下工作，而对于UIKit这样一个庞大的框架，将其所有属性都设计为线程安全是不现实的，这可不仅仅是简单的将nonatomic改成atomic或者是加锁解锁的操作，还涉及到很多的方面：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) 假设能够异步设置view的属性，那我们究竟是希望这些改动能够同时生效，还是按照各自runloop的进度去改变这个view的属性呢？</span><br><span class="line"></span><br><span class="line">2) 假设UITableView在其他线程去移除了一个cell，而在另一个线程却对这个cell所在的index进行一些操作，这时候可能就会引发crash。</span><br><span class="line"></span><br><span class="line">3) 如果在后台线程移除了一个view，这个时候runloop周期还没有完结，用户在主线程点击了这个“将要”消失的view，那么究竟该不该响应事件？在哪条线程进行响应？</span><br></pre></td></tr></table></figure><p> <strong>总结</strong>：</p><ul><li><p>将UIKit设置为线程安全并不能带来太多便利，也不会提升太多的性能表现，甚至会因为加锁解锁而耗费大量的时间。</p></li><li><p>事实上并发编程也没有因为UIKit是线程不安全而变得困难，我们所需要做的只是要确保UI操作在主线程进行就可以了。</p></li></ul><p>2、UIKit为什么选择主线程</p><ul><li>UIApplication在<strong>主线程</strong>所初始化的Runloop我们称为<strong>Main Runloop</strong>，它负责处理app存活期间的大部分事件，如<strong>用户交互</strong>等，它一直处于不断处理事件和休眠的循环之中，以确保能尽快的将用户事件传递给GPU进行渲染，使用户行为能够得到响应，画面之所以能够得到不断刷新也是因为Main Runloop在驱动着。</li></ul><ul><li>而每一个<strong>view的变化的修改并不是立刻变化，相反的会在当前RunLoop的结束的时候统一进行重绘</strong>，这样设计的目的是为了能够在一个Runloop里面处理好所有需要变化的view，包括resize、hide、reposition等等，所有view的改变都能在同一时间生效，这样能够更高效的处理绘制，这个机制被称为<strong>绘图循环（View Drawing Cycle</strong>)。</li></ul><ul><li><strong>如果我们的UIKit并不是在主线程，所以Main Runloop中的事件需要跨线程进行传输，这样会导致显示与用户事件并不同步；</strong></li></ul><ul><li>这是因为点击等事件是由系统传递给UIApplication中，并在Main Runloop中进行处理与响应，但是由于UI在后台线程中进行处理，所以他跟事件响应并不同步。即使在UI所在的后台线程也自己维护了一个Runloop，在Runloop结束时候进行渲染。</li></ul><ul><li>UI操作涉及到渲染访问各种View对象的属性，如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度。另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。</li></ul><p>3、其他</p><ul><li>AsyncDisplayKit（现命名为Texture，建立在UIKit之上的iOS框架简述如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Texture的基本单位就是node。 **ASDisplayNode**是一个抽象UIView，j就想UIView是一个抽象CALayer。不同于只能在主线程上使用的视图，nodes是线程安全的：您可以在后台线程上并行实例化和配置它们的整个层次结构。</span><br><span class="line"></span><br><span class="line">为了保持其用户界面的流畅和响应，您的应用程序应该以每秒60帧的速度呈现 - iOS上的黄金标准。这意味着主线程有一秒钟的时间推动每个帧。这是执行所有布局和绘图代码的16毫秒！并且由于系统开销，您的代码通常在导致帧丢失之前运行不到10毫秒。</span><br><span class="line"></span><br><span class="line">Texture使您可以从主线程移除图像解码，文本大小和渲染以及其他昂贵的UI操作到其它线程，以保持主线程可用于响应用户交互。</span><br></pre></td></tr></table></figure><p><strong>更多参考：</strong></p><p><a href="https://www.jianshu.com/p/cd4b445a6a35" target="_blank" rel="noopener">Texture——保持最复杂的用户界面的流畅和响应</a></p><p><a href="http://www.cocoachina.com/ios/20180209/22243.html" target="_blank" rel="noopener">iOS 开发一定要尝试的 Texture(ASDK)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;iOS主要的&lt;strong&gt;绘图系统&lt;/strong&gt;有UIKit、&lt;strong&gt;Core Animat
      
    
    </summary>
    
      <category term="iOS知识小集" scheme="http://buaa0300/nanhuacoder.com/categories/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OSX/iOS 的系统架构</title>
    <link href="http://buaa0300/nanhuacoder.com/2019/03/20/iOS16-system-basic/"/>
    <id>http://buaa0300/nanhuacoder.com/2019/03/20/iOS16-system-basic/</id>
    <published>2019-03-20T04:00:13.000Z</published>
    <updated>2019-03-23T07:36:05.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、系统架构"><a href="#一、系统架构" class="headerlink" title="一、系统架构"></a>一、系统架构</h3><p>苹果官方将整个系统大致划分为下述4个层次</p><h4 id="1、-应用层"><a href="#1、-应用层" class="headerlink" title="1、 应用层"></a>1、 应用层</h4><p>包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringBoard：iOS的桌面</span><br><span class="line">Spotlight：搜索界面</span><br><span class="line">Aqua：Mac OS X的桌面 ？？</span><br></pre></td></tr></table></figure><h4 id="2、应用框架层"><a href="#2、应用框架层" class="headerlink" title="2、应用框架层"></a>2、应用框架层</h4><p>即开发人员接触到的 Cocoa 等框架</p><h4 id="3、核心框架层"><a href="#3、核心框架层" class="headerlink" title="3、核心框架层"></a>3、核心框架层</h4><p>各种核心框架、OpenGL 等内容</p><h4 id="4、Darwin"><a href="#4、Darwin" class="headerlink" title="4、Darwin"></a>4、Darwin</h4><p>操作系统的核心，包括系统内核、驱动、Shell 等内容，源码可以访问<a href="http://opensource.apple.com" target="_blank" rel="noopener">opensource.apple.com</a> </p><p><img src="https://upload-images.jianshu.io/upload_images/201701-8d4708bdfac3da31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p><h3 id="二、Darwin-核心的架构"><a href="#二、Darwin-核心的架构" class="headerlink" title="二、Darwin 核心的架构"></a>二、Darwin 核心的架构</h3><p><img src="https://upload-images.jianshu.io/upload_images/201701-f69c10b12fcdc42f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p><ul><li><p>XNU是Darwin操作系统的一部分，是操作系统的内核，主要有<strong>Mach</strong>、<strong>BSD</strong>、<strong>IOKit**</strong>,** </p></li><li><p>XNU内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如<strong>处理器调度</strong>、<strong>IPC</strong> (进程间通信)等非常少量的基础服务。 </p></li><li><p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能</p></li><li><p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p></li><li><p><strong>Mach</strong> 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。</p></li><li><p>在 Mach 中，所有的东西都是通过自己的对象实现的，<strong>进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</strong></p></li></ul><h3 id="三、Mach-消息"><a href="#三、Mach-消息" class="headerlink" title="三、Mach 消息"></a>三、Mach 消息</h3><h4 id="1、消息的定义"><a href="#1、消息的定义" class="headerlink" title="1、消息的定义"></a>1、消息的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  mach_msg_header_t header;</span><br><span class="line">  mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line">  </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  mach_msg_bits_t msgh_bits;</span><br><span class="line">  mach_msg_size_t msgh_size;</span><br><span class="line">  mach_port_t msgh_remote_port;</span><br><span class="line">  mach_port_t msgh_local_port;</span><br><span class="line">  mach_port_name_t msgh_voucher_port;</span><br><span class="line">  mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure><p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port， 发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">    mach_msg_header_t *msg,</span><br><span class="line">    mach_msg_option_t option,</span><br><span class="line">    mach_msg_size_t send_size,</span><br><span class="line">    mach_msg_size_t rcv_size,</span><br><span class="line">    mach_port_name_t rcv_name,</span><br><span class="line">    mach_msg_timeout_t timeout,</span><br><span class="line">    mach_port_name_t notify);</span><br></pre></td></tr></table></figure><h4 id="2、消息发送和接收"><a href="#2、消息发送和接收" class="headerlink" title="2、消息发送和接收"></a>2、消息发送和接收</h4><p>为了实现消息的<strong>发送</strong>和<strong>接收</strong>，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数<strong>mach_msg_trap</strong>()，trap这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/201701-09914a1f3cdd0484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p><ul><li>RunLoop 的核心就是一个 mach_msg()，RunLoop 调用这个函数去接收消息，<strong>如果没有别人发送 port 消息过来，内核会将线程置于等待状态</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、系统架构&quot;&gt;&lt;a href=&quot;#一、系统架构&quot; class=&quot;headerlink&quot; title=&quot;一、系统架构&quot;&gt;&lt;/a&gt;一、系统架构&lt;/h3&gt;&lt;p&gt;苹果官方将整个系统大致划分为下述4个层次&lt;/p&gt;
&lt;h4 id=&quot;1、-应用层&quot;&gt;&lt;a href=&quot;#1、-
      
    
    </summary>
    
      <category term="iOS知识小集" scheme="http://buaa0300/nanhuacoder.com/categories/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈图片解码</title>
    <link href="http://buaa0300/nanhuacoder.com/2019/03/13/iOS15-pic-decode/"/>
    <id>http://buaa0300/nanhuacoder.com/2019/03/13/iOS15-pic-decode/</id>
    <published>2019-03-13T04:56:46.000Z</published>
    <updated>2019-03-23T07:35:49.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong>KeyPoints</strong></p><ul><li><p>图片如何显示到屏幕上的</p></li><li><p>为什么要图片解码</p></li><li><p>图片解码方案及其对比</p></li></ul><h4 id="一、图像知识"><a href="#一、图像知识" class="headerlink" title="一、图像知识"></a>一、图像知识</h4><h5 id="1、图片"><a href="#1、图片" class="headerlink" title="1、图片"></a>1、图片</h5><ul><li><p>计算机能以<strong>矢量图</strong>(vector)或<strong>位图</strong>(bitmap)格式显示图像，其中<strong>矢量图</strong> 使用线段和曲线描述图像，同时图像还包含了<strong>色彩</strong>和<strong>位置</strong>信息；而<strong>位图</strong> 使用像素点来描述图像，也称为点阵图像，位图图片格式有RGB、CMYK等颜色模式；其中RGB是最常用的颜色模式，它通过红(R)、绿(G)、蓝(B)三个颜色通道的数值表示颜色。手机显示屏使用自带Aphal通道(<strong>RGBA</strong>)的<strong>RGB32</strong>格式。</p></li><li><p>我们平时接触到的JPG或PNG图片格式，他们是<strong>压缩的位图</strong>图形格式，其中 PNG 图片是<strong>无损压缩</strong>，并且支持 alpha 通道，而 JPEG 图片则是<strong>有损压缩</strong>，可以指定 0-100% 的压缩比。JPG或PNG图片显示到屏幕之前，需要将JPG/PNG格式的图片<strong>解码</strong>成<strong>位图图像。</strong></p></li></ul><h5 id="2、16位色、24位色、32位色、真彩色"><a href="#2、16位色、24位色、32位色、真彩色" class="headerlink" title="2、16位色、24位色、32位色、真彩色"></a>2、16位色、24位色、32位色、真彩色</h5><ul><li><p>16位色表示描绘图像时有<strong>2^16种颜色可供选择， 颜色</strong>总数65536。</p></li><li><p>24位色表示描绘图像时有<strong>2^24</strong>种颜色可供选择；颜色总数是16777216。通常也被简称为1600万色或千万色；24位色被称为真彩色，它可以达到人眼分辨的极限</p></li><li><p>32位色在1677万多色基础上，不过它增加了256阶颜色的灰度，为了方便称呼，就规定它为32位色。</p></li><li><p>真彩色指的是图像是一种用三个或更多字节描述像素的计算机图像存储方式，24位色、32位色都是真彩色。</p></li></ul><h5 id="3、动图GIF"><a href="#3、动图GIF" class="headerlink" title="3、动图GIF"></a>3、动图GIF</h5><ul><li><p>GIF格式的图像只有256种颜色用以描绘图片，并且只能通过抖动、差值等方式模拟较多丰富的颜色。</p></li><li><p>GIF的alpha通道只有1bit，一个像素要么完全透明，要么完全不透明，而不像现在PNG的RGBA的8bit alpha通道，alpha值也可以和RGB一样都有255个透明值。</p></li><li><p>所有GIF的图片带上透明度以后，边缘会出现明显的锯齿。如果客户端需要展示带透明度的动图，不考虑GIF。</p></li></ul><h4 id="二、iOS背景知识"><a href="#二、iOS背景知识" class="headerlink" title="二、iOS背景知识"></a>二、iOS背景知识</h4><h5 id="1、图像显示到屏幕"><a href="#1、图像显示到屏幕" class="headerlink" title="1、图像显示到屏幕"></a>1、图像显示到屏幕</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-60465ee3a4d45e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p><p>图像显示到屏幕上，是CPU和GPU协作完成渲染的。具体工作如下:</p><ul><li><p><strong>CPU</strong>: 计算视图frame，图片解码，需要绘制纹理图片通过数据总线交给GPU</p></li><li><p><strong>GPU</strong>: 纹理混合，顶点变换与计算,像素点的填充计算，渲染到帧缓冲区。</p></li><li><p><strong>时钟信号</strong>：垂直同步信号V-Sync / 水平同步信号H-Sync。</p></li><li><p><strong>iOS设备双缓冲机制</strong>：显示系统通常会引入两个帧缓冲区，双缓冲机制</p></li></ul><h5 id="2、图片的显示流程"><a href="#2、图片的显示流程" class="headerlink" title="2、图片的显示流程"></a>2、图片的显示流程</h5><ul><li><p>假设本地从本地加载一张图片，将值赋给UIImageView</p></li><li><p>一次Runloop结束后，CATransaction遍历所有layer的contents(寄宿图)，发现UIImageView layer的contents的变化(CGImage类型)；</p></li><li><p>发现图片不是位图，解码成位图；</p></li><li><p>如果图像数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐；</p></li><li><p>Core Animation提交渲染树CA::render::<strong>commit</strong>，将渲染任务和数据交给Render server线程去处理；</p></li><li><p>Render server调用Open GL、Core Graphics相关程序,最终由GPU完成图像渲染并显示到屏幕。</p></li></ul><p><strong>说明</strong>：图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</p><h5 id="3、为什么要解压图片"><a href="#3、为什么要解压图片" class="headerlink" title="3、为什么要解压图片"></a>3、为什么要解压图片</h5><ul><li><p>JPEG 和 PNG 图片是位图的压缩格式</p></li><li><p>本质上，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点</p></li><li><p>将磁盘中/网络上获取的 图片渲染到屏幕之前，必须<strong>先要得到图片的原始像素数据</strong>，才能执行后续的绘制操作。</p></li></ul><p><strong>参考</strong>：<a href="https://www.jianshu.com/p/4008ec3cacaa" target="_blank" rel="noopener">https://www.jianshu.com/p/4008ec3cacaa</a></p><h4 id="三、Image-I-O-iOS图片解码方案"><a href="#三、Image-I-O-iOS图片解码方案" class="headerlink" title="三、Image I/O: iOS图片解码方案"></a>三、Image I/O: iOS图片解码方案</h4><h5 id="1、Image-I-O是什么"><a href="#1、Image-I-O是什么" class="headerlink" title="1、Image I/O是什么"></a>1、Image I/O是什么</h5><ul><li><p>Image/IO是Apple提供的一套用于<strong>图片编码解码</strong>的系统库，详细参考 <a href="http://link.zhihu.com/?target=https%3A//developer.apple.com/documentation/imageio" target="_blank" rel="noopener">Apple Image/IO</a></p></li><li><p>Image/IO的解码，支持了常见的图像格式，包括PNG（包括APNG）、JPEG、GIF、BMP、TIFF（具体的，可以通过CGImageSourceCopyTypeIdentifiers来打印出来，不同平台不完全一致）。在iOS 11之后另外支持了HEIC（即使用了HEVC编码的HEIF格式）；</p></li><li><p>Image/IO支持的解码和编码格式可通过以下方法查询</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)printImageSupportTypes &#123;</span><br><span class="line">CFArrayRef mySourceTypes = CGImageSourceCopyTypeIdentifiers();</span><br><span class="line">    //支持解码的图片格式</span><br><span class="line">    CFShow(mySourceTypes);</span><br><span class="line">    </span><br><span class="line">    //支持编码的图片格式</span><br><span class="line">    CFArrayRef myDestinationTypes = CGImageDestinationCopyTypeIdentifiers();</span><br><span class="line">    CFShow(myDestinationTypes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、解码流程"><a href="#2、解码流程" class="headerlink" title="2、解码流程"></a>2、解码流程</h5><ul><li><strong>静态图（PNG、JPG）解码流程</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建CGImageSource</span><br><span class="line">读取图像格式元数据（可选）</span><br><span class="line">**解码得到CGImage**</span><br><span class="line">CGImage转成UIImage，资源清理</span><br></pre></td></tr></table></figure><ul><li><strong>动态图(GIF、APNG)解码流程</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态图的步骤1</span><br><span class="line">遍历所有图像帧，重复静态图的步骤2-4</span><br><span class="line">生成动图UIImage</span><br></pre></td></tr></table></figure><h5 id="3、解码关键API"><a href="#3、解码关键API" class="headerlink" title="3、解码关键API"></a>3、解码关键API</h5><ul><li><p><strong>CGImageSourceCreateWithData</strong>：从一个内存中的二进制数据（CGData）中创建ImageSource。ImageSource代表一个待解码数据，还可以通过CGImageSourceCreateWithURL、CGImageSourceCreateWithDataProvider分别从URL、DataProvide中创建ImageSource，DataProvider提供了很多种输入，包括内存，文件，网络，流等。很多CG的接口会用到这个来避免多个额外的接口。</p></li><li><p><strong>CGImageSourceCreateImageAtIndex</strong>: 获取<strong>CGImage</strong>，对于静态图来说，index始终是0。</p></li></ul><h5 id="4、动态图解码Demo"><a href="#4、动态图解码Demo" class="headerlink" title="4、动态图解码Demo"></a>4、动态图解码Demo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CGImageSourceRef source = **CGImageSourceCreateWithData**((__bridge CFDataRef)data, NULL);</span><br><span class="line">if (!source) &#123; // 一般这时候都是输入图像数据的格式不支持</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">NSUInteger frameCount = CGImageSourceGetCount(source); //帧数</span><br><span class="line">NSMutableArray &lt;UIImage *&gt; *images = [NSMutableArray array];</span><br><span class="line">double totalDuration = 0;</span><br><span class="line">for (size_t i = 0; i &lt; frameCount; i++) &#123;</span><br><span class="line">    NSDictionary *frameProperties = (__bridge NSDictionary *) CGImageSourceCopyPropertiesAtIndex(source, i, NULL);</span><br><span class="line">    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary]; // GIF属性字典</span><br><span class="line">    double duration = [gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime] doubleValue]; // GIF原始的帧持续时长，秒数</span><br><span class="line">    CGImagePropertyOrientation exifOrientation = [frameProperties[(__bridge NSString *)kCGImagePropertyOrientation] integerValue]; // 方向</span><br><span class="line">    CGImageRef imageRef = **CGImageSourceCreateImageAtIndex**(source, i, NULL); // CGImage</span><br><span class="line">    UIImageOrientation imageOrientation = [self imageOrientationFromExifOrientation:exifOrientation];</span><br><span class="line">    UIImage *image = [[UIImage imageWithCGImage:imageRef scale:[UIScreen mainScreen].scale orientation:imageOrientation];</span><br><span class="line">    totalDuration += duration;</span><br><span class="line">    [images addObject:image];</span><br><span class="line">&#125;</span><br><span class="line">// 最后生成动图</span><br><span class="line">UIImage *animatedImage = [UIImage animatedImageWithImages:images duration:totalDuration];</span><br></pre></td></tr></table></figure><h5 id="5、说明"><a href="#5、说明" class="headerlink" title="5、说明"></a>5、说明</h5><ul><li><p>Image/IO所有的方法都是线程安全的，而且基本上也都是同步的；</p></li><li><p>通过CGImageSourceCreateImageAtIndex生成的CGImage，其实它的Bitmap还没有立即创建，他只是一个包含了一些<strong>元信息的空壳Image</strong>。这个CGImage，在最终需要获取它的Bitmap Buffer的时候（即，通过相应的API，如CGDataProviderCopyData，CGDataProviderRetainBytePtr），<strong>才会触发最后的Bitmap Buffer的创建和内存分配；</strong></p></li><li><p>图片的解码默认发生在主线程，在图片多或图片过大的情况下，第一次加载会导致滚动帧率下滑，后续帧率会好些，解码完成后的Bitmap Buffer会复用；</p></li><li><p>Image/IO是Appple提供的<strong>图片编码解码库，使用简单，性能也有保证，</strong> 但是对于不支持的格式如webp，编解码是无能为力。</p></li></ul><h3 id="四、子线程解码方案"><a href="#四、子线程解码方案" class="headerlink" title="四、子线程解码方案"></a>四、子线程解码方案</h3><h5 id="1、空间换时间"><a href="#1、空间换时间" class="headerlink" title="1、空间换时间"></a>1、空间换时间</h5><ul><li><p>通过CGContext创建一个位图画布 <strong>CGBitmapContextCreate</strong></p></li><li><p>通过<strong>CGContextDrawImage</strong>绘制位图，CGContextDrawImage在执行过程中会触发Image/IO进行解码并分配Bitmap内存。得到的产物用来真正产出一个CGImage-based的UIImage，交由UIImageView渲染。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        BOOL hasAlpha = NO;</span><br><span class="line">        if (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        // BGRA8888 (premultiplied) or BGRX8888</span><br><span class="line">        // same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        CGContextRef context = **CGBitmapContextCreate**(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">        if (!context) return NULL;</span><br><span class="line">        **CGContextDrawImage**(context, CGRectMake(0, 0, width, height), imageRef); // decode</span><br><span class="line">        CGImageRef newImage = **CGBitmapContextCreateImage**(context);</span><br><span class="line">        CFRelease(context);</span><br><span class="line">        return newImage;</span><br></pre></td></tr></table></figure><h5 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h5><ul><li><p>可以提升图第一次渲染到屏幕上的性能和滚动帧率; </p></li><li><p>因为解码后的位图要保留在内存中，会给内存带来压力，要注意内存的清理;</p></li><li><p>注意控制处理图片解码的子线程数量，子线程过多同样会影响性能。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解码后的图像大小和图片的宽高像素有关，宽高像素越大，位图图像就越大。假设一个3MB的图片，其宽高像素为2048 * 2048 的图片，解码后的位图图像大小是16MB（2048 * 2048 * 4）</span><br></pre></td></tr></table></figure><h5 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h5><ul><li><p>SDWebImage中有两个解码方法decodedImageWithImage 和 decodedAndScaledDownImageWithImage ，分别对应处理普通图，大图（默认位图大小超过60MB），对于大图，建议使用后者。其主要思路是：将大的原图切块，按块缩放成指定大小的图片填充到目标图片中去。</p></li><li><p>Apple大大没有采用此类方案，猜测原因是：因为早期设备内存有限，UIKit整套渲染机制很多地方采用时间换空间的策略。</p></li><li><p>现在，大部分业务使用的是小图，大图的场景少，导致SDWebImage这类子线程解码方案很欢迎，内存开销比较稳定，性能也能提升。</p></li></ul><h4 id="五、后续"><a href="#五、后续" class="headerlink" title="五、后续"></a>五、后续</h4><ul><li><p>子线程解码最终还是利用Image I/O解码，对于Image I/O不支持的图片格式，第三方解码方案？</p></li><li><p>图片编解中遇到的图像方面的知识</p></li><li><p>Core Animation的深入</p></li></ul><p><a href="https://mp.weixin.qq.com/s/HVpX6yie4Cas-d6nkt9k6Q" target="_blank" rel="noopener">探讨iOS 中图片的解压缩到渲染过程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;KeyPoints&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;图片如何显示到屏幕上的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么要图片解码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图片解码方案及其对比&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;一、图像
      
    
    </summary>
    
      <category term="iOS知识小集" scheme="http://buaa0300/nanhuacoder.com/categories/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>推荐迷雾(一):话说ABTest实验</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/11/30/2018-11-30-tl2/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/11/30/2018-11-30-tl2/</id>
    <published>2018-11-30T15:17:13.000Z</published>
    <updated>2019-03-23T04:42:08.037Z</updated>
    
    <content type="html"><![CDATA[<p><em>雄兔脚扑朔，雌兔眼迷离；双兔傍地走，安能辨我是雄雌？</em></p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1、什么是ABTest实验"><a href="#1、什么是ABTest实验" class="headerlink" title="1、什么是ABTest实验"></a>1、什么是ABTest实验</h4><ul><li>今天ABTest已经是一门显学了，主流的产品，无论是算法模型优化，还是UI或体验的调整，上线后都会做ABTest实验，这种线上实验离用户更近，收益大于离线评估方案；</li><li>ABTest实验是为了避免盲目决策带来不确定性和随机性，将各种不同的实验同时放到线上，然后利用数据分析来辅助决策，总之一句话，让数据说话 (data talk)。</li></ul><h4 id="2、ABTest实验的条件"><a href="#2、ABTest实验的条件" class="headerlink" title="2、ABTest实验的条件"></a>2、ABTest实验的条件</h4><ul><li><strong>比较好的两个及以上备选方案</strong>，毕竟 ABTest实验不是银弹，它只是辅助我们做<strong>更好的选择</strong>。</li><li><strong>量化的指标</strong>，比如App中PV、UV、CTR、CVR、CPM等</li><li><strong>用户群体稳定 且 用户量足够</strong></li></ul><h4 id="3、ABTest实验需要注意的问题"><a href="#3、ABTest实验需要注意的问题" class="headerlink" title="3、ABTest实验需要注意的问题"></a>3、ABTest实验需要注意的问题</h4><ul><li><strong>实验流量合理分配</strong>: 保证每组实验流量分配的正交性、均匀性和充足性</li><li><strong>排查实验自身干扰</strong>：实验中可能引入不确定因素，导致结果不可预估</li></ul><p><strong>参考</strong>：<a href="http://uxren.cn/?p=58841" target="_blank" rel="noopener">你的AB测试平台和方案，真的可靠么</a></p><h3 id="二、单层模型和分层模型"><a href="#二、单层模型和分层模型" class="headerlink" title="二、单层模型和分层模型"></a>二、单层模型和分层模型</h3><h4 id="1、单层模型"><a href="#1、单层模型" class="headerlink" title="1、单层模型"></a>1、单层模型</h4><ul><li>不同组实验在同一层拆分流量，不同组的流量是不重叠的</li><li>只能支持少量的实验，不利于迭代</li><li>实验之间不独立，策略之间可能相互影响</li><li>分流方式不灵活</li></ul><h4 id="2、分层模型"><a href="#2、分层模型" class="headerlink" title="2、分层模型"></a>2、分层模型</h4><ul><li>主流的流量分配方案，来自2010年谷歌公布的的《Overlapping Experiment Infrastructure More, Better, Faster Experimentation》论文；</li><li>谷歌提出将实验空间横向、纵向划分，纵向流量可以独占实验区域，可以独享实验流量，不被其他实验影响；横向分若干层，每一个可以做同一组的实验，每个独立实验为一层，层与层之间流量是正交的，一份流量穿越每层实验时，都会再次随机打散，且随机效果离散。</li></ul><p><strong>参考</strong>：<a href="http://www.woshipm.com/pd/1080730.html" target="_blank" rel="noopener">一文搞懂AB Testing的分层分流</a></p><h3 id="三、分层模型方案"><a href="#三、分层模型方案" class="headerlink" title="三、分层模型方案"></a>三、分层模型方案</h3><h4 id="1、技术关键点"><a href="#1、技术关键点" class="headerlink" title="1、技术关键点"></a>1、技术关键点</h4><ul><li><p>分流函数（流量如何在每层被打散）如何设计，如果保证每层流量分配的均匀性和正交性</p></li><li><p>如何处理实验样本的过滤(如 只选取某个地区的用户、只选取新用户)</p></li><li><p>分配多大的流量可以使实验置信</p></li></ul><h4 id="2、设计"><a href="#2、设计" class="headerlink" title="2、设计"></a>2、设计</h4><ul><li>域（domain）：划分的一部分流量</li><li>层（layer）：系统参数的一个子集</li><li>实验（exp）：在一个域上，对一个或者多个参数修改，改变请求路径的过程</li></ul><ul><li>相关联的策略参数位于同一实验层；</li><li>相互独立的策略参数分属于不同的实验层；</li><li>一个实验参数只能在一个实验层中出现；</li><li><p>不同实验层间进行独立的流量划分和独立的实验，互不影响。</p></li><li><p>每一实验层享有 100% 流量，可以避免流量切分过细，保证实验间的可对比性、客观性；</p></li><li>不同实验层之间流量正交，可以避免不同试验间的流量依赖和流量不均匀情况的出现。为了更好地评估实验的效果，每一实验层还引入了基准实验。该基准实验会采用该实验层的默认策略取值，流量配比会设定在一个合适的水平。</li></ul><h3 id="四、业内ABTest实验平台"><a href="#四、业内ABTest实验平台" class="headerlink" title="四、业内ABTest实验平台"></a>四、业内ABTest实验平台</h3><p>基于Google的分层模型，美团和微博的ABTest平台实现</p><h4 id="1、美团点评-的-Gemini"><a href="#1、美团点评-的-Gemini" class="headerlink" title="1、美团点评 的 Gemini"></a>1、美团点评 的 Gemini</h4><p><a href="https://www.csdn.net/article/2015-03-24/2824303" target="_blank" rel="noopener">https://www.csdn.net/article/2015-03-24/2824303</a></p><h4 id="2、微博的-Faraday"><a href="#2、微博的-Faraday" class="headerlink" title="2、微博的 Faraday"></a>2、微博的 Faraday</h4><p>微博广告法拉第（Faraday）全流量分层实验平台。该实验平台支持大规模广告策略并发实验，提供了多种流量均匀分流模式，全面的广告指标跟踪评估，实验效果实时反馈等。</p><p><a href="http://www.yunweipai.com/archives/19535.html" target="_blank" rel="noopener">http://www.yunweipai.com/archives/19535.html</a></p><ul><li><a href="https://zhuanlan.zhihu.com/p/25685006" target="_blank" rel="noopener">携程机票的ABTest实践</a></li><li><a href="https://yq.aliyun.com/articles/5837" target="_blank" rel="noopener">10分钟搞懂分层实验原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;雄兔脚扑朔，雌兔眼迷离；双兔傍地走，安能辨我是雄雌？&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h3&gt;&lt;h4 id=&quot;1、什么是ABTest实验&quot;
      
    
    </summary>
    
      <category term="推荐" scheme="http://buaa0300/nanhuacoder.com/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐迷雾(一):再见推荐系统</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/11/21/2018-11-21-tj1/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/11/21/2018-11-21-tj1/</id>
    <published>2018-11-21T14:55:30.000Z</published>
    <updated>2019-03-23T04:42:02.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><em>花非花，雾非雾。夜半来，天明去。来如春梦不多时，去似朝云无觅处。</em></p><p>​    用白居易的诗作为《推荐迷雾》系列的开始，本人非推荐算法工程师，但是工作中也和算法打过些交道，也曾于13年粗读过项亮博士的《推荐系统实战》，这本12年出版的“旧”书如今再读起来，更多一番体会；虽然近些年，机器学习尤其是深度学习给传统推荐学习带来新的变化，但是这些新兴的推荐技术依旧有传统的推荐算法模型的影子。</p><p><img src="/nanhuacoder.com/2018/11/21/2018-11-21-tj1/jianghu.jpeg" alt="江湖"></p><h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><ul><li>推荐产生的背景：信息过载，用户需求不确定</li><li>推荐三步骤：召回，预估和排序</li></ul><h3 id="二、推荐系统的评估指标和方法"><a href="#二、推荐系统的评估指标和方法" class="headerlink" title="二、推荐系统的评估指标和方法"></a>二、推荐系统的评估指标和方法</h3><h4 id="1、评估指标"><a href="#1、评估指标" class="headerlink" title="1、评估指标"></a>1、评估指标</h4><h5 id="1-1、评分预测的评估"><a href="#1-1、评分预测的评估" class="headerlink" title="1-1、评分预测的评估"></a>1-1、评分预测的评估</h5><ul><li><p>RMSE (均方根误差，加大预测不准物品评分的惩罚)</p></li><li><p>MAE（平均绝对误差）</p></li></ul><h5 id="1-2、TopN推荐的评估"><a href="#1-2、TopN推荐的评估" class="headerlink" title="1-2、TopN推荐的评估"></a>1-2、TopN推荐的评估</h5><ul><li>在这里用到了<strong>准确率</strong>、<strong>召回率</strong>和<strong>F-1 Score</strong>三个度量值</li><li><strong>召回率</strong>（Recall）：用户消费的内容，是由推荐提供的占比</li><li><strong>准确率</strong>（Precision）：推荐的内容中，用户消费的占比</li><li><strong>F-1 Score</strong> </li></ul><p>$$<br>F_1 Score = \frac{2 x recall * precision}{recall + precision}<br>$$</p><p><strong>召回率</strong>表示在原始样本的正样本中，最后被正确预测为正样本的概率；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算召回率和准确率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrecisionRecall</span><span class="params">(test,N)</span>:</span></span><br><span class="line">hit = <span class="number">0</span></span><br><span class="line">n_recall = <span class="number">0</span></span><br><span class="line">n_precision = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> user,item <span class="keyword">in</span> test.items():</span><br><span class="line">rank = Recommend(user,N)</span><br><span class="line">hit += len(rank &amp; items)</span><br><span class="line">n_recall += len(items)</span><br><span class="line">n_precision += N</span><br><span class="line"><span class="keyword">return</span> [hit/(<span class="number">1.0</span> * n_recall),hit/(<span class="number">1.0</span>*n_precision)]</span><br></pre></td></tr></table></figure><ul><li>为了全面评估TopN推荐的准确率和召回率，一般选取不同推荐列表长度N，计算一组准确率/召回率，然后画出准确率/召回率曲线。</li><li>在工程实践中，TopN推荐更合适，因为对于推荐的内容来说，预测用户会不会看，比预测用户看了内容后给多少分更重要。</li></ul><h5 id="1-3、覆盖率"><a href="#1-3、覆盖率" class="headerlink" title="1-3、覆盖率"></a>1-3、覆盖率</h5><p>推荐系统对物品长尾的发掘能力，简单的定义是推荐物品占总物品集合的比例。当然还有更好的指标来定义覆盖率。</p><ul><li>信息熵：</li><li>基尼系数：</li></ul><h5 id="1-3、其他指标"><a href="#1-3、其他指标" class="headerlink" title="1-3、其他指标"></a>1-3、其他指标</h5><ul><li>多样性、新颖性、惊喜度、信任度、实时性、健壮性，商业目标等等，具体参考《推荐系统实战》中的内容</li></ul><h4 id="2、评估方法"><a href="#2、评估方法" class="headerlink" title="2、评估方法"></a>2、评估方法</h4><ul><li><p>离线评估：速度快，不需要用户参与；在用户的历史数据上做评估，和线上真实效果有偏差；只能评估少数指标。</p></li><li><p>用户调查：主要的形式是问卷调查，成本高</p></li><li><p>在线实验：目前最普遍的做法是ABtest，目前主采用多层重叠实验设计，这些在后面的文章重点介绍</p></li></ul><h3 id="三、推荐系统架构"><a href="#三、推荐系统架构" class="headerlink" title="三、推荐系统架构"></a>三、推荐系统架构</h3><ul><li>推荐系统是产品的核心，而推荐算法仅仅是推荐系统中的一部分；以NetFlix的推荐系统架构为例，介绍经典的推荐系统架构。</li><li>在NetFlix推荐系统架构中，分为三层：Offline层（离线层）、Nearline层（近线层）和  Online层（在线层）</li></ul><h4 id="1、Offline层（离线层）"><a href="#1、Offline层（离线层）" class="headerlink" title="1、Offline层（离线层）"></a>1、Offline层（离线层）</h4><ul><li>这一层批量、周期性地<strong>抽取数据</strong>，<strong>训练模型</strong>；训练得到的模型可以用于为用户计算推荐结果。协同过滤、矩阵分解一般在这层做，Hadoop、Spark分布式计算也在这一层。</li><li>Offline阶段的推荐结果或模型在Nearline层被更新，产生最终的推荐结果，呈现给用户。</li></ul><h4 id="2、Nearline层（近线层）"><a href="#2、Nearline层（近线层）" class="headerlink" title="2、Nearline层（近线层）"></a>2、Nearline层（近线层）</h4><ul><li>Nearline要处理处理实时数据流(流计算），执行计算任务：从事件队列中获取最新的一个或少许几个用户反馈行为，将这些用户已经反馈过的物品从离线推荐结果中剔除，然后用这几个反馈行为作为样本，以小批量梯度下降的优化方法去更新融合模型的参数。</li></ul><h4 id="3、Online层（在线层）"><a href="#3、Online层（在线层）" class="headerlink" title="3、Online层（在线层）"></a>3、Online层（在线层）</h4><ul><li>用户使用App/浏览Web，消费展示内容，产生行为事件数据，如页面曝光，按钮点击等，实时被收集走，一边进入分布式文件系统中做存储，给Offline使用，一边流向Nearline的<strong>消息队列</strong>，供Nearline的<strong>流计算</strong>使用。</li><li>用户发出请求，等待推荐结果；Online层必须实施响应用户请求，要快，要有兜底，Online层处理的一般是已经预处理后的推荐结果。</li></ul><h3 id="四、推荐系统中的冷启动和EE问题"><a href="#四、推荐系统中的冷启动和EE问题" class="headerlink" title="四、推荐系统中的冷启动和EE问题"></a>四、推荐系统中的冷启动和EE问题</h3><ul><li>在推荐系统中有两个经典问题：<strong>冷启动</strong>和<strong>EE</strong>(探索和利用问题)。</li><li>Bandit算法提供了一种有效的解决办法；其中<strong>冷启动</strong>的本质是：推荐系统没有历史数据，无法预测用户偏好；可分为用户冷启动，物品冷启动和系统冷启动。<strong>EE问题</strong>是指，是选择现在不确定的一些方案，但未来可能会有高收益的方案；还是选择现在可能最佳的方案；本质是一个选择的问题。</li><li>Bandit 算法来源于历史悠久的赌博学，它要解决这样的问题：一个赌徒去摇老虎机，赌场中有的老虎机一模一样，但是每个老虎机吐钱的概率不一样，他不知道每个老虎机吐钱的概率分布是什么，那么每次该选择哪个老虎机可以做到最大化收益呢？这就是<strong>多臂赌博机问题</strong>（Multi-armed bandit problem, K-armed bandit problem, MAB）</li></ul><p><img src="/nanhuacoder.com/2018/11/21/2018-11-21-tj1/mab.png" alt="MAB问题"></p><ul><li><p>假设我们已经经过一些试验，得到了当前每个老虎机的吐钱的概率，如果想要获得最大的收益，我们会一直摇哪个吐钱概率最高的老虎机，这就是Exploitation。但是，当前获得的信息并不是老虎机吐钱的真实概率，可能还有更好的老虎机吐钱概率更高，因此还需要进一步探索，这就是Exploration问题。</p></li><li><p>Bandit解决MAB或者EE问题的策略是：有策略地走一步看一步，这些策略就是Bandit算法，经典的Bandit算法分别是：<strong>朴素Bandit、汤普森采样、UCB和Epsilon贪婪算法</strong>。</p></li></ul><h4 id="1、朴素Bandit"><a href="#1、朴素Bandit" class="headerlink" title="1、朴素Bandit"></a>1、朴素Bandit</h4><p><strong>原理</strong>：先随机试若干次，计算每个臂的平均收益，一直选均值最大那个臂。</p><h4 id="2、汤普森采样-Thompson-sampling-算法"><a href="#2、汤普森采样-Thompson-sampling-算法" class="headerlink" title="2、汤普森采样(Thompson sampling)算法"></a>2、汤普森采样(Thompson sampling)算法</h4><p><strong>原理</strong>：</p><ul><li>每个臂维护一个beta(a，b)分布，每次用现有的beta分布产生一个随机数，输出随机数最大的臂（较快，随机性高）</li></ul><p><strong>beta(a，b)分布特点</strong>：</p><ul><li>a+b值越大，分布曲线就越窄，分布就越集中；</li><li>a/(a+b)值越大，分布中心越靠近1，反之越靠近0；</li></ul><p><strong>采样过程</strong>：</p><ul><li><p>假设a是用户的点击次数，b是没有得到用户的点击次数</p></li><li><p>每次取出所有候选的参数a和b，用贝塔分布产生一个随机数</p></li><li><p>随机数排序，输出最大值对应的候选</p></li><li><p>如果用户点击，对应的候选a加1，反之b加1</p></li></ul><p><strong>分析</strong>：</p><ul><li>如果一个候选被选中的次数很多（a+b很大），分布变窄，对应的分布产生的随机数基本在中心位置，接近平均收益。</li><li>如果a+b很大，a/(a+b)也很大，那么分布产生的随机数越接近1，平均收益很好，进入利用阶段；</li><li>如果a+b很小，说明候选的好坏不能确定，分布很宽，可能得到一个较大的随机数，排序时候可能被优先输出，起到了探索的目的。</li></ul><h4 id="3、UCB算法"><a href="#3、UCB算法" class="headerlink" title="3、UCB算法"></a>3、UCB算法</h4><p><strong>原理</strong>：</p><ul><li>以每个候选的平均收益作为基准线进行选择</li><li>对于每次被选择不足的给与照顾</li><li>选择倾向于那些确定收益较好的候选</li></ul><p><strong>简言之</strong>，均值越大，标准差越小，被选中的概率会越来越大 (相对慢一点，确定性高)</p><h4 id="4、Epsilon贪婪-Epsilon-Greedy-算法"><a href="#4、Epsilon贪婪-Epsilon-Greedy-算法" class="headerlink" title="4、Epsilon贪婪(Epsilon-Greedy)算法"></a>4、Epsilon贪婪(Epsilon-Greedy)算法</h4><p><strong>原理：</strong></p><ul><li>先选一个(0,1)之间较小的值，作为Epsilon，然后每次以1-epsilon的概率选取当前收益最大的臂，以epsilon的随机概率选取一个臂。（后期不需要较大探索，epsilon需要衰减）</li><li>Epsilon可以控制探索和利用的程度，Epsilon越接近0，在探索上就越保守；Epsilon越接近1，在探索上就越激进。</li></ul><p><img src="/nanhuacoder.com/2018/11/21/2018-11-21-tj1/bandit-performance.png" alt="Bandit算法算法模拟试验效果"></p><p><strong>总结</strong>：UCB算法和汤普森采样算法效果更好些。</p><h3 id="五、Bandit算法的工程实现"><a href="#五、Bandit算法的工程实现" class="headerlink" title="五、Bandit算法的工程实现"></a>五、Bandit算法的工程实现</h3><p>​    上面介绍的<strong>朴素Bandit、汤普森采样、UCB和Epsilon贪婪算法</strong>都是经典的Bandit算法，在工程中很少使用；实际中，我们采用的是上下文Bandit算法，比较常见的是LinUCB算法和COFIBA算法</p><h4 id="1、LinUCB"><a href="#1、LinUCB" class="headerlink" title="1、LinUCB"></a>1、LinUCB</h4><p><strong>概述</strong>：</p><ul><li><p>传统的 Bandit 算法并没有考虑臂的特征信息，也就是说并没有考虑上下文信息，而yahoo在2010年提出的，一种结合上下文的 Bandit算法——LinUCB (linear UCB)算法。</p></li><li><p>LinUCB 算法可以将当前用户的特征、物品特征构成所有的相关特征，然后根据每个臂维护的特征系数,计算出预估收益。由于加入了特征，所以收敛速度比 UCB 更快。</p></li><li>LinUCB的不足：同时处理的候选臂数量不能太多，不超过几百个最佳。因为每一次要计算每一个候选臂的期望收益和置信区间，一旦候选太多，计算代价将不可接受。其实这也是所有的 Bandit 算法的缺点。</li></ul><p><strong>原理：</strong></p><ul><li><p>LinUCB 假设一个物品推送给用户之后，获得的收益与相关特征呈<strong>线性关系</strong>，这里的相关特征就是指上下文信息。LinUCB 有两个版本：<strong>Disjoint</strong> 和 <strong>Hybrid</strong>，Disjoint 表示不同臂之间的不相关，也就是说参数不共享，Hybrid 表示臂之间共享一些参数。</p></li><li><p>Disjoint 模型：假设每个臂包含一个物品，我们在每一次选择时，用户与物品的的特征构成了上下文信息，表示为 x，维度为 d，每个臂维护了一个 d 维的表示特征系数的向量 θ，使用 c 表示本次选择的收益，如果用户点击了就为 1，否则为 0。我们假定：</p></li></ul><p>  根据p’ + ∆来选择合适的臂。p’的计算基于有监督的学习方法。我们为每个老虎机维护一个特征向量D，同时上下文特征我们写作θ，然后通过收集的反馈进行有监督学习：</p><ul><li><p>加入特征信息，用User和Item的特征预估回报及其置信区间，选择置信区间上界最大的Item推荐，观察回报后更新线性关系的参数，以此达到试验学习的目的。</p></li><li><p>岭回归的求解，岭回归适合样本数少于特征的数据集。</p></li><li><p>参考：<a href="http://www.naodongopen.com/908.html" target="_blank" rel="noopener">结合上下文信息的Bandit算法—LinUCB算法</a></p></li></ul><h4 id="2、COFIBA"><a href="#2、COFIBA" class="headerlink" title="2、COFIBA"></a>2、COFIBA</h4><ul><li>2016年提出，COFIBA算法的不同有两个：<ol><li>基于用户聚类挑选最佳的Item（相似用户集体决策的Bandit）。</li><li>基于用户的反馈情况调整User和Item的聚类（协同过滤部分）。</li></ol></li><li>在时刻t，用户来访问推荐系统，推荐系统需要从已有的候选池子中挑一个最佳的物品推荐给他，然后观察他的反馈，用观察到的反馈来更新挑选策略。 这里的每个物品都有一个特征向量，所以这里的Bandit算法是context相关的。 这里依然是用岭回归去拟合用户的权重向量，用于预测用户对每个物品的可能反馈（payoff），这一点和linUCB算法是一样的</li></ul><ul><li><p>bandit结合协同过滤。</p><p><a href="https://blog.csdn.net/heyc861221/article/details/80129310" target="_blank" rel="noopener">https://blog.csdn.net/heyc861221/article/details/80129310</a></p></li></ul><h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><ul><li>Exploit-Explore这一对矛盾一直客观存在，Bandit算法是公认的一种比较好的解决EE问题的方案。但解决Explore，势必就是要冒险，势必要走向未知，而这显然就是会伤害用户体验的：明知道用户肯定喜欢A，你还偏偏以某个小概率给推荐非A。</li><li>实际上，很少有公司会采用这些理性的办法做Explore，反而更愿意用一些盲目主观的方式。究其原因，可能是因为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、互联网产品生命周期短，而Explore又是为了提升长期利益的，所以没有动力做；</span><br><span class="line">2、用户使用互联网产品时间越来越碎片化，Explore的时间长，难以体现出Explore 的价值；</span><br><span class="line">3、同质化互联网产品多，用户选择多，稍有不慎，用户用脚投票，分分钟弃你于不顾；</span><br><span class="line">4、已经成规模的平台，红利杠杠的，其实是没有动力做Explore的。</span><br></pre></td></tr></table></figure><ul><li>所以做Explore要精心设计，必须保证质量。</li></ul><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li><p>bandit添加对应的源码实现</p></li><li><p>ABTest的分层实验设计</p></li><li>召回中的协同过滤和隐语义模型, 矩阵分解</li><li>CTR预估的进化，特征工程 + LR -&gt; GBDT + LR -&gt; FM -&gt;FFM -&gt; DeepFM/Wide&amp;Deep/…</li><li>排序怎么做</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;p&gt;&lt;em&gt;花非花，雾非雾。夜半来，天明去。来如春梦不多时，去似朝云无觅处。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;​    用白居易的诗作为《推荐迷雾》系列
      
    
    </summary>
    
      <category term="推荐" scheme="http://buaa0300/nanhuacoder.com/categories/%E6%8E%A8%E8%8D%90/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习中的树模型</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/11/20/2018-11-20-dtree/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/11/20/2018-11-20-dtree/</id>
    <published>2018-11-20T15:33:16.000Z</published>
    <updated>2019-03-23T04:41:49.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><ul><li>在数据结构中，有树这种结构；在机器学习中，有决策树；咋一看，感觉是一回事，其实不然；</li><li><p>数据结构的树关注的事查找，插入，删除的效率，二叉树，平衡二叉树都是为了解决这些效率而产生的；</p></li><li><p>机器学习中的决策树关注的是，如何找到最佳分解节点，<strong>ID3算法</strong>(按最大信息增益划分)，<strong>C4.5</strong>（按信息增益比划分），<strong>CART算法</strong>（按最小基尼指数划分）都是为了达到最佳分裂的效果。</p></li><li>最大信息增益会倾向于<strong>可取值较多</strong>的特征，最大信息增益比会倾向于<strong>可取值较少的特征</strong>。</li></ul><h4 id="2、决策树和集成学习"><a href="#2、决策树和集成学习" class="headerlink" title="2、决策树和集成学习"></a>2、决策树和集成学习</h4><ul><li>决策树模型很简单，简单到即使你不懂机器学习，也能很快了解他，可能有人会说，这么简单的模型有什么用。哈哈，数学的伟大，在于复杂的问题简单化，深度学习的强大在于利用将简单的神经网络不断加深；决策树虽然简单，但是很多个决策树在一起，就足够让很多浅层机器学习算法忘而却步。</li><li><p>这个将许多决策树整合一起的方式就是集成学习，在集成学习中，决策树是个体学习器，当然个体学习器可以是别的弱学习器。</p></li><li><p>而根据个体学习器生成方式的不同，目前集成学习方法大致可分为两大类，即个体学习器间存在<strong>强依赖关系</strong>、必须串行生成的序列化方法，以及个体学习器间<strong>不存在强依赖关系</strong>、可同时生成的并行化方法；前者的代表是<strong>Boosting </strong> 和 <strong>梯度提升树</strong>(GBDT)，后者的代表是和<strong>Bagging</strong>和 <strong>随机森林</strong>（Random Forest）</p></li></ul><h3 id="二、决策树"><a href="#二、决策树" class="headerlink" title="二、决策树"></a>二、决策树</h3><h4 id="1、决策树中需关注问题"><a href="#1、决策树中需关注问题" class="headerlink" title="1、决策树中需关注问题"></a>1、决策树中需关注问题</h4><ul><li><p>一棵树是如何构建的？建树过程中，树分裂节点时，如何选出最优的属性作为分裂节点。</p></li><li><p>如何用树的减枝来避免过拟合问题。</p></li><li><p>对于含有空值的数据，如何构建树。</p></li><li><p>构建树可能存在的问题，过拟合问题，如何解决</p></li></ul><h4 id="2、如何构建一棵树"><a href="#2、如何构建一棵树" class="headerlink" title="2、如何构建一棵树"></a>2、如何构建一棵树</h4><p>简言之：<strong>选择最优划分属性作为分裂结点，使得分支结点中所包含的样本尽可能属于同一类</strong>。树的生成算法有三种：ID3、C4.5和CART.</p><h5 id="1、ID3"><a href="#1、ID3" class="headerlink" title="1、ID3"></a>1、ID3</h5><p>选择<strong>最大信息增益(Information Gain)</strong>规则去寻找最优分裂节点</p><h5 id="1-1、基础概念"><a href="#1-1、基础概念" class="headerlink" title="1-1、基础概念"></a>1-1、基础概念</h5><ul><li><p>信息熵(Information entropy)：表示随机变量不确定性的度量；<strong>熵越大，随机变量的不确定性就越大</strong>；(我们希望分类后的结果熵越小越好)。</p></li><li><p>信息增益(Information gain)：表示因特征X的信息而使得类Y信息不确定性减少的程度。(当然是越大越好）；<br>$$<br>g(D,A) = H(D) - H(D|A)<br>$$</p></li></ul><p>在划分过程中，找到信息增益最大的特征将样本根据此特征划分不同的结点中，新的结点中继续划分。</p><h5 id="1-2、不足"><a href="#1-2、不足" class="headerlink" title="1-2、不足"></a>1-2、不足</h5><ul><li>信息增益反应的是：给点条件后，不确定性减少的程度，<strong>特征取值越多，意味着确定性越高，也就是条件熵越小，信息增益越大。</strong>这就造成信息增益对<strong>可取值较多</strong>的属性有所偏好。</li><li>ID3只能处理离散型变量，只能处理分类任务</li><li>对样本特征缺失值比较敏感</li></ul><h5 id="2、C4-5"><a href="#2、C4-5" class="headerlink" title="2、C4.5"></a>2、C4.5</h5><p>选择<strong>最大信息增益比(Information Gain Ratio)</strong>规则去寻找最优分裂节点</p><h5 id="2-1、基础概念"><a href="#2-1、基础概念" class="headerlink" title="2-1、基础概念"></a>2-1、基础概念</h5><ul><li><strong>信息增益比(Information Gain Ratio)</strong>: 特征A对训练数据集D的信息增益比为其 信息增益与训练数据集D关于特征A的值的熵之比。<br>$$<br>g_R(D,A) =\frac{g(D,A)}{H_A(D)}<br>$$</li></ul><p>在划分过程中，找到信息增益比最大的特征将样本根据此特征划分不同的结点中，新的结点中继续划分。</p><h5 id="2-2、不足"><a href="#2-2、不足" class="headerlink" title="2-2、不足"></a>2-2、不足</h5><ul><li>C4.5 对ID3做了优化，使用信息增益比在一定程度上对取值较多的特征进行了惩罚，避免ID3出现的过拟合特性，提升了决策树的泛化能力。</li><li>C4.5 能处理连续型变量和离散型变量，但是只能处理分类任务。</li></ul><h5 id="3、CART"><a href="#3、CART" class="headerlink" title="3、CART"></a>3、CART</h5><p>选择<strong>最小基尼指数(Gini index)</strong>规则去寻找最优分裂节点</p><h5 id="3-1、基础概念"><a href="#3-1、基础概念" class="headerlink" title="3-1、基础概念"></a>3-1、基础概念</h5><ul><li>基尼指数：表示数据的纯度<br>$$<br>Cini(D) = 1 - \sum_{k=1}^n(\frac{|C_k|}{|D|})^2<br>$$</li></ul><p>利用基尼指数最小选择最优分裂点，采用二元切割法</p><h5 id="3-2、特点"><a href="#3-2、特点" class="headerlink" title="3-2、特点"></a>3-2、特点</h5><ul><li>不仅能处理分类任务，还能处理回归任务</li><li>不仅能处理离散型变量，还能处理连续型变量</li><li>能够处理样本特征数据缺失的情况</li></ul><h4 id="3、树的剪枝"><a href="#3、树的剪枝" class="headerlink" title="3、树的剪枝"></a>3、树的剪枝</h4><h5 id="3-1、预剪枝"><a href="#3-1、预剪枝" class="headerlink" title="3-1、预剪枝"></a>3-1、预剪枝</h5><p>阈值、</p><h5 id="3-2、后剪枝"><a href="#3-2、后剪枝" class="headerlink" title="3-2、后剪枝"></a>3-2、后剪枝</h5><h3 id="三、梯度提升树-和-随机森林"><a href="#三、梯度提升树-和-随机森林" class="headerlink" title="三、梯度提升树 和 随机森林"></a>三、梯度提升树 和 随机森林</h3><ul><li><p>梯度提升树，GBDT，特征组合的一把好手</p></li><li><p>随机森林 RF</p></li><li><p>基于决策树实现的GBDT、RF（随机森林）、Xgboost 和 lightGBM都在数据竞赛和工程中都大展身手。</p></li><li><p><a href="https://github.com/e-snail/understanding_machine_learning/tree/master/3_decision_tree" target="_blank" rel="noopener">https://github.com/e-snail/understanding_machine_learning/tree/master/3_decision_tree</a></p></li><li><p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/tree.html" target="_blank" rel="noopener">决策树API</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、开篇&quot;&gt;&lt;a href=&quot;#一、开篇&quot; class=&quot;headerlink&quot; title=&quot;一、开篇&quot;&gt;&lt;/a&gt;一、开篇&lt;/h3&gt;&lt;h4 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="机器学习" scheme="http://buaa0300/nanhuacoder.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习杂谈</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/11/17/2018-11-17-ml/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/11/17/2018-11-17-ml/</id>
    <published>2018-11-17T14:20:28.000Z</published>
    <updated>2019-03-23T05:05:44.909Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高能预警</strong>：本人非算法开发，以下是我的一些浅见。</p><h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><p>自有机器学习以来，算法模型中就有了区分；分为监督学习，无监督学习，半监督学习和强化学习等。</p><h4 id="1、监督学习"><a href="#1、监督学习" class="headerlink" title="1、监督学习"></a>1、监督学习</h4><ul><li><p>机器学习中<strong>大部分任务</strong>都是监督学习任务；在监督学习中，分类和回归是其两大主题。分类中名声最大的是：<strong>逻辑回归</strong>(Logistic regression)、<strong>朴素贝叶斯</strong>(Naive Bayes) 和 <strong>支持向量机</strong>(Support Vector Machine，SVM) 。</p></li><li><p>在工业界曾经有<strong>一招LR打天下</strong>的”传说”，这里的LR就是逻辑回归；早些年做CTR预估时候，<strong>人工特征海洋 + LR</strong>用得非常多，很多算法工程师大部分时间埋头搞特征工程；</p></li><li><strong>朴素贝叶斯</strong>(Naive Bayes)是个开挂的存在，它将<strong>贝叶斯原理</strong>应用到机器学习中，而后机器学习中贝叶斯学派声明鹊起，与旧贵族统计学派在机器学习中鼎足而立；它强假设输入的数据的特征都是独立的，在文本分类中表现出很好的效果，可谓是入门nlp都必须了解的算法之一了。</li><li><strong>支持向量机</strong>(Support Vector Machine，SVM) 当之无愧是监督学习中的无冕之王，自上世纪90年代诞生之后，在机器学习界掀起“腥风血雨”，它利用核技巧，在属于两个不同类别的两组数据之间找到良好的分类边界，将线性不可分问题转为高纬空间的线性可分问题，借此达到了分类的目的。因为SVM的存在，将<strong>多层神经网络</strong>的研究打进冷宫；多层神经网络是深度学习的前身。直到2012年，因为深度学习在ImageSet竞赛中的完胜，神经网络的研究才再次复苏，直至形成今天的野火燎原之势。</li><li>监督学习中另一个主题是回归，最基础的的当然是<strong>线性回归</strong>(Linear regression)，模型虽然简单，但是预测个房价，股票价格这种高大上的事情也还是有着不错的表现。</li><li>非监督学习比较尴尬，在工业界，更多起到打辅助的左右；有聚类，降维和关联规则三大主题，聚类中用的较多反而是简单的K-means，PCA和SVD用来做数据降维，关联规则那块好像在推荐系统用的稍微多些。</li></ul><h4 id="2、决策树和集成学习"><a href="#2、决策树和集成学习" class="headerlink" title="2、决策树和集成学习"></a>2、决策树和集成学习</h4><ul><li>决策树是监督学习中比较特殊的模型，说他特殊，是因为它不像LR、SVM和NB直接上手，大家喜欢使用将决策树作为集成学习的基础学习器，比较著名的是<strong>随机森林</strong>(Random Forest)、<strong>梯度提升树</strong>(GBDT)，决策树的实现经历了ID3, C4.5，CART三个阶段，在随机森林、梯度提升树里面用的是CART这个分类回归树。从CART的名字也看出来，不仅仅可以做回归，也能做分类。粗暴理解就是，分类时候好多CART投票分类结果，回归时候，取CART预测值得平均数。</li><li>GBDT有个超级经典的实现，XgBoost。在Kaggle比赛中，XgBoost近乎霸主级别的存在；江湖有传言，图片图像等机器学习问题用Keras（深度学习库），浅层机器学习用XgBoost。</li></ul><h4 id="3、神经网络和深度学习的渊源"><a href="#3、神经网络和深度学习的渊源" class="headerlink" title="3、神经网络和深度学习的渊源"></a>3、神经网络和深度学习的渊源</h4><ul><li>我认为，没有神经网络，就没有深度学习；虽然业界有说法，不用神经网络就也能实现深度学习；但是神经网络真的真的很厉害，虽然很长一段时间不被看好，因为两层的神经网络连个异或都处理不了，的确有理由被看不上；但是随着反向传播算法发现，神经网络层数不断加深，在工业界发挥牛逼闪闪的光芒。</li><li>你可能想不到，权重，阈值，激活函数这些简简单单的东西，怎么能解决计算机视觉、语音识别这种非常难的问题，这些问题连当年风光无限的SVM都败下阵来。</li></ul><h4 id="4、特征工程"><a href="#4、特征工程" class="headerlink" title="4、特征工程"></a>4、特征工程</h4><ul><li><p>有句老话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。在传统机器学习领域，做好特征工程很重要；工业界有句老话，70%多的时间在做特征工程；</p></li><li><p>比较尴尬的是，市面上多是讲解机器学习算法模型的书，讲解算法和模型的奥妙是他们的主题，提供的试验数据也都是已经处理好的，并不需要特征工程处理，但是实际工程中不是这样。特征工程的处理依赖领域知识和经验依旧是主流，但是业界很多项目处于安全、隐私等考虑，不会透露底层的特征工程的处理。</p></li></ul><h4 id="5、特征工程-amp-深度学习"><a href="#5、特征工程-amp-深度学习" class="headerlink" title="5、特征工程 &amp; 深度学习"></a>5、特征工程 &amp; 深度学习</h4><ul><li>深度学习有自动获取特征的能力，可以对输入的低阶特征进行组合、变换，得到高阶特征，但是这个能力只是对于某些领域(如图像、语音)有比较好的效果。</li><li>在其他领域，如自然语言处理中，输入的字或词都是离散、稀疏的值，不像图片一样是连续、稠密的。输入原始数据进行组合、变换得到的高阶特征并不是那么有效。而且有的语义并不来自数据，而来自人们的先验知识，所以利用先验知识构造的特征是很有帮助的。</li><li>总的来说，在深度学习中，特征工程仍然适用；神经网络能对特征自动进行排列组合，所以只要输入一阶特征就行，省去了手动构造高阶特征的工作量。</li></ul><h4 id="6、模型评估"><a href="#6、模型评估" class="headerlink" title="6、模型评估"></a>6、模型评估</h4><ul><li>模型评估很重要，是向别人证明你的模型怎么好的依据，我也就知道过拟合、欠拟合、交差验证、ROC、分类中查全率，查准率这些概念，没有个比较整体的认识，后面抽时间了解后再来补充。</li></ul><h3 id="二、常见的监督学习算法模型"><a href="#二、常见的监督学习算法模型" class="headerlink" title="二、常见的监督学习算法模型"></a>二、常见的监督学习算法模型</h3><p>哈哈，先留坑，后面慢慢填</p><h4 id="1、LR（逻辑回归）"><a href="#1、LR（逻辑回归）" class="headerlink" title="1、LR（逻辑回归）"></a>1、LR（逻辑回归）</h4><ul><li>线性模型的基础上增加了sigmoid函数，处理二分类问题，广义的线性模型，在CTR预估中有大作用</li></ul><h4 id="2、SVM-支持向量机"><a href="#2、SVM-支持向量机" class="headerlink" title="2、SVM(支持向量机)"></a>2、SVM(支持向量机)</h4><ul><li><p>可以处理非线性问题，深度学习未火之前，是学术界和工业界的热点，</p><p>数据规模较小时，能够构建出数据间的非线性关系，</p><p>1、SVM的原始公式是如何由实际问题产生，算法的灵魂</p><p>2、SVM原始问题到对偶问题的数学推导公式</p></li></ul><h4 id="3、NB-朴素贝叶斯"><a href="#3、NB-朴素贝叶斯" class="headerlink" title="3、NB(朴素贝叶斯)"></a>3、NB(朴素贝叶斯)</h4><ul><li>基于贝叶斯定理的一组有监督学习算法，<strong>朴素</strong>：“简单”地假设每对特征之间相互独立；</li><li>在很多实际情况下，朴素贝叶斯工作得很好，特别是<strong>文档分类</strong>和<strong>垃圾邮件过滤</strong>。这些工作都要求 一个小的训练集来估计必需参数。</li></ul><p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/naive_bayes.html" target="_blank" rel="noopener">http://sklearn.apachecn.org/cn/0.19.0/modules/naive_bayes.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;高能预警&lt;/strong&gt;：本人非算法开发，以下是我的一些浅见。&lt;/p&gt;
&lt;h3 id=&quot;一、开篇&quot;&gt;&lt;a href=&quot;#一、开篇&quot; class=&quot;headerlink&quot; title=&quot;一、开篇&quot;&gt;&lt;/a&gt;一、开篇&lt;/h3&gt;&lt;p&gt;自有机器学习以来，算法模型中
      
    
    </summary>
    
      <category term="机器学习" scheme="http://buaa0300/nanhuacoder.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈JavaScriptCore</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/02/28/iOS11-jscore/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/02/28/iOS11-jscore/</id>
    <published>2018-02-27T16:07:41.000Z</published>
    <updated>2019-03-23T05:07:24.321Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="一、JavaScriptCore核心类和协议"><a href="#一、JavaScriptCore核心类和协议" class="headerlink" title="一、JavaScriptCore核心类和协议"></a>一、JavaScriptCore核心类和协议</h4></blockquote><ul><li><p>JavaScriptCore给iOS开发的第一反应是<strong>实现原生应用和Web应用之间通信</strong></p></li><li><p>实际上，JavaScriptCore是iOS 7推出的<strong>JavaScript引擎</strong>，是为了实现OC和JS通信，使用场景不局限于在原生应用和Web应用间使用(<em>虽然这是大部分场景</em>)。</p></li></ul><h5 id="1、-JSContext"><a href="#1、-JSContext" class="headerlink" title="1、 JSContext"></a>1、 JSContext</h5><ul><li><strong>JavaScript运行的上下文环境</strong>，使用JSContext对象来执行JavaScript代码，所有的JSValue对象都由JSContext对象管理。</li></ul><h5 id="2、JSValue"><a href="#2、JSValue" class="headerlink" title="2、JSValue"></a>2、JSValue</h5><ul><li><p><strong>代表一个JavaScript实体</strong>，不仅可以表示JavaScript原始类型数据如boolean、Number、String等，还可以表示对象和函数。OC和JS对象之间的转换如下表：</p><pre><code>|Objective-C type  |   JavaScript type||--|--||nil | undefined||NSNull       |        null||NSString      |       string||NSNumber      |   number, boolean||NSDictionary    |   Object object||NSArray       |    Array object||NSDate       |     Date object||NSBlock   |   Function object ||id     |   Wrapper object ||Class | Constructor object|</code></pre></li></ul><h5 id="3、-JSManagedValue"><a href="#3、-JSManagedValue" class="headerlink" title="3、 JSManagedValue"></a>3、 JSManagedValue</h5><ul><li>本质是<strong>弱引用的JSValue对象</strong>，可以处理内存管理中的一些特殊情形，它能帮助引用技术和垃圾回收这两种内存管理机制之间进行正确的转换。如代替JSValue对象被OC对象持有避免发生循环引用(<em>本文后面会讲解</em>)。</li></ul><h5 id="4、JSVirtualMachine"><a href="#4、JSVirtualMachine" class="headerlink" title="4、JSVirtualMachine"></a>4、JSVirtualMachine</h5><ul><li><strong>JavaScript运行的虚拟机</strong>，拥有自己的堆结构和垃圾回收机制。大部分情况下不需要和它直接交互，除非要处理一些特殊的多线程或者内存管理问题。</li></ul><h5 id="5、JSExport"><a href="#5、JSExport" class="headerlink" title="5、JSExport"></a>5、JSExport</h5><ul><li><p><strong>将OC对象直接转成JS对象的协议</strong>，可以将OC类的属性或方法转换为JS的属性或方法。使用时，继承JSExport定义自己的协议，然后在自己的协议中定义暴露给JavaScript的方法；</p></li><li><p><strong>方法由Objective-C中的类实现</strong>；JavaScriptCore将实现类的对象注入JSContext运行环境中，使用注入的名称调用JS方法就会自动调用这个对象对应的OC方法。</p></li></ul><blockquote><h4 id="二、Objective-C调用JavaScript代码"><a href="#二、Objective-C调用JavaScript代码" class="headerlink" title="二、Objective-C调用JavaScript代码"></a>二、Objective-C调用JavaScript代码</h4></blockquote><h5 id="1、Objective-C直接执行JavaScript代码"><a href="#1、Objective-C直接执行JavaScript代码" class="headerlink" title="1、Objective-C直接执行JavaScript代码"></a>1、Objective-C直接执行JavaScript代码</h5><p><strong>1）JSContext</strong>为JavaScript提供运行的上下文环境，执行JavaScript代码前必须先创建JSContext对象，创建JSContext对象之后，才可以调用JSContext的evaluateScript:方法可以执行JavaScript代码了，如创建变量，做计算，定义方法等。</p><p><strong>2）JSContext</strong>的创建都是基于<strong>JSVirtualMachine</strong>(<em>JSVirtualMachine为JavaScript的运行提供了底层资源</em>)，默认使用init进行初始化，在其内部会自动创建一个新的JSVirtualMachine对象，然后根据JSVirtualMachine对象初始化JSContext对象。</p><p><strong>3）JSContext的evaluateScript:方法的返回值类型是JSValue</strong>， JSValue 封装了每一个可能的 JavaScript 值，如字符串和数字、数组、对象、方法、甚至错误和特殊的 JavaScript 值诸如 null 和 undefined等。对JSValue调用toString、toBool、toDouble、toArray等等方法把它转换成合适的Objective-C值或对象。</p><p><strong>4） 示例代码如下</strong>。XCode控制台输出12，是调用add(5,7)代码执行后的结果值。</p><pre><code>- (void)ocCallJsCode{    JSContext *context = [[JSContext alloc]init];    [context evaluateScript:@&quot;var a = 5,b = 7&quot;];    [context evaluateScript:@&quot;function add(a,b){return a+b}&quot;];    JSValue *addValue = [context evaluateScript:@&quot;add(5,7)&quot;];    NSLog(@&quot;addValue = %d&quot;,addValue.toInt32);    }</code></pre><h5 id="2、Objective-C执行JavaScript代码文件"><a href="#2、Objective-C执行JavaScript代码文件" class="headerlink" title="2、Objective-C执行JavaScript代码文件"></a>2、Objective-C执行JavaScript代码文件</h5><p>首先初始化了一个JSContext对象，然后执行JavaScript文件中的代码，最后从JSContext对象中取出JS函数，使用callWithArguments:调用JS函数，参数是一个数组，如果没有参数则传入空数组@[]</p><p><strong>1）在项目中新建一个occalljs.js的文件，定义了加减乘除四个JS函数，代码如下：</strong></p><pre><code>function add(a,b){    return a + b}function sub(a,b){    return a - b}function mul(a,b){    return a * b}function div(a,b){    return a / b}</code></pre><p><strong>2） OC代码中执行JS代码文件</strong></p><pre><code>- (void)ocCallJsCodeInFile{    JSContext *context = [[JSContext alloc]init];    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;calculate&quot; ofType:@&quot;js&quot;];    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];    [context evaluateScript:jsContent];    JSValue *addValue = [context[@&quot;add&quot;] callWithArguments:@[@5,@7]];    NSLog(@&quot;5 + 7 = %d&quot;,addValue.toInt32);    JSValue *subValue = [context[@&quot;sub&quot;] callWithArguments:@[@5,@7]];    NSLog(@&quot;5 - 7 = %d&quot;,subValue.toInt32);    JSValue *mulValue = [context[@&quot;mul&quot;] callWithArguments:@[@5,@7]];    NSLog(@&quot;5 * 7 = %d&quot;,mulValue.toInt32);    JSValue *divValue = [context[@&quot;div&quot;] callWithArguments:@[@5,@7.0]];    NSLog(@&quot;5 / 7 = %.2lf&quot;,divValue.toDouble);}</code></pre><p><strong>总结：</strong>通过JSContext和JSValue的配合使用，实现了Objective-C执行JavaScript代码。</p><blockquote><h4 id="三、JavaScript调用Objective-C代码"><a href="#三、JavaScript调用Objective-C代码" class="headerlink" title="三、JavaScript调用Objective-C代码"></a>三、JavaScript调用Objective-C代码</h4></blockquote><p>可以使用两种方式实现JavaScript调用Objective-C代码</p><h5 id="方式一：在OC中定义block，使用block代替JS的函数实现"><a href="#方式一：在OC中定义block，使用block代替JS的函数实现" class="headerlink" title="方式一：在OC中定义block，使用block代替JS的函数实现"></a>方式一：在OC中定义<strong>block</strong>，使用block代替JS的函数实现</h5><p>代码如下：</p><p><strong>1、新建一个jscalloc1.js的文件，定义了两个方法，代码如下：</strong></p><pre><code>function sayHello() {    print(&quot;你好&quot;);}function showAlert() {    alert(&quot;Alert!!!&quot;);}</code></pre><p><strong>2、oc中实现block代替js方法，代码如下：</strong></p><pre><code>- (void)jsCalloc1{    JSContext *context = [[JSContext alloc]init];    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;jscalloc&quot; ofType:@&quot;js&quot;];    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];    [context evaluateScript:jsContent];    //block替换js中的print方法    context[@&quot;print&quot;] = ^(NSString *printStr){        NSLog(@&quot;printStr = %@&quot;,printStr);    };    __weak typeof(self) weakSelf = self;    //block替换js中的alert方法    context[@&quot;alert&quot;] = ^(NSString *alertStr){        __strong typeof(weakSelf) strongSelf = weakSelf;        UIAlertController *vc = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:alertStr preferredStyle:UIAlertControllerStyleAlert];        [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDestructive handler:nil]];        [strongSelf presentViewController:vc animated:YES completion:nil];    };    //执行    [context[@&quot;sayHello&quot;] callWithArguments:nil];    [context[@&quot;showAlert&quot;] callWithArguments:nil];}</code></pre><p><strong>说明1</strong>：在代码中，我们将两个Block分别以”print”和“alert”为名传递给JavaScript上下文。在JS中调用print函数或者alert函数，其实就是执行在oc中定义的Block；也就实现了<strong>JavaScript调用Objective-C代码</strong>。</p><p><strong>说明2</strong>：JavaScript中的字符串可以无缝的桥接为NSString。</p><p><strong>说明3</strong>: 当JavaScript运行时出现异常，会回调JSContext的exceptionHandler中设置的Block，我们通过Block的方式将异常信息打印处理</p><pre><code>context.exceptionHandler = ^(JSContext *context, JSValue *exception) {       NSLog(@&quot;JS Error: %@&quot;, exception);};</code></pre><h5 id="方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中"><a href="#方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中" class="headerlink" title="方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中"></a>方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中</h5><p>代码如下：</p><p><strong>1、新建一个jscalloc2.js的文件，定义了两个方法，代码如下：</strong></p><pre><code>function sayHello() {    qsobj.print(&quot;你好&quot;);}function showAlert() {    qsobj.alert(&quot;Alert!!!&quot;);}</code></pre><p><strong>2、OC中实现QSExportObject类，将QSExportObject对象qsobj注入到JS执行的上下文环境中，JS中执行qsobj.print和qsobj.alert函数，就是执行OC对象qsobj的方法</strong>，代码如下：</p><pre><code> //QSExportObject.h@protocol QSExport &lt;JSExport&gt;- (void)print:(NSString *)text;- (void)alert:(NSString *)text;//JSExportAs(print,- (void)print:(NSString *)text);//JSExportAs(alert,- (void)alert:(NSString *)text);@end@interface QSExportObject : NSObject&lt;QSExport&gt;@property (nonatomic,weak)UIViewController *vc;@end//QSExportObject.m@implementation QSExportObject- (void)print:(NSString *)text{    NSLog(@&quot;print text = %@&quot;,text);}- (void)alert:(NSString *)text{    UIAlertController *vc = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:text preferredStyle:UIAlertControllerStyleAlert];    [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDestructive handler:nil]];    [self.vc presentViewController:vc animated:YES completion:nil];}@end//在ViewController中调用 - (void)jsCallOc2{    JSContext *context = [[JSContext alloc]init];    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;jscalloc2&quot; ofType:@&quot;js&quot;];    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];    [context evaluateScript:jsContent];    //注入qsObj    QSExportObject *qsObj = [QSExportObject new];    qsObj.vc = self;    context[@&quot;qsobj&quot;] = qsObj;     //执行    [context[@&quot;sayHello&quot;] callWithArguments:nil];    [context[@&quot;showAlert&quot;] callWithArguments:nil];}</code></pre><p><strong>说明1</strong>：在QSExport中定义暴露给JS的接口，也可以使用宏<strong>JSExportAs</strong>，它将JS函数和OC方法绑定在一起；对于OC中多参数的方法，一般使用<strong>JSExportAs</strong>。</p><blockquote><h4 id="四、循环引问题"><a href="#四、循环引问题" class="headerlink" title="四、循环引问题"></a>四、循环引问题</h4></blockquote><p><strong>说明</strong>：Objective-C的内存管理机制是<strong>引用计数</strong>，JavaScript的内存管理机制是<strong>垃圾回收</strong>。在大部分情况下，JavaScriptCore能做到在这两种内存管理机制之间无缝无错转换，但是有些情况下会发生循环引用。</p><h4 id="1、block直接使用self-context-会发生循环引用"><a href="#1、block直接使用self-context-会发生循环引用" class="headerlink" title="1、block直接使用self.context 会发生循环引用"></a>1、block直接使用self.context 会发生循环引用</h4><p>打破这类循环引用的办法有两种。</p><p><strong>1）方法1：weakSelf和strongSelf</strong></p><pre><code>[self.context evaluateScript:@&quot;function printAppVersion() { print(getAppVersion())}&quot;];self.context[@&quot;print&quot;] = ^(NSString *printStr){    NSLog(@&quot;printStr = %@&quot;,printStr);};__weak typeof(self) weakSelf = self;self.context[@&quot;getAppVersion&quot;] = ^{    __strong typeof(weakSelf) strongSelf = weakSelf;    NSString* versionString = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];    versionString = [@&quot;App Version &quot; stringByAppendingString:versionString];    JSContext *context = strongSelf.context;    JSValue *version = [JSValue valueWithObject:versionString inContext:context];    return version;};//执行[self.context[@&quot;printAppVersion&quot;] callWithArguments:nil];</code></pre><p><strong>2）方法2：block内使用[JSContext currentContext]代替self.context</strong></p><pre><code>[self.context evaluateScript:@&quot;function printAppVersion() { print(getAppVersion())}&quot;];self.context[@&quot;print&quot;] = ^(NSString *printStr){    NSLog(@&quot;printStr = %@&quot;,printStr);};self.context[@&quot;getAppVersion&quot;] = ^{    NSString* versionString = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];    versionString = [@&quot;App Version &quot; stringByAppendingString:versionString];    JSContext *context = [JSContext currentContext];    JSValue *version = [JSValue valueWithObject:versionString inContext:context];    return version;};//执行[self.context[@&quot;printAppVersion&quot;] callWithArguments:nil];</code></pre><h4 id="2、block中使用外部定义的JSValue对象不会发生循环引用"><a href="#2、block中使用外部定义的JSValue对象不会发生循环引用" class="headerlink" title="2、block中使用外部定义的JSValue对象不会发生循环引用"></a>2、block中使用外部定义的JSValue对象不会发生循环引用</h4><pre><code>[self.context evaluateScript:@&quot;function log() { }&quot;];JSValue *value = [JSValue valueWithObject:@&quot;test content&quot; inContext:self.context];self.context[@&quot;log&quot;] = ^(){    NSLog(@&quot;%@&quot;,value);};[self.context[@&quot;log&quot;] callWithArguments:nil];</code></pre><p><strong>原因：</strong>在block里面直接使用外部定义的JSValue对象不会发生循环引用。以上诉代码为例，JSContext强引用了一个log函数，log函数中又强引用了JSValue对象，JSValue对象强引用JSContext对象和保存的值，JSContext对象引用它管理的所有JSValue对象，这样JSContext和JSValue看上去是循环引用的，然而并不会，<strong>垃圾回收机制会打破这个循环引用</strong>。</p><h4 id="3、OC对象保存JSValue容易引起循环引用"><a href="#3、OC对象保存JSValue容易引起循环引用" class="headerlink" title="3、OC对象保存JSValue容易引起循环引用"></a>3、OC对象保存JSValue容易引起循环引用</h4><p>假设下面这样的场景，定义QSAlertView类，该类中持有successHandler，failureHandler这两个JSValue对象，使用block方式注入JS方法时候</p><pre><code>self.context[@&quot;presentNativeAlert&quot;] = ^(NSString *title,                                        NSString *message,                                        JSValue *successHandler,                                        JSValue *failureHandler) {    JSContext *context = [JSContext currentContext];    QSAlertView *alertView = [[QSAlertView alloc] initWithTitle:title                                                        message:message                                                        successHandler:successHandler                                                 failureHandler:failureHandler                                                        context:context];    [alertView show];};</code></pre><p><strong>说明</strong>：因为JavaScript环境中都是“强引用”（相对Objective-C的概念来说）的，这时JSContext强引用了一个presentNativeAlert函数，这个函数中又强引用了QSAlertView，等于说JSContext强引用了QSAlertView，而QSAlertView为了持有两个回调强引用了successHandler和failureHandler这两个JSValue，而JSValue又是强引用JSContext的，循环引用便出现了。</p><p><strong>打破该类循环引用的方式是：JSMagagedValue对象代替JSValue对象被OC对象持有</strong></p><blockquote><h4 id="五、JSMagagedValue类使用"><a href="#五、JSMagagedValue类使用" class="headerlink" title="五、JSMagagedValue类使用"></a>五、JSMagagedValue类使用</h4></blockquote><p><strong>JSMagagedValue类</strong>：弱引用对象，需要调用JSVirtualMachine的addManagedReference:withOwner:把它添加到JSVirtualMachine对象中，确保使用过程中JSValue不会被释放 </p><pre><code>//QSAlertView.h@interface QSAlertView : UIAlertView- (instancetype)initWithTitle:(NSString *)title                      message:(NSString *)message               successHandler:(JSValue *)successHandler               failureHandler:(JSValue *)failureHandler                      context:(JSContext *)context;@end//QSAlertView.m@interface QSAlertView() &lt;UIAlertViewDelegate&gt;@property (nonatomic,strong) JSContext *context;@property (nonatomic,strong) JSManagedValue *successHandler;@property (nonatomic,strong) JSManagedValue *failureHandler;@end@implementation QSAlertView- (instancetype)initWithTitle:(NSString *)title                      message:(NSString *)message               successHandler:(JSValue *)successHandler               failureHandler:(JSValue *)failureHandler                      context:(JSContext *)context{    self = [super initWithTitle:title message:message delegate:self cancelButtonTitle:@&quot;NO&quot; otherButtonTitles:@&quot;YES&quot;, nil];    if (self) {        _context = context;        _successHandler = [JSManagedValue managedValueWithValue:successHandler];        _failureHandler = [JSManagedValue managedValueWithValue:failureHandler];        //添加JSManagedValue对象到JSVirtualMachine对象中，防止使用过程被释放        [_context.virtualMachine addManagedReference:_successHandler withOwner:self];        [_context.virtualMachine addManagedReference:_failureHandler withOwner:self];    }    return self;}- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{    NSString *btnTitle = [alertView buttonTitleAtIndex:buttonIndex];    if ([btnTitle isEqualToString:@&quot;YES&quot;]) {        JSValue *function = [self.successHandler value];        [function callWithArguments:@[]];    }else{        JSValue *function = [self.failureHandler value];        [function callWithArguments:@[]];    }    //移除JSManagedValue对象    [self.context.virtualMachine removeManagedReference:_successHandler withOwner:self];    [self.context.virtualMachine removeManagedReference:_failureHandler withOwner:self];}@end</code></pre><p><strong>说明1</strong>：外部传入的JSValue对象在类内部使用JSManagedValue(弱引用对象)来保存<br><strong>说明2</strong>：JSManagedValue对象因为是弱引用对象，需要调用JSVirtualMachine的addManagedReference:withOwner:把它添加到JSVirtualMachine对象中，确保使用过程中JSValue不会被释放<br><strong>说明3</strong>：当用户点击QSAlertView上的按钮时，根据用户点击哪一个按钮，来执行对应的处理函数，这时QSAlertView也随即被销毁。 这时需要手动调用removeManagedReference:withOwner:来移除JSManagedValue对象。</p><pre><code>//OC执行JS代码[self.context evaluateScript:@&quot;function success() {print(&apos;success&apos;) }&quot;];[self.context evaluateScript:@&quot;function failure() {print(&apos;failure&apos;) }&quot;];self.context[@&quot;print&quot;] = ^(NSString *printStr){    NSLog(@&quot;printStr = %@&quot;,printStr);};self.context[@&quot;presentNativeAlert&quot;] = ^(NSString *title,                                        NSString *message,                                        JSValue *successHandler,                                        JSValue *failureHandler) {    JSContext *context = [JSContext currentContext];    QSAlertView *alertView = [[QSAlertView alloc] initWithTitle:title                                                        message:message                                                        successHandler:successHandler                                                 failureHandler:failureHandler                                                        context:context];    [alertView show];};[self.context evaluateScript:@&quot;presentNativeAlert(&apos;提示&apos;,&apos;这是一条警告&apos;,success,failure)&quot;];</code></pre><p><strong>说明1</strong>：在JS中定义了success和failure函数，为JS中的print函数和presentNativeAlert函数注入OC实现。<br><strong>说明2</strong>：点击弹出框的YES，调用JS的success函数，点击弹出框的NO，调用JS的failure函数。</p><p><strong>效果图如下：</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/201701-b063e377adf7528c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JS函数弹出OC警告框的效果图.png"></p><h4 id="六、UIWebView中获取JSContext"><a href="#六、UIWebView中获取JSContext" class="headerlink" title="六、UIWebView中获取JSContext"></a>六、UIWebView中获取JSContext</h4><p>JavaScriptCore实现JS和OC交互是依赖<strong>JSContext对象</strong>，而在UIWebView使用中，不应该手动去创建JSContext对象，因为手动创建JSContext对象和UIWebView对应的JSContext对象并不是同一个JS上下文环境。我们应该去获取UIWebView对应的JSContext对象，虽然Apple并未提供直接的方式，但是我们可以通过KVC +  Runtime这两种方式去获取</p><h5 id="1、KVC"><a href="#1、KVC" class="headerlink" title="1、KVC"></a>1、KVC</h5><pre><code>JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</code></pre><p>使用简单，但是坑比较多，项目不推荐</p><p><strong>原因一</strong>：方法暴力，有不被APP Store的审核通过的风险<br><strong>原因二</strong>：通过KVC获取JSContext对象的时机不好控制，</p><ul><li><p>在UIWebView的<strong>shouldStartLoadWithRequest</strong>或者<strong>webViewDidStartLoad</strong>阶段中获取context，由于此时页面中的JS代码并没有完全加载完，所以JS中定义的函数在OC端无法被执行。还会出现在加载一级页面时JS可以正常调用OC的方法，而跳转到二级页面中无法执行OC的方法。</p></li><li><p>在UIWebView的<strong>webViewDidFinishLoad</strong>阶段获取context,并暴露OC方法，由于加载JS的时机在<strong>webVIewDidFinishLoad</strong>阶段之前，因此会发生JS无法调用OC方法的情况发生。</p></li></ul><h5 id="2、Runtime-（项目中使用）"><a href="#2、Runtime-（项目中使用）" class="headerlink" title="2、Runtime （项目中使用）"></a>2、Runtime （项目中使用）</h5><p>UIWebViewTS_JavaScriptContet项目：通过 runtime 机制，巧妙地获取 JavaScriptContext 创建之后，生成回调。</p><p>在项目中，实现TSWebViewDelegate中的didCreateJavaScriptContext方法，可以获取UIWebView对应的JSContext对象</p><pre><code>- (void)webView:(UIWebView *)webView didCreateJavaScriptContext:(JSContext*) ctx{      //ctx就是UIWebView对应的JSContext对象}</code></pre><blockquote><h4 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h4></blockquote><ul><li><p>之前的笔记整理，主要介绍JavaScriptCore的使用，为后续JavaScriptCore深入使用做准备。</p></li><li><p>本文参考了<a href="http://liuduo.me/2015/10/24/JavaScriptCore%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">JavaScriptCore初探</a> 和 <a href="https://segmentfault.com/a/1190000004285316" target="_blank" rel="noopener">iOS引入JavaScriptCore引擎框架</a></p></li><li><p><a href="https://github.com/buaa0300/QSKitDemo/tree/master/QSUseJSCoreDemo" target="_blank" rel="noopener">QSUseJSCoreDemo</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;一、JavaScriptCore核心类和协议&quot;&gt;&lt;a href=&quot;#一、JavaScriptCore核心类和协议&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScriptCore核心类和协议&quot;&gt;&lt;/a&gt;一、JavaS
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Runtime</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/02/06/iOS10-runtime/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/02/06/iOS10-runtime/</id>
    <published>2018-02-06T14:53:28.000Z</published>
    <updated>2019-03-23T05:07:10.387Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C利用Runtime库(底层的 C 语言 API)赋予了语言的动态特性。</p><blockquote><h4 id="一、Runtime基石：Objective-C对象模型"><a href="#一、Runtime基石：Objective-C对象模型" class="headerlink" title="一、Runtime基石：Objective-C对象模型"></a>一、Runtime基石：Objective-C对象模型</h4></blockquote><h5 id="1、对象"><a href="#1、对象" class="headerlink" title="1、对象"></a>1、对象</h5><ul><li><p>每一个对象都是<strong>类的实例</strong>, 类中保存<strong>对象的方法列表</strong>；当一个对象方法被调用时，类会首先查找它本身是否有该方法的实现，如果没有，则会向它的父类查找该方法，直到NSObject(根类)；</p></li><li><p>类是<strong>元类 (metaclass) 的实例</strong>；元类保存<strong>类方法列表</strong>；当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则会向它的父类查找该方法，直到NSObject(根类)；</p></li></ul><h5 id="2、isa指针"><a href="#2、isa指针" class="headerlink" title="2、isa指针"></a>2、isa指针</h5><ul><li><p>对象的<strong>isa指针</strong>指向所属的类，类的<strong>isa指针</strong>指向所属的元类；所有的元类的 <strong>isa指针</strong>都会指向一个根元类 (root metaclass)。根元类的 <strong>isa指针</strong>指向自己，行成了一个闭环。</p></li><li><p>在64 位 CPU 下，isa 的内部结构有变化。具体查看用<a href="http://ios.jobbole.com/89485/" target="_blank" rel="noopener"> isa 承载对象的类信息</a></p></li><li><p>对象、isa指针、类、元类、根元类的关系如下图：</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/201701-fa143a7c6b17b43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="OC类图.png"></p><h5 id="3、对象布局"><a href="#3、对象布局" class="headerlink" title="3、对象布局"></a>3、对象布局</h5><ul><li><p>实例变量（包括父类）都保存在对象本身的存储空间内；实例方法保存在<strong>类</strong>中，类方法保存在<strong>元类</strong>中；父类的实例方法保存在各级 super class 中，父类的类方法保存在各级 super meta class;</p><pre><code>//对象组成 --start--isa pointerrootClass&apos;s varspenultimate superClass&apos;s vars...superClass&apos;s varsClass&apos;s vars//对象组成 --end--typedef struct objc_class *Class; //类的结构 struct objc_class{  struct objc_class* isa;                              //指向元类  struct objc_class* super_class;                //指向父类  const char* name;  long version;  long info;  long instance_size;  struct objc_ivar_list* ivars;                         //实例变量列表  struct objc_method_list** methodLists;      //方法列表  struct objc_cache* cache;  struct objc_protocol_list* protocols;           //协议列表};//实例变量的结构struct objc_ivar {    char *ivar_name  OBJC2_UNAVAILABLE;    char *ivar_type  OBJC2_UNAVAILABLE;    int ivar_offset  OBJC2_UNAVAILABLE;#ifdef __LP64__    int space        OBJC2_UNAVAILABLE;#endif}</code></pre><p>  <strong>说明1</strong>：对象中保存指向类的<code>isa</code>指针 以及 各级的 实例变量(<code>ivar</code>)，这个内存结构在编译时就确定下来了，不能在编译时给对象增加实例变量。</p><p>  <strong>说明2</strong>：类的内存布局有<code>isa</code>指针、<code>super_class</code>指针、实例变量列表、方法列表和协议列表，其中实例变量(var)包含了变量的名称、类型、偏移等。</p></li></ul><blockquote><h4 id="二、Runtime核心：消息发送和转发"><a href="#二、Runtime核心：消息发送和转发" class="headerlink" title="二、Runtime核心：消息发送和转发"></a>二、Runtime核心：消息发送和转发</h4></blockquote><p><strong>Runtime</strong>赋予了OC了诸多动态特性，使其可以在运行时可以做一些事情；主要表现为：<strong>动态类型</strong>（在运行时才检查对象类型）和 <strong>动态绑定</strong>（接到消息后，由运行环境决定执行哪部分代码）</p><h5 id="1、消息发送（Message）"><a href="#1、消息发送（Message）" class="headerlink" title="1、消息发送（Message）"></a>1、消息发送（Message）</h5><ul><li><p>Objective-C 中的方法调用，实质上是在底层用objc_msgSend()实现<strong>消息发送</strong>，其核心在于：<strong>根据SEL(选择器)开始找到IMP</strong>；其中SEL是实例方法的指针，可以看做方法名字符串；IMP是函数指针，指向方法实现的地址。</p><pre><code>//调用方法  [obj doSomething];//在编译时候转换objc_msgSend(obj,@selector(doSomething))</code></pre></li><li><p><strong>objc_msgSend</strong>的定义如下：</p><pre><code>// self是接收者，接收该消息的类的实例 // _cmd是选择器，要处理的消息的selector  // ... 是需传入的参数，参数个数不定 objc_msgSend(id self, SEL _cmd, ...) </code></pre></li><li><p><strong>objc_msgSend的发送流程</strong>：先在Class中的缓存查找imp（没缓存则初始化缓存），如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，就走消息转发(_objc_msgForward)了。</p></li><li><p>给nil发送消息不会有什么作用，但是返回值有些区别，具体如下：</p><pre><code>a) 如果方法返回值是 对象，返回nilb) 如果方法返回值是 指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量c) 如果方法返回值是 结构体，发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。d) 如果方法返回值不是 上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。</code></pre></li></ul><h5 id="2-1、消息转发（Message-Forwarding）"><a href="#2-1、消息转发（Message-Forwarding）" class="headerlink" title="2-1、消息转发（Message Forwarding）"></a>2-1、消息转发（Message Forwarding）</h5><p>消息转发解决的是：查找IMP(方法实现)失败后的处理；经历<strong>动态方法解析</strong>、 <strong>备用接收者</strong>和 <strong>完整的消息转发</strong>三个过程，其流程如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/201701-35938988b21e8a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发流程.png"></p><ul><li><p><strong>动态方法解析</strong>：接收到未知消息时，Runtime向当前类发送+resolveInstanceMethod:或+resolveClassMethod:消息，在这里可以<strong>添加缺失的方法</strong>，返回YES，重新发送消息，否则继续下一步；</p></li><li><p><strong>备用接收者</strong>：<strong>动态方法解析</strong>中没能处理，Runtime会向forwardingTargetForSelector:发消息，如果该方法返回了一个非nil或非self对象，恰好该对象实现了这个方法，那么该对象就成了消息的接收者，消息就被分发到该对象。</p></li><li><p><strong>完整消息转发</strong>：前两个都没能处理好，Runtime发送methodSignatureForSelector:消息，获取selector对应方法的签名；如果有方法签名返回，则根据方法签名创建描述消息的NSInvocation，向当前对象发送forwardInvocation:消息；如果没有方法签名返回，返回nil，向当前对象发送doesNotRecognizeSelector:消息，应用Crash退出。</p></li></ul><h5 id="2-2、避免消息转发的办法"><a href="#2-2、避免消息转发的办法" class="headerlink" title="2-2、避免消息转发的办法"></a>2-2、避免消息转发的办法</h5><p><strong>在消息转发三个过程中，未知消息的处理过程越往后，代价越大</strong>；一般我们可以这么做 尽可能避免消息转发，可以这么做：</p><ul><li><p><strong>调用delegate 方法前检查方法是否实现</strong>(respondsToSelector:), 只有实现了(respondsToSelector:返回YES) ，才去真正调用delegate 方法。</p><pre><code>if([self.delegate respondsToSelector: @selector(sayHello)]) {    [self.delegate sayHello];}</code></pre></li><li><p><strong>直接调用方法，少用performSelector:</strong>；因为在直接调用方法时，编译自动校验，如果方法不存在，编译器会直接报错；而使用performSelector:的话一定是在运行时候才能发现，如果此方法不存在就会崩溃。</p><pre><code>//直接使用方法调用,少使用performSelector[dog sayHello];// [dog performSelector:@selector(sayHello) withObject:nil];</code></pre></li><li><p><strong>使用performSelector:，最好先判断方法是否实现(respondsToSelector:)</strong>，只有实现了(respondsToSelector:返回YES) ，才去调用performSelector：方法。</p><pre><code>//respondsToSelector:和performSelector:组合使用    if ([dog respondsToSelector:@selector(sayHello)])         {    [dog performSelector:@selector(sayHello)]; }</code></pre></li><li><p><strong>强制类型转换，先判断对象是否属于强制转换后的类</strong></p><pre><code>if([data isKindOfClass:[NSDictionary class]]){  //}</code></pre></li></ul><blockquote><h4 id="三、Runtime特性和应用"><a href="#三、Runtime特性和应用" class="headerlink" title="三、Runtime特性和应用"></a>三、Runtime特性和应用</h4></blockquote><h5 id="1、分类（Category）"><a href="#1、分类（Category）" class="headerlink" title="1、分类（Category）"></a>1、分类（Category）</h5><ul><li><p><strong>原理</strong>：对象的<strong>方法</strong>定义都保存在类的可变区域中，修改methodLists指针指向的指针的值，就可以实现动态地为某一个类增加<strong>成员方法</strong>。(<em>但是对象布局在编译时候就固定了，结构体的大小并不能动态变化，在运行时不能增加实例变量</em>)。</p></li><li><p>通过关联<code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code>方法可以变相地给对象增加实例变量，并不会真正改变了对象的内存结构。</p></li><li><p>通过Category新增的方法，会插入到方法列表的前部；如果有和原来方法重名，在运行时，顺序查找时，一旦找到对应名字的方法，就不再查找，导致<strong>原来方法</strong>得不到机会，<em>这是Category新增的方法和原方法重名，原有方法失效的原因</em>。</p></li><li><p><strong>作用</strong>：给现有的类添加方法；将一个类的实现拆分成多个独立的源文件；声明私有的方法。</p></li></ul><h5 id="2、关联对象（Associated-Objects）"><a href="#2、关联对象（Associated-Objects）" class="headerlink" title="2、关联对象（Associated Objects）"></a>2、关联对象（Associated Objects）</h5><ul><li><p><strong>原理</strong>：Category不能给一个已有类添加实例变量，但是可以通过<strong>关联对象</strong>添加属性；但是关联对象不会改变对象的内存布局，新增的属性是添加到和对象地址关联的哈希表中；</p></li><li><p>Associated Objects 相关的三个方法</p><pre><code>objc_setAssociatedObject    //添加关联对象objc_getAssociatedObject    //获取关联对象objc_removeAssociatedObjects  // 删除所有关联对象</code></pre></li><li><p><strong>作用</strong>：为现有的类添加私有变量以帮助实现细节；为现有的类添加公有属性；为 KVO 创建一个关联的观察者</p><p>具体参考：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">Objective-C Associated Objects 的实现原理</a></p></li></ul><h5 id="3、方法混写-Method-Swizzling"><a href="#3、方法混写-Method-Swizzling" class="headerlink" title="3、方法混写(Method Swizzling)"></a>3、方法混写(Method Swizzling)</h5><ul><li><strong>原理</strong>：在运行时交换方法实现（IMP）</li></ul><ul><li><p><strong>作用</strong>：可以利用它hook原有的方法，插入自己的业务需求，</p><p> 详细参考我写的<a href="https://www.jianshu.com/p/5f2e38a40aa4" target="_blank" rel="noopener">Method Swizzling小记</a></p></li></ul><h5 id="4、键值观察（KVO）"><a href="#4、键值观察（KVO）" class="headerlink" title="4、键值观察（KVO）"></a>4、键值观察（KVO）</h5><p>  观察者模式在Objective-C的应用之一，借助Runtime特性，实现自动键值观察；使用了isa swizzling机制。具体描述如下：</p><ul><li><p>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个<strong>子类</strong>，在这个子类中<strong>重写</strong>基类中被观察属性的 setter 方法，实现真正的通知机制；</p></li><li><p>派生类还重写了 class 方法以“欺骗”外部调用者，系统将对象的 isa 指针指向这个<strong>新诞生的子类</strong>，实质上这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。</p></li><li><p>此外，派生类还重写了 dealloc 方法来释放资源。</p></li></ul><p><strong>说明</strong>：KVC（键值编码）是不通过存取方法，而通过属性名称字符串间接访问属性的机制，没有用到isa swizzling机制。</p><h5 id="5、NSProxy"><a href="#5、NSProxy" class="headerlink" title="5、NSProxy"></a>5、NSProxy</h5><ul><li><p>OC是单继承的，但是可以利用NSProxy实现一下<strong>“伪多继承”</strong>，具体参考<a href="">NSProxy——少见却神奇的类</a></p></li><li><p>项目中，主要是利用NSProxy做<strong>消息转发的代理类</strong>，如弱引用代理类，可以打破循环引用。</p><pre><code>//代码摘自 FLAnimatedImage@interface FLWeakProxy : NSProxy+ (instancetype)weakProxyForObject:(id)targetObject;   @end@interface FLWeakProxy ()@property (nonatomic, weak) id target;@end@implementation FLWeakProxy#pragma mark Life Cycle//类没有定义默认的init方法.+ (instancetype)weakProxyForObject:(id)targetObject{    FLWeakProxy *weakProxy = [FLWeakProxy alloc];    weakProxy.target = targetObject;    return weakProxy;}#pragma mark Forwarding Messages- (id)forwardingTargetForSelector:(SEL)selector{// Keep it lightweight: access the ivar directlyreturn _target;   }- (void)forwardInvocation:(NSInvocation *)invocation{    void *nullPointer = NULL;    [invocation setReturnValue:&amp;nullPointer];}- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector{    return [NSObject instanceMethodSignatureForSelector:@selector(init)];   }   @end</code></pre><p><strong>说明</strong>: NSProxy非常适合做消息转发的代理类，能自动转发<nsobject>中定义的接口和NSObject的Category中定义的方法，如果使用NSObject来做，不能自动转发NSObject的Category中定义、respondsToSelector:、isKindOfClass:这两个方法。·</nsobject></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Objective-C利用Runtime库(底层的 C 语言 API)赋予了语言的动态特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、Runtime基石：Objective-C对象模型&quot;&gt;&lt;a href=&quot;#一、Runtime基石：Objective-C对象模
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈RunLoop</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/02/04/iOS09-runloop/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/02/04/iOS09-runloop/</id>
    <published>2018-02-04T15:07:27.000Z</published>
    <updated>2019-03-23T05:07:16.135Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><ul><li><p><strong>RunLoop</strong>：运行循环，和线程有关；当没有事件/消息时，RunLoop让线程休眠；当有事件/消息发生时，RunLoop唤醒线程去处理。</p></li><li><p><strong>每个线程都有一个对应的 Runloop 对象</strong>；主线程的RunLoop会在App运行时自动运行，<strong>子线程中需要手动获取并运行，第一次获取时，才会去创建</strong>。</p></li><li><p>一个RunLoop包含若干个Mode,每个<strong>Mode</strong>包含若干个<strong>Source/Timer/Observer</strong>。每次启动RunLoop时，只能指定一个Mode，如果需要切换Mode，需要退出Loop，再重新指定一个Mode进入。</p></li><li><p>RunLoop处理两大类事件源：<strong>Timer Source</strong>和<strong>Input Source</strong>；每个事件源都会绑定在RunLoop的某个特定Mode上，而且只有RunLoop在这个Mode运行的时候才会触发该Timer和Input Source。</p></li><li><p>如果没有任何事件源添加到RunLoop上，RunLoop就会立刻退出。(<em>线程结束,RunLoop也会退出</em>)。</p></li><li><p>操作RunLoop，Foundation层对应的是<strong>NSRunLoop</strong>，Core Foundation层对应的是<strong>CFRunLoopRef</strong>；</p></li></ul><blockquote><h4 id="二、Runloop-Mode"><a href="#二、Runloop-Mode" class="headerlink" title="二、Runloop Mode"></a>二、Runloop Mode</h4></blockquote><ul><li><p>一个RunLoop包含若干个Mode,每个<strong>Mode</strong>包含若干个<strong>Source/Timer/Observer</strong>。每次启动RunLoop时，只能指定一个Mode，如果需要切换Mode，需要退出Loop，再重新指定一个Mode进入。</p></li><li><p>Foundation暴露出来的Mode有： <strong>NSDefaultRunLoopMode</strong> 和 <strong>NSRunLoopCommonModes</strong>；NSDefaultRunLoopMode是默认的Mode；NSRunLoopCommonModes 是Mode集合，包括NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode; 只要RunLoop运行在NSRunLoopCommonModes中任何一个模式，这个事件源都可以被触发。</p></li></ul><pre><code>NSDefaultRunLoopMode             //默认的运行方式NSTaskDeathCheckMode             //task任务UITrackingRunLoopMode            //UI跟踪（如UITableView上下滑动）NSRunLoopCommonModes             //Mode集合 //其他, 很少用NSModalPanelRunLoopMode       //在Model Panel情况下去区分事件(OS X开发中会遇到)NSConnectionReplyMode             //可以监听NSConnection对象的状态，比较少用</code></pre><p>  <strong>说明</strong>：RunLoop不能在运行在NSRunLoopCommonModes模式，因为NSRunLoopCommonModes只是个模式集合，而不是一个具体的模式。</p><blockquote><h4 id="三、Runloop事件源"><a href="#三、Runloop事件源" class="headerlink" title="三、Runloop事件源"></a>三、Runloop事件源</h4></blockquote><ul><li><p>事件源主要由两种： <strong>Timer Source</strong>和<strong>Input Source</strong>，其中<strong>Timer Source</strong> 指的是定时器事件， Input Source细分三类如下： </p><pre><code>Port-Based Sources，系统底层的Port 事件，例如 CFSocketRef ，在应用层基本用不到Custom Input Sources，用户手动创建的 SourceCocoa Perform Selector Sources， Cocoa 提供的 performSelector 系列方法</code></pre></li><li><p>如果没有任何事件源添加到RunLoop上，RunLoop就会立刻退出；</p></li></ul><blockquote><h4 id="四、Runloop-Observer"><a href="#四、Runloop-Observer" class="headerlink" title="四、Runloop Observer"></a>四、Runloop Observer</h4></blockquote><h5 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h5><ul><li><p>Runloop 通过监控 Source 来决定有没有任务要做，除此之外，我们还可以用 Runloop Observer 来监控 Runloop 本身的状态。RunLoop的状态有</p><pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {  kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop  kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer  kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source  kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠  kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒  kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop       };</code></pre></li></ul><h5 id="2、应用"><a href="#2、应用" class="headerlink" title="2、应用"></a>2、应用</h5><p><strong>1）AutoreleasePool</strong></p><ul><li><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，一个监听<strong>kCFRunLoopEntry</strong>（<em>即将进入Loop</em>），回调内会<strong>创建自动释放池</strong>(<em>_objc_autoreleasePoolPush()</em>)；优先级最高，保证创建释放池发生在其他所有回调之前；</p></li><li><p>另一个监听 <strong>kCFRunLoopBeforeWaiting</strong>(<em>准备进入休眠</em>) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；<strong>kCFRunLoopExit</strong>(<em>即将退出Loop</em>) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。优先级最低，保证其释放池子发生在其他所有回调之后。</p></li></ul><p><strong>2）界面更新</strong></p><ul><li><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p></li><li><p>苹果注册了一个 Observer 监听 <strong>kCFRunLoopBeforeWaiting</strong>(<em>即将进入休眠</em>) 和 <strong>kCFRunLoopExit</strong>(<em>即将退出Loop</em>)  事件，回调执行函数，函数会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p></li></ul><blockquote><h4 id="五、RunLoop手动启动和取消"><a href="#五、RunLoop手动启动和取消" class="headerlink" title="五、RunLoop手动启动和取消"></a>五、RunLoop手动启动和取消</h4></blockquote><h5 id="1、手动启动"><a href="#1、手动启动" class="headerlink" title="1、手动启动"></a>1、手动启动</h5><p>主线程默认已经启动，一般在子线程中手动启动RunLoop；NSRunloop提供的三种启动方式，如下：</p><pre><code>//1、无条件运行(强烈不推荐)- (void)run; </code></pre><p><strong>说明1</strong>：如果Runloop上有事件源，RunLoop会一直运行在NSDefaultRunLoopMode模式；除非移除事件源，线程才能停止；</p><pre><code>//2、启动 + 超时限制- (void)runUntilDate:(NSDate *)limitDate;  //Demo, RunLoop会每1秒退出一次，然后又启动RunLoop，连续10次后退出RunLoopNSInteger loopCount = 0;while (loopCount++ &lt; 10){      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];      NSLog(@&quot;%@ exiting runloop.........:&quot;,@(loopCount));}</code></pre><p><strong>说明2</strong>：可以控制每次RunLoop的运行时间，但是默认是NSDefaultRunLoopMode模式；超过时间限制后可以再次运行RunLoop；</p><pre><code>//3、有一个超时时间限制，而且设置运行模式 （推荐使用）- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;//Demo : 使用CFRunLoopStop暂停RunLoopdispatch_async(dispatch_get_global_queue(0, 0), ^{    NSLog(@&quot;线程开始&quot;);    _thread = [NSThread currentThread];    NSRunLoop *runloop = [NSRunLoop currentRunLoop];    [runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];    //    [runloop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:10]];    NSLog(@&quot;线程结束&quot;);});//延迟执行dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{    [self performSelector:@selector(stopRunLoop) onThread:_thread withObject:nil waitUntilDone:NO];});- (void)stopRunLoop{    CFRunLoopStop(CFRunLoopGetCurrent());    NSLog(@&quot;暂停runloop&quot;);}</code></pre><p><strong>说明3</strong>：可以设置超时限制和运行模式，比较灵活，还可以被CFRunLoopStop(runloopRef)所停止（<em>Demo显示</em>）。</p><p><strong>说明4</strong>：NSRunloop是基于CFRunloop来封装的，NSRunloop是线程不安全的，而CFRunloop则是线程安全的；CFRunloop还提供了2中启动方式(<em>CFRunLoopRun、CFRunLoopRunInMode</em>)</p><p><strong>说明5</strong>：因为NSRunLoopCommonModes是个模式集合，不是一个具体的模式，RunLoop不能在运行在NSRunLoopCommonModes模式；但是可以在添加事件源的时候使用NSRunLoopCommonModes，只要RunLoop运行在NSRunLoopCommonModes中任何一个模式，这个事件源都可以被触发。</p><h5 id="2、取消"><a href="#2、取消" class="headerlink" title="2、取消"></a>2、取消</h5><p><em>了解了启动方式后，取消就很清晰了</em>，主要有三种：</p><ul><li><p>移除掉RunLoop中的所有事件源（timer和source）</p></li><li><p>达到超时（limitDate）条件</p></li><li><p>使用CFRunLoopStop(CFRunLoopRef rl )停止（CFRunloop运行起来或通过NSRunloop的runMode:beforeDate:方法）。</p></li></ul><blockquote><h4 id="六、使用场景"><a href="#六、使用场景" class="headerlink" title="六、使用场景"></a>六、使用场景</h4></blockquote><h4 id="1、NSTimer-CADisplayLink"><a href="#1、NSTimer-CADisplayLink" class="headerlink" title="1、NSTimer/CADisplayLink"></a>1、NSTimer/CADisplayLink</h4><pre><code>NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];//1、timer运行在NSDefaultRunLoopMode下，一旦RunLoop进入其他模式，timer不会工作[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//2、timer运行在NSRunLoopCommonModes集合中任何模式下，timer会工作[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];//3、scheduledTimer返回的定时器，会自动被添加到当前runLoop中，默认是NSDefaultRunLoopModeNSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];//4、创建并启动GCD定时器_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0); //每秒执行// 事件回调dispatch_source_set_event_handler(_timer, ^{    NSLog(@&quot;gcd timer......&quot;);});dispatch_resume(_timer);</code></pre><p><strong>说明1</strong>：一般把NSTimer/CADisplayLink的RunLoop Mode选择NSRunLoopCommonModes集合，防止因列表滑动等导致NSTimer/CADisplayLink不工作；</p><p><strong>说明2</strong>：Timer注册到RunLoop后，如果所属线程中有耗时操作，Timer回调的时间点并不十分准确；CADisplayLink是屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，就可能丢帧，造成界面卡顿。</p><p><strong>说明3</strong>：如果希望比较准的定时器的效果。可以使用GCD的定时器。</p><h4 id="2、-常驻线程"><a href="#2、-常驻线程" class="headerlink" title="2、 常驻线程"></a>2、 常驻线程</h4><pre><code>+ (NSThread *)networkRequestThread {  static NSThread *_networkRequestThread = nil;  static dispatch_once_t oncePredicate;  dispatch_once(&amp;oncePredicate, ^{      _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];      [_networkRequestThread start];  });  return _networkRequestThread;}+ (void)networkRequestThreadEntryPoint:(id)__unused object {  @autoreleasepool {      [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];      NSRunLoop *runLoop = [NSRunLoop currentRunLoop];      //添加端口，防止runloop直接退出      [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];      [runLoop run];  }}</code></pre><p><strong>说明</strong>：AF2.x维护一个常驻线程，用来发起网络请求，并且接受网络请求回调处理；NSURLSession有类似实现；在AF3.x后无常驻线程这部分代码了</p><h4 id="3、子线程执行PerformSelector-或-Timer"><a href="#3、子线程执行PerformSelector-或-Timer" class="headerlink" title="3、子线程执行PerformSelector 或  Timer"></a>3、子线程执行PerformSelector 或  Timer</h4><pre><code>//1、子线程执行performSelectordispatch_async(dispatch_get_global_queue(0, 0), ^{        NSLog(@&quot;befor&quot;);        [self performSelector:@selector(printLog) withObject:nil afterDelay:0];         //创建并启动Runloop，performSelector才有效         [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];        NSLog(@&quot;after&quot;);    });- (void)p_logAction {    NSLog(@&quot;p_logAction&quot;);}//2、子线程执行timer dispatch_async(dispatch_get_global_queue(0, 0), ^{    [NSTimer scheduledTimerWithTimeInterval:0.1 repeats:YES block:^(NSTimer * _Nonnull timer) {        NSLog(@&quot;timer in thread ...&quot;);    }];    //创建并启动Runloop，timer才有效    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];});</code></pre><p><strong>说明1</strong>：<strong>performSelector</strong>原理是：设置一个timer，添加到当前线程Runloop，默认是NSDefaultRunLoopMode；通过NSTimer的 scheduledTimerWithTimeIntervaly创建的定时器，也是自动被添加到当前RunLoop中，默认是NSDefaultRunLoopMode；</p><p><strong>说明2</strong>：<strong>在子线程中</strong>，因为默认没有RunLoop，所以他们<strong>不执行</strong>；想要执行，<strong>需要创建并启动Runloop</strong>。</p><h4 id="4、卡顿检测"><a href="#4、卡顿检测" class="headerlink" title="4、卡顿检测"></a>4、卡顿检测</h4><p><strong>监听主线程(UI线程)之间的耗时，如果发现</strong>kCFRunLoopEntry<strong>(即将进入)和</strong>kCFRunLoopExit<strong>(即将退出)之间耗时过大(大于16.67ms),认为卡顿发生；</strong></p><pre><code>- (void)setupRunloopObserver{    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        CFRunLoopRef runloop = CFRunLoopGetCurrent();        CFRunLoopObserverRef enterObserver;        enterObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(),                                               kCFRunLoopEntry | kCFRunLoopExit,                                               true,                                               0                                               QSRunloopObserverCallBack, NULL);        CFRunLoopAddObserver(runloop, enterObserver, kCFRunLoopCommonModes);        CFRelease(enterObserver);    });}static void QSRunloopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {    switch (activity) {        case kCFRunLoopEntry: {            NSLog(@&quot;enter runloop...&quot;);        }            break;        case kCFRunLoopExit: {            NSLog(@&quot;leave runloop...&quot;);        }            break;        default: break;    }}</code></pre><p><strong>说明</strong>：如果发现卡顿，可以利用PLCrashReporter搜集各个线程的调用堆栈信息，上报到服务器,参考自<a href="http://mrpeak.cn/blog/ui-detect/" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a></p><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><p>想了解更多可参考<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;RunLoop&lt;/strong&gt;：运
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈OC的内存</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/30/iOS08-iOSMemory/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/30/iOS08-iOSMemory/</id>
    <published>2018-01-30T14:43:26.000Z</published>
    <updated>2019-03-24T08:14:40.296Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a>1、内存管理</h5><ul><li><p><strong>引用计数</strong>：每个OC对象都有引用计数(retaincount)、retaincount表明当前有多少个对象<strong>希望该对象存活</strong>；当对象的retaincount &gt; 0,对象存活；当对象的retaincount = 0,对象销毁；</p></li><li><p><strong>创建对象</strong>，retaincount至少为1；<strong>retain操作</strong>，retaincount加1；<strong>release操作</strong>，retaincount减1；<strong>autorelease操作</strong>，清理autorelease pool后，再递减retaincount；为了简化引用计数的管理，ARC应运而生。</p></li><li><p><strong>ARC</strong>（自动引用计数）通过编译器，在合适的地方插入<strong>retain、release和autorelease</strong>等操作；变量的内存管理通过<strong>修饰符(<strong>strong、</strong>weak、__autoreleasing)</strong>指明；以<strong>alloc、new、copy和mutableCopy</strong>方法名开头返回的对象归调用者所有。</p></li><li><p><strong>ARC只管理Objective-C对象的内存</strong>，CoreFoundation对象、CoreGraphics对象、还有C/C++的内存分配还是需要开发者自己管理。</p></li></ul><h5 id="2、内存空间说明"><a href="#2、内存空间说明" class="headerlink" title="2、内存空间说明"></a>2、内存空间说明</h5><p>内存空间主要包括：栈、堆、全局数据区、未初始化数据区 和 代码区</p><ul><li><p><strong>栈</strong>：编译器自动分配释放，存放函数的参数值，局部变量的值等，向低地址扩展，是一块连续的内存的区域<strong>。</strong>栈顶的地址 和 栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将出现栈溢出，发生未知错误。（栈空间较小）。</p></li><li><p><strong>堆</strong>：一般由程序员分配释放，<strong>向高地址扩展</strong>，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的。堆的大小受限于计算机系统中有效的虚拟内存。</p></li><li><p>堆获得的空间比较灵活，也比较大。 但是<strong>栈空间比堆空间响应速度更快，所以一般类似int、NSInteger等占用内存比较小的通常放在栈空间，对象一般放在堆空间</strong>。</p></li><li><p><strong>全局数据区</strong>(静态区)：存放 初始化的全局变量 和 静态变量，全局区的生命周期会伴随整个应用而存在，比较消耗内存</p></li><li><p><strong>未初始化数据区</strong>，亦称BSS区（uninitialized data segment），存入的是<strong>全局未初始化变量</strong></p></li><li><p><strong>代码区</strong>：存放二进制代码</p></li></ul><h5 id="3、Tagged-Pointer特性"><a href="#3、Tagged-Pointer特性" class="headerlink" title="3、Tagged Pointer特性"></a>3、Tagged Pointer特性</h5><ul><li><p>64bit 开始，iOS 引入了<strong>Tagged Pointer</strong>技术，用于优化NSNumber、NSDate、NSString等小对象的存储。</p></li><li><p>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值；</p></li><li><p>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。当指针不够存储数据时，会使用动态分配内存的方式来存储数据。</p></li></ul><h5 id="4、内存泄漏"><a href="#4、内存泄漏" class="headerlink" title="4、内存泄漏"></a>4、内存泄漏</h5><ul><li><p>Objective-C对象分配在内存的<strong>堆区</strong>，这部分内存需要开发者自己回收；如果没有释放，就造成<strong>内存泄漏</strong>；在ARC帮助下，当前内存泄漏最大可能是<strong>循环引用</strong>，导致对象的retaincount &gt; 0,系统无法回收这部分内存。</p></li><li><p>此外，CoreFoundation对象、CoreGraphics对象、还有C/C++的内存分配还是需要开发者自己管理，否则也会发生内存泄漏。</p></li><li><p><strong>循环引用</strong>，简单来说，就是堆内存中对象相互引用，彼此都得不到释放的机会；解决办法无非是使用<strong>弱引用</strong>；比较典型的场景有三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、一般申明代理(delegate)为weak；</span><br><span class="line">2、使用weakSelf和strongSelf处理Block的循环引用；</span><br><span class="line">3、实现NSProxy(虚拟类)的子类，然后在子类中定义weak修饰的target，然后实现消息转发方法，使target处理业务逻辑；一般用于解决NSTimer、CADisplayLink的循环引用。</span><br></pre></td></tr></table></figure></li></ul><h5 id="5、其他内存问题"><a href="#5、其他内存问题" class="headerlink" title="5、其他内存问题"></a>5、其他内存问题</h5><ul><li>高清图片解码、内存暴增，可以将大图裁成小图，然后分别加载显示；</li><li>添加NSNotification监听，记得在dealloc中移除。</li><li>捕获异常时，一定要注意把try块内创建的对象清理干净。</li></ul><h4 id="二、weak相关"><a href="#二、weak相关" class="headerlink" title="二、weak相关"></a>二、weak相关</h4><h5 id="1、weak的实现原理"><a href="#1、weak的实现原理" class="headerlink" title="1、weak的实现原理"></a>1、weak的实现原理</h5><p>Runtime维护一个<strong>weak表</strong>，用于存储执行某个对象的<strong>所有weak指针</strong>；Key是对象地址，Value是weak指针的地址数组；实现分三步：</p><ul><li><p><strong>初始化时</strong>，Runtime会调用<strong>objc_initWeak</strong>函数，初始化一个新的weak指针指向对象的地址；</p></li><li><p><strong>添加引用时</strong>，调用<strong>objc_storeWeak</strong>函数，更新指针指向，创建对应的弱引用表；</p></li><li><p><strong>释放时</strong>，调用<strong>clearDeallocating</strong>函数，根据对象地址获得所有weak指针地址数组，然后遍历这个数组把其中指针置为nil，把这组对应关系从weak表中删除。</p><p><strong>说明</strong>：详细可了解下<a href="http://ios.jobbole.com/89012/" target="_blank" rel="noopener">weak 弱引用的实现方式</a></p></li></ul><h5 id="2、assgin-VS-weak"><a href="#2、assgin-VS-weak" class="headerlink" title="2、assgin VS  weak"></a>2、assgin VS  weak</h5><ul><li><p>assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。 </p></li><li><p>assign也可以用来修饰对象，但是当assign修饰的对象在释放之后，指针没有被nil，如果后续如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。 </p></li><li><p>而weak修饰的对象在释放之后，指针地址会被置为nil。<strong>所以现在一般弱引用就是用weak</strong>。</p></li></ul><h5 id="3、unsafe-unretained-vs-weak"><a href="#3、unsafe-unretained-vs-weak" class="headerlink" title="3、unsafe_unretained  vs weak"></a>3、unsafe_unretained  vs weak</h5><ul><li><p>unsafe_unretained修饰的变量，不属于编译器的内存管理对象</p><p>该修饰符表明<strong>不保留值</strong>，即对其所指向的对象既不强引用，也不弱引用。</p></li><li><p>当我们给被unsafe_unretained修饰的变量赋值时，必须保证赋值对象确实存在，不然程序就会发生崩溃。</p></li><li><p>iOS5之后才有<strong>weak，可以替换</strong>unsafe_unretaine修饰对象，可以参考NotificationCenter在iOS 9之后不需要手动移除监听了。 </p></li></ul><h5 id="4、strong-vs-weak"><a href="#4、strong-vs-weak" class="headerlink" title="4、strong vs  weak"></a>4、strong vs  weak</h5><ul><li><p>strong表示强引用，strong修饰的对象，表示持有这个对象，只有所有对这个对象的强引用都去除时，这个对象才会被释放。</p></li><li><p>weak表示弱引用，表示不持有对象</p></li></ul><h5 id="5、iOS-9-以后通知不再需要手动移除"><a href="#5、iOS-9-以后通知不再需要手动移除" class="headerlink" title="5、iOS 9 以后通知不再需要手动移除"></a>5、iOS 9 以后通知不再需要手动移除</h5><p>​    iOS之前，通知 NSNotification 在注册者被回收时需要手动移除，但是iOS 9以后不需要手动移除，其原因如下：</p><ul><li><p>在iOS 9之前，通知中心持有的是注册者的 <strong>unsafe_unretained</strong> 指针<strong>，在注册者被回收时</strong>若不对通知进行手动移除，则指针指向被回收的内存区域，变为野指针。此时发送通知会造成 crash </p></li><li><p>在iOS 9之后，通知中心持有的是注册者的<strong>weak</strong> 指针，这时即使不对通知进行手动移除，指针也会在注册者被回收后自动置空。因为向空指针发送消息是不会有问题的。</p></li></ul><h4 id="三、Autoreleasepool（自动释放池）"><a href="#三、Autoreleasepool（自动释放池）" class="headerlink" title="三、Autoreleasepool（自动释放池）"></a>三、Autoreleasepool（自动释放池）</h4><h5 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h5><ul><li><p>AutoreleasePool是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。</p></li><li><p>App启动后，苹果在<strong>主线程 RunLoop</strong> 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p></li><li><p>第一个 Observer 监视的事件是 kCFRunLoopEntry(<strong>即将进入Loop</strong>)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p></li><li>第二个 Observer 监视了两个事件： kCFRunLoopBeforeWaiting(<strong>准备进入休眠</strong>) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() <strong>释放旧的池并创建新池</strong>；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来<strong>释放自动释放池</strong>。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li><li>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</li></ul><h5 id="2、Autoreleasepool日常使用"><a href="#2、Autoreleasepool日常使用" class="headerlink" title="2、Autoreleasepool日常使用"></a>2、Autoreleasepool日常使用</h5><ul><li><p>在没有手动添加自动释放池的情况下，autorelease对象<strong>会自动在当前的runloop迭代中加入自动释放池push和pop</strong>，在当前的runloop迭代结束时释放；如果加了，在添加自动释放池结束后，autorelease对象释放；</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autorealsepool&#123;</span><br><span class="line">  //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>合理使用@autorealsepool，能降低内存峰值</strong>；如容器的block版本的枚举器时，内部会自动添加一个autoreleasepool（<em>普通for循环和for in循环中没有</em>）：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">   // 这里被一个局部@autoreleasepool包围着</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>  <strong>说明</strong>：详细可了解下<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></p></li></ul><h4 id="四、Block"><a href="#四、Block" class="headerlink" title="四、Block"></a>四、Block</h4><h5 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h5><ul><li><p>Block在C语言层面就是结构体，结构体存储了<strong>isa（Class对象的指针）</strong>、<strong>函数指针</strong>(invoke指针，指向块的实现)和<strong>捕获的变量列表</strong>等;</p></li><li><p>Block可以分配在<strong>栈上</strong>、<strong>堆上</strong>或<strong>全局</strong>上；<strong>栈上分配的Block</strong>，作用域结束后自动释放；<strong>堆上分配的Block</strong>，和Objective-C对象一样有引用计数了；<strong>全局分配的Block</strong>分配在全局内存中，不会被系统回收，相当于单例；</p></li><li><p>ARC开启时，会自动把栈上的Block拷贝到堆上；</p></li><li><p>Block捕获对象的时候会增加对象的引用计数。</p><p><strong>说明</strong>： <a href="http://blog.csdn.net/hello_hwc/article/details/70210549" target="_blank" rel="noopener">Objective C block背后的黑魔法</a></p></li></ul><h5 id="2、-block和-weak"><a href="#2、-block和-weak" class="headerlink" title="2、__block和__weak"></a>2、<code>__block</code>和<code>__weak</code></h5><ul><li><p><code>__block</code>是用来修饰一个<strong>变量</strong>，这个变量就可以在block中被修改 ，使用__block修饰的变量在block代码快中会被retain（ARC下，MRC下不会retain）</p></li><li><p><code>__weak</code>：使用__weak修饰的变量不会在block代码块中被retain </p></li><li><p>在ARC下，要避免block出现循环引用 __weak typedof(self)weakSelf = self;</p></li></ul><h5 id="3、-block在ARC和MRC下含义"><a href="#3、-block在ARC和MRC下含义" class="headerlink" title="3、__block在ARC和MRC下含义"></a>3、__block在ARC和MRC下含义</h5><ul><li><p>不一样的。 </p></li><li><p>在MRC中<code>__block</code> variable在block中使用是不会retain的；但是ARC中__block則是会Retain的。</p></li></ul><h4 id="五、发现循环引用"><a href="#五、发现循环引用" class="headerlink" title="五、发现循环引用"></a>五、发现循环引用</h4><p><em>有一定开发经验后，开发中可以避免绝大多数的循环引用问题，但是代码多了之后，不能保证代码中没有循环引用问题；</em>这时候就要靠工具了。</p><h5 id="1、Instrument"><a href="#1、Instrument" class="headerlink" title="1、Instrument"></a>1、Instrument</h5><ul><li><p>App内存中有三类：<strong>Abandoned memory</strong>、<strong>Leaked memory</strong>和<strong>Cached memory</strong>；有了ARC帮助管理内存，Leaked memory很少了，Leaks工具效果不大；</p></li><li><p>目前用得比较多的是<strong>Allocation</strong>，利用它观察在App运行中，业务相关类的创建和销毁情况。如进入底层页后退出，底层页相关的Controller、View等是否会销毁。</p></li><li><p>使用<strong>Allocation</strong>，需要一个个场景去跑，比较费时，但是可信度最高，可以作为其他方案补充；人力够的话，可以安排单人跑（<em>感觉有点奢侈</em>）。</p></li></ul><h5 id="2、MLeaksFinder"><a href="#2、MLeaksFinder" class="headerlink" title="2、MLeaksFinder"></a>2、<a href="https://github.com/Tencent/MLeaksFinder" target="_blank" rel="noopener">MLeaksFinder</a></h5><ul><li><p><em>微信阅读推出的内存泄漏检测工具</em>；它通过利用Method Swizzling，<strong>hook</strong> 掉 UIViewController 和 UINavigationController 的dismiss和pop方法，当对象即将释放时，调用<strong>willDealloc</strong>方法; 该方法先用一个弱指针指向 self，并在一小段时间(2秒)后，通过这个弱指针调用<strong>assertNotDealloc</strong>，而<strong>assertNotDealloc</strong>主要是利用<strong>FBRetainCycleDetector</strong>找出<strong>循环引用链</strong>，以此定位循环引用的位置。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;</span><br><span class="line"></span><br><span class="line"> // 白名单机制，消除某些场景的内存泄漏警告...（略）</span><br><span class="line">     __weak id weakSelf = self;</span><br><span class="line">     dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">         __strong id strongSelf = weakSelf;</span><br><span class="line">         [strongSelf assertNotDealloc];</span><br><span class="line">     &#125;);</span><br><span class="line">     return YES;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">- (void)assertNotDealloc &#123;</span><br><span class="line"></span><br><span class="line"> if ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[self parentPtrs]]) &#123;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line">    //检查循环引用链</span><br><span class="line">    [MLeakedObjectProxy addLeakedObject:self];</span><br><span class="line">    //输出日志...（略）</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>有可能误判的情形，</p></li></ul><table><thead><tr><th></th><th>场景</th><th>解决</th></tr></thead><tbody><tr><td>1</td><td><strong>单例和Cache 起来复用的 View 或 ViewController</strong></td><td>可以将willDealloc返回NO，以消除内存泄漏的警告。</td></tr><tr><td>2</td><td><strong>释放不及时的 View 或 ViewController</strong></td><td>可能是网络请求返回慢的原因，可以在网络请求回调的 block 里弱引用 ViewController（比较合理）</td></tr></tbody></table><p>  <strong>说明</strong>：具体可以参考<a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/" target="_blank" rel="noopener">MLeaksFinder：精准 iOS 内存泄露检测工具</a>、<a href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/" target="_blank" rel="noopener">MLeaksFinder 新特性</a></p><h5 id="3、FBMemoryProfiler"><a href="#3、FBMemoryProfiler" class="headerlink" title="3、FBMemoryProfiler"></a>3、<a href="https://github.com/facebook/FBMemoryProfiler" target="_blank" rel="noopener">FBMemoryProfiler</a></h5><ul><li><p>Facebook发布的内存检查工具，FBMemoryProfiler包括<strong>FBAllocationTracker</strong> 、 <strong>FBRetainCycleDetector</strong>和 <strong>UI界面</strong>。</p></li><li><p><strong>FBAllocationTracker</strong>利用Method Swizzling 替换原本的 alloc 方法，记录检测所有的实例分配；而<strong>FBRetainCycleDetector</strong>用来递归遍历对象中的所有强引用的对象，以检测以该对象为根结点的强引用树有没有循环引用。</p></li><li><p><strong>FBMemoryProfiler</strong> 除了可以手动调试之外，它还可以进行自动化检测。 通过它内置的两个组件 FBRetainCycleDetector 和 FBAllocationTracker，直接检测出内存中的循环引用，然后把数据发送到自己的服务器上，可以形成一个自动化检测系统。 </p><p><strong>说明</strong>：详细了解可见<a href="https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/" target="_blank" rel="noopener">automatic-memory-leak-detection-on-ios</a></p></li></ul><h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><ul><li>保持良好编程习惯的同时，搭配工具来及时纠错；推荐<strong>MLeaksFinder + Instrument</strong> 或 <strong>FBMemoryProfiler + Instrument</strong>组合使用。通过MLeaksFinder/FBMemoryProfiler发现后。然后使用Instrument再验证下。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;h5 id=&quot;1、内存管理&quot;&gt;&lt;a href=&quot;#1、内存管理&quot; class=&quot;headerlink&quot; title=&quot;1、内存管
      
    
    </summary>
    
      <category term="iOS基础" scheme="http://buaa0300/nanhuacoder.com/categories/iOS%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈启动优化</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/28/iOS07-launchOPt/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/28/iOS07-launchOPt/</id>
    <published>2018-01-28T09:22:36.000Z</published>
    <updated>2019-03-23T05:06:57.290Z</updated>
    
    <content type="html"><![CDATA[<p>目前iOS优化主要包括三方面：<strong>卡顿优化</strong>、<strong>启动优化</strong>和<strong>瘦身优化</strong>，本文简单说下<strong>启动优化</strong></p><blockquote><h4 id="一、启动时间"><a href="#一、启动时间" class="headerlink" title="一、启动时间"></a>一、启动时间</h4></blockquote><ul><li><p>如果你的App启动超过20s，是时候考虑换个工作了(<em>开个玩笑</em>)；启动优化是<strong>基于当下的业务复杂度和代码复杂度的近似最优处理</strong>。</p></li><li><p><strong>App总启动时间</strong> = t1(main函数之前的加载时间) + t2(main函数之后的加载时间)</p></li><li><p><strong>t1</strong> = 系统dylib(动态链接库)和自身App可执行文件的加载时间</p></li><li><strong>t2</strong> = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</li></ul><blockquote><h4 id="二、main函数之前的优化"><a href="#二、main函数之前的优化" class="headerlink" title="二、main函数之前的优化"></a>二、main函数之前的优化</h4></blockquote><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><ul><li><p><strong>加载过程</strong>：先加载<strong>可执行文件</strong>；然后<strong>加载dyld</strong>(dynamic link editor)动态链接器；最后dyld从可执行文件的依赖开始，递归加载所有依赖的动态链接库。</p></li><li><p><strong>动态链接库</strong>包括：系统的framework、加载OC Runtime的libobjc、系统级别的libSystem、如libdispatch(GCD)和libsystem_blocks(Block)。</p></li><li><p><strong>Apple不允许使用自己的动态库</strong>，否则无法过审；只能选择<strong>静态库</strong>的方式，第三方登录、分享都使用该类方式；链接时会被完整的复制到可执行文件中；</p></li><li><p>相比<strong>静态库</strong>而言，<strong>动态链接库</strong>在程序运行时才记载到内存，不会增加可执行文件的体积，但是会增加加载时间；而<strong>静态库</strong>虽然有利于优化加载速度，但是会增加包的体积。</p></li></ul><h5 id="2、main之前做了什么"><a href="#2、main之前做了什么" class="headerlink" title="2、main之前做了什么"></a>2、main之前做了什么</h5><ul><li><p><strong>load dylibs image</strong>: 读取库静态文件</p></li><li><p><strong>rebase/bind image</strong>: 修复镜像中的资源指针，来指向正确的地址。rebase修复的是镜像内部的资源指针，bind指向的是镜像外部的资源指针；</p></li><li><p><strong>objc setup</strong>:注册objc类；将category的定义插入方法列表；保证selector的唯一；</p></li><li><p><strong>initializers</strong>:动态调整，执行load函数，C+++构造函数属性函数，非基本类型的C++静态全局变量的创建</p></li></ul><h5 id="3、优化思路"><a href="#3、优化思路" class="headerlink" title="3、优化思路"></a>3、优化思路</h5><ul><li><p>减少不必要的framework，因为动态链接比较耗时；</p></li><li><p>检查framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查；</p></li><li><p>合并或者删减一些OC类；删减一些无用的静态变量；删减没有被调用到或者已经废弃的方法；</p></li><li><p>将不必须在+load方法中做的事情延迟到+initialize中；</p></li><li><p>尽量不要用C++虚函数(创建虚函数表有开销)；</p></li></ul><h5 id="4、耗时衡量"><a href="#4、耗时衡量" class="headerlink" title="4、耗时衡量"></a>4、耗时衡量</h5><ul><li><p>Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS 设为 1</p></li><li><p>Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS_DETAILS 设为 1，可以看到更多数据</p></li></ul><blockquote><h4 id="三、main函数之后的优化"><a href="#三、main函数之后的优化" class="headerlink" title="三、main函数之后的优化"></a>三、main函数之后的优化</h4></blockquote><h5 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h5><ul><li>这部分主要是服务初始化、闪屏（广告或引导）和首页UI渲染等工作；</li></ul><h5 id="2、优化思路"><a href="#2、优化思路" class="headerlink" title="2、优化思路"></a>2、优化思路</h5><ul><li><p><strong>视图</strong>：使用代码创建首页视图。</p></li><li><p><strong>服务初始化</strong>：团队间沟通优化业务逻辑，如，延迟某些服务的初始化；合并某些网络请求或减少启动时网络请求个数；</p></li><li><p><strong>其他</strong>：减少NSLog输出，因为其会隐似创建个NSCalender，比较耗时；网络请求和数据读取等耗时操作放在子线程；图片子线程解码等。</p></li></ul><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote><ul><li><p>一个比较靠谱团队，启动这块耗时不会太糟糕，动不动就优化效果显著，要么是太牛逼，要么是团队太坑；做启动优化这块，需要平常心和耐心。</p></li><li><p><strong>main函数之后优化空间比较大，主要在业务上</strong>；所以要先需要熟悉业务，优化之前和各方沟通好，如XX提供的SDK能否延迟初始化，XXX效果设计团队能否接受；XXXX处理会不会给其他团队人员的工作带来困扰….</p></li><li><p>网络上有很多团队分享了启动优化经验，大都是基于自身业务特点的优化总结；想系统了解，还是推荐看看<a href="https://techblog.toutiao.com/2017/01/17/iosspeed/" target="_blank" rel="noopener">今日头条iOS客户端启动速度优化</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前iOS优化主要包括三方面：&lt;strong&gt;卡顿优化&lt;/strong&gt;、&lt;strong&gt;启动优化&lt;/strong&gt;和&lt;strong&gt;瘦身优化&lt;/strong&gt;，本文简单说下&lt;strong&gt;启动优化&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、启
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈瘦身优化</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/27/iOS06-app-thinning/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/27/iOS06-app-thinning/</id>
    <published>2018-01-27T09:39:47.000Z</published>
    <updated>2019-03-23T05:06:48.864Z</updated>
    
    <content type="html"><![CDATA[<p>目前iOS优化主要包括三方面：<strong>卡顿优化</strong>、<strong>启动优化</strong>和<strong>瘦身优化</strong>，本文简单说下<strong>瘦身优化</strong>。</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><h5 id="1、App-Thinning"><a href="#1、App-Thinning" class="headerlink" title="1、App Thinning"></a>1、App Thinning</h5><p>在iOS 9时候，苹果推出的App Thinning三件套：<strong>App Slicing</strong>、<strong>On Demand Resouces</strong>、<strong>Bitcode</strong>；</p><table><thead><tr><th>App Thinning</th><th>理想</th><th>现实</th></tr></thead><tbody><tr><td><strong>App Slicing</strong></td><td>将App Bundle资源根据不同的设备特性分为不同的版本。对于图片资源，会根据设备所需图片分辨率不同分发给对应设备所需对应的图片资源。</td><td>主要是图片资源的Slicing，我们有自己的方案，没有采用</td></tr><tr><td><strong>On Demand Resources</strong></td><td>App的资源只有要使用时才下载，如果其他资源需要空间这些资源可以被移除</td><td>更适合游戏类App，项目没有使用</td></tr><tr><td><strong>Bitcode</strong></td><td>Bitcode可以作为中间产物一起提交AppStore。包含Bitcode配置的程序将会在AppStore上被编译和链接。Bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到AppStore上</td><td>使用BitCode的要求所有代码都支持BitCode，改动项目较大，没有使用</td></tr></tbody></table><p><strong>说明</strong>：我没有使用App Thinning，App Thinning真正带来的效果如何，不好评估。</p><h5 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h5><ul><li><p>安装包主要组成：<strong>二进制代码文件</strong>、<strong>资源文件</strong>和<strong>配置文件</strong>；</p></li><li><p>主要针对<strong>二进制代码文件</strong>和<strong>资源文件</strong>的优化；其中资源文件中最多的是图片文件。</p><p>  <strong>说明</strong>：简单来说，瘦身优化就是为了<strong>减少图片体积</strong>、<strong>减少二进制代码文件</strong>。</p></li></ul><blockquote><h4 id="二、图片体积优化"><a href="#二、图片体积优化" class="headerlink" title="二、图片体积优化"></a>二、图片体积优化</h4></blockquote><h5 id="1、常规手段"><a href="#1、常规手段" class="headerlink" title="1、常规手段"></a>1、常规手段</h5><ul><li><p><strong>及时清理旧的图片资源</strong>。使用类似<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a> 清理旧的图片文件。</p></li><li><p>引入项目中的图片记得<strong>压缩</strong>。</p><p><strong>说明</strong>：LSUnusedResources的思路是，先获取图片文件(imageset, jpg, png, gif)集合A，然后搜索代码文件中所有字符串名称得到B，然后从A集合中排除集合B就得到未使用的图片资源。</p></li></ul><h5 id="2、方案替换"><a href="#2、方案替换" class="headerlink" title="2、方案替换"></a>2、方案替换</h5><ul><li><p><strong>PNG切图的替换方案</strong>，如<strong>PDF矢量图</strong>来代替大部分简单的png切图；然后在代码中自己解码并展示出来，一套PDF矢量图可以等效大部分2x和3x的png图片；如<strong>iconfont</strong>代替项目中纯色小图标，也省去很多@2x和@3x的图片切图。</p><p><strong>说明</strong>：PNG切图不可能被完全替换，在表现颜色丰富图片时候，PNG效果很不错。</p></li><li><p>详见<a href="https://buaa0300.github.io/2018/01/13/imageOptimize/" target="_blank" rel="noopener">浅谈iOS图片优化</a></p></li></ul><h5 id="3、图片文件去重"><a href="#3、图片文件去重" class="headerlink" title="3、图片文件去重"></a>3、图片文件去重</h5><ul><li><p><strong>重复图片</strong>文件遇到的情况不多(重复引入)，但是发现难度大。提供一种思路：</p><pre><code>1）遍历图片文件，计算每个文件的MD5值，然后以MD5值为key，文件路径存入key对应的数组；2）遍历字典values，将value的数组大小大于1的路径输出，这样就找到重复图片的路径了。</code></pre><p>  <strong>说明</strong>：也可以使用<strong>感知哈希算法</strong>去计算图片见的<strong>海明距离</strong>，找出相似图片，看看这些图片是否可以被整合或清理。</p></li></ul><blockquote><h4 id="三、二进制代码文件优化"><a href="#三、二进制代码文件优化" class="headerlink" title="三、二进制代码文件优化"></a>三、二进制代码文件优化</h4></blockquote><h5 id="1、常规手段-1"><a href="#1、常规手段-1" class="headerlink" title="1、常规手段"></a>1、常规手段</h5><ul><li><p><strong>及时下线不需要的功能</strong>，如完成使命的ABTest代码、被产品抛弃的功能代码等。</p></li><li><p><strong>功能合并</strong>，相似功能的代码，只需维护一份就可以了。如定制通用UI组件，大家可以有类似需求，可以给通用UI组件的开发提，没必要自己单独实现。</p></li><li><p><strong>保持好的开发习惯</strong>；如 同质第三方库(如AFNetworking和ASIHttpRequest,)选一个就可以了；不要因为引入一个功能，引入很多类文件。</p></li><li><p><strong>建议预警机制</strong>，监控每个版本的体积大小，体积图片突然变大，要去找原因。</p></li></ul><h5 id="2、其他"><a href="#2、其他" class="headerlink" title="2、其他"></a>2、其他</h5><ul><li>使用工具分析冗余的代码，如AppCode工具，<strong>其分析结果只是作为参考</strong>。</li></ul><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote><ul><li><p>保持良好的开发习惯，有一定的意识，一般不会把App体积弄得很离谱；</p></li><li><p>如果是之前的技术债造成的，也不用担心，先从图片优化开发(<strong>见效显著</strong>)，二进制方面优化慢慢来，熟悉代码后再动手吧。</p></li><li><p>头条的<a href="https://techblog.toutiao.com/2016/12/27/iphone/" target="_blank" rel="noopener">iPhone安装包的优化</a>值得学习了解下。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前iOS优化主要包括三方面：&lt;strong&gt;卡顿优化&lt;/strong&gt;、&lt;strong&gt;启动优化&lt;/strong&gt;和&lt;strong&gt;瘦身优化&lt;/strong&gt;，本文简单说下&lt;strong&gt;瘦身优化&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈卡顿优化</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/26/iOS05-kadunyouhua/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/26/iOS05-kadunyouhua/</id>
    <published>2018-01-26T15:23:05.000Z</published>
    <updated>2019-03-23T05:06:41.878Z</updated>
    
    <content type="html"><![CDATA[<p>目前iOS优化主要包括三方面：<strong>卡顿优化</strong>、<strong>启动优化</strong>和<strong>瘦身优化</strong>，本文简单说下<strong>卡顿优化</strong>。</p><blockquote><h4 id="一、卡顿"><a href="#一、卡顿" class="headerlink" title="一、卡顿"></a>一、卡顿</h4></blockquote><h5 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h5><ul><li><p>iOS设备使用双缓存，以<strong>60HZ</strong>的频率刷新屏幕，这就意味着，在<strong>1/60s(16.67ms)</strong>内要将完成<strong>下一帧</strong>的图片的绘制，并存在缓存区中；</p></li><li><p>在这1/60s(16.67ms)内，<strong>CPU要计算显示内容</strong>，然后将这些内容交给<strong>GPU去变换、合成和渲染</strong>，GPU把渲染后的内容提交到帧缓存区，等待更新信号；</p></li><li><p>如果在1/60s(16.67ms)不能完成这些工作，这帧内容就会被丢弃，显示屏还保存之前的内容，也就是常说的<strong>丢帧</strong>了，这也是<strong>卡顿的原因</strong>。</p></li><li><p>简单说，卡顿优化就是为了，<strong>优化CPU和GPU的使用情况</strong>。</p></li></ul><h5 id="2、卡顿监控"><a href="#2、卡顿监控" class="headerlink" title="2、卡顿监控"></a>2、卡顿监控</h5><ul><li><p><strong>主线程卡顿监控</strong>。通过子线程监测主线程的 RunLoop，判断两个状态区域之间的耗时是否达到一定阈值，发现卡顿还可以抓取堆栈信息，上报到服务器，便于准确定位和优化。</p></li><li><p><strong>FPS监控</strong>，利用CADisplayLink(和屏幕刷新频率相同)，过记录两次刷新时间间隔，计算出当前的 FPS。</p><p><strong>说明</strong>：卡顿监控很有意义，要么自己做，要么用第三方的，如腾讯的bugly。</p><p>参考：<a href="http://mrpeak.cn/blog/ui-detect/" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a></p></li></ul><blockquote><h4 id="二、CPU方面优化"><a href="#二、CPU方面优化" class="headerlink" title="二、CPU方面优化"></a>二、CPU方面优化</h4></blockquote><p>CPU做计算显示的内容，主要包括：视图创建、视图布局、图片解码、文本绘制、图像绘制等。</p><h5 id="1、视图创建"><a href="#1、视图创建" class="headerlink" title="1、视图创建"></a>1、视图创建</h5><ul><li><p><strong>对象复用</strong>，复用对象的代价比创建新对象的成本要低；比较典型的是：<strong>UITableViewCell对象的复用</strong>，需要UITableViewCell对象，先从缓存池取，如果取不到，才去创建新对象；</p></li><li><p><strong>选择轻量级对象</strong>：不响应触摸事件的视图，不使用UIView，优先使用CAShapeLayer(硬件加速、渲染快）。</p></li><li><p><strong>数据对象的缓存</strong>：比较典型的是，解码图像的缓存和cell高度的缓存；前者避免图片重复解码，后者避免Cell高度重复计算。</p></li></ul><h5 id="2、视图布局"><a href="#2、视图布局" class="headerlink" title="2、视图布局"></a>2、视图布局</h5><ul><li><p>不使用Autolayout（布局计算在主线程），视图复杂后，性能不佳；可以使用代码创建View，使用frame布局；要注意<strong>frame值要取整</strong>，避免像素不对齐；</p></li><li><p>尽量减少视图的数量、层级数量、层级调整、视图添加和删除操作；</p></li><li><p>尽量减少不必要的属性修改，如CALayer相关的属性(如frame、bounds、transform、center等），修改会引起隐式动画。</p></li></ul><h5 id="3、图片解码"><a href="#3、图片解码" class="headerlink" title="3、图片解码"></a>3、图片解码</h5><ul><li>子线程解码图片，然后在主线程展示解码后的位图（位图结果记得缓存）。</li></ul><h5 id="4、文本绘制"><a href="#4、文本绘制" class="headerlink" title="4、文本绘制"></a>4、文本绘制</h5><ul><li><strong>文本的宽高计算和绘制</strong>会占用资源，可以在子线程计算和绘制，然后在主线程显示；这适用于大量文本显示的处理，如果只是2-3行文本显示，没必要选择这么做。</li></ul><h5 id="5、图像绘制"><a href="#5、图像绘制" class="headerlink" title="5、图像绘制"></a>5、图像绘制</h5><ul><li><p>图片的绘制可以放到子线程中做，因为CG绘制是线程安全的；将图片绘制到画布上，然后将图片显示到视图中。</p><p><strong>总结</strong>：因为<strong>主线程占用CPU高、子线程占用CPU低</strong>；优化时，把不是必须要在主线程中做的事情 放在子线程中做，但是要防止线程爆炸，参考<a href="https://www.jianshu.com/p/5d51a367ed62" target="_blank" rel="noopener">GCD小结之控制最大并发数</a>。</p></li></ul><blockquote><h4 id="三、GPU方面优化"><a href="#三、GPU方面优化" class="headerlink" title="三、GPU方面优化"></a>三、GPU方面优化</h4></blockquote><p>GPU接收提交的纹理(Texture) 和顶点数据信息，应用变换(transform)、混合并渲染等，然后输出到屏幕上。</p><h5 id="1、纹理的渲染"><a href="#1、纹理的渲染" class="headerlink" title="1、纹理的渲染"></a>1、纹理的渲染</h5><ul><li><p>GPU的消耗主要在：所有Bitmap由内存提交到显存、绑定为GPU Texture；GPU的调整；渲染Texture等。尽量避免短时间显示大量图片，否则会造成CPU使用率低，而GPU使用率飙升；可以合成多张图片，做一张显示。</p></li><li><p>尽量避免图片过大，超过GPU的最大纹理尺寸，需要CPU进行预处理，带来CPU和GPU的格外消耗。在网络环境中，遇到下载特大高清图时，SDWebImage的处理是，<strong>将大的原图裁剪成指定大小的小图，然后拼成大图</strong> 思路类似异步绘制内容的图层CATiledLayer，不加载全部图片，而是将大图分解成小图片，然后再载入显示。</p></li></ul><h5 id="2、视图混合"><a href="#2、视图混合" class="headerlink" title="2、视图混合"></a>2、视图混合</h5><ul><li><p><strong>尽量减少视图的数量和层级</strong>，多视图叠加在一起显示时，GPU需要混合计算，视图的数量和层级越深，GPU的消耗越大；</p></li><li><p>视图尽量<strong>不使用透明的背景色</strong>，避免像素混合计算(视图默认不透明 opaque=YES)；尽量<strong>使用不透明的图片</strong>，避免像素混合计算</p></li><li><p>UILabel显示中文时，记得<strong>masksToBounds = YES</strong>，避免混合计算</p></li></ul><h5 id="3、离屏渲染"><a href="#3、离屏渲染" class="headerlink" title="3、离屏渲染"></a>3、离屏渲染</h5><ul><li><p>GPU屏幕渲染分为当前<strong>屏幕渲染</strong>(On-Screen Rendering)和<strong>离屏渲染</strong>(Off-Screen Rendering)，<strong>离屏渲染</strong>需要在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作，其中涉及到的<strong>创建新缓冲区</strong>、<strong>上下文切换</strong>都很消耗GPU资源。</p></li><li><p>容易触发离屏渲染最多的四个场景，<strong>圆角处理</strong>（RoundCorner）、<strong>阴影处理</strong>(Shadow)、<strong>遮罩</strong>(Mask)和Group Opacity（组不透明）；</p></li><li><p><strong>圆角处理</strong>可以采用绘制方式，可以参考<a href="https://www.jianshu.com/p/a38a7c7bccbb" target="_blank" rel="noopener">网络图片的优化显示</a>；<strong>阴影处理</strong>可以通过设置shadowPath来避免；Mask没啥好办法; GroupOpacity处理是<strong>关闭layer的allowsGroupOpacity 属性</strong>；</p></li><li><p><strong>离屏渲染不可避免情况下</strong>，设置<strong>shouldRasterize=YES</strong>（启动光栅化)，可以将layer光栅化为Bitmap, layer的阴影等效果也会被缓存到Bitmap中，减少离屏渲染次数，减少GPU消耗。</p></li></ul><p><strong>说明</strong>：还有种<strong>CPU渲染</strong>的说法，重写了drawRect方法，或使用Core Graphics绘制都会触发；虽然其性能可能还不如GPU的离屏渲染，但是可以在子线程中做CPU渲染，然后在主线程显示。</p><h5 id="4、像素不对齐"><a href="#4、像素不对齐" class="headerlink" title="4、像素不对齐"></a>4、像素不对齐</h5><ul><li>图片显示前，在子线程中可以按目标显示大小裁剪，使图片符合展示大小，避免拉伸缩放(像素不对齐)。</li></ul><blockquote><h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4></blockquote><ul><li><p>优化工作视具体业务来做，没必要过早优化；</p></li><li><p>如果没做过优化方面工作的同学，可以仔细阅读<strong>ibireme</strong>的<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a>，后续很多团队的分享经验都没有跳出ibireme的框架。</p></li><li><p>iOS图片优化是个值得注意的点，不管是在卡顿优化、还是在App瘦身，可以参考我的一点见解<a href="https://buaa0300.github.io/2018/01/13/imageOptimize/" target="_blank" rel="noopener">浅谈iOS图片优化</a>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前iOS优化主要包括三方面：&lt;strong&gt;卡顿优化&lt;/strong&gt;、&lt;strong&gt;启动优化&lt;/strong&gt;和&lt;strong&gt;瘦身优化&lt;/strong&gt;，本文简单说下&lt;strong&gt;卡顿优化&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>组件化学习笔记</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/21/iOS13-zujianhua/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/21/iOS13-zujianhua/</id>
    <published>2018-01-21T13:29:49.000Z</published>
    <updated>2019-03-23T05:07:36.803Z</updated>
    
    <content type="html"><![CDATA[<p>没有做过组件化，先自行了解下</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><h5 id="1、为什么用组件化"><a href="#1、为什么用组件化" class="headerlink" title="1、为什么用组件化"></a>1、为什么用组件化</h5><ul><li><p><strong>业务快速发展、复杂的业务场景、团队的快速扩展等</strong>带来的变革诉求，希望通过<strong>组件化</strong>来提高团队的协作能力、减低开发成本，提高开发质量。</p></li><li><p>组件化直接效果：代码解耦，功能模块化；代码的复用性高；代码管理更加科学。</p></li><li><p>从<strong>蘑菇街</strong>(<a href="https://www.jianshu.com/p/cdf94a963c27" target="_blank" rel="noopener">蘑菇街 App 的组件化之路</a>)、<strong>支付宝(<a href="http://www.sohu.com/a/129493438_536622" target="_blank" rel="noopener">从支付宝红包揭秘亿级APP的移动开发</a>)</strong>等团队公开的信息来看：业务的增加、开发团队的扩张、快速迭代的要求，催生组件化方案(<em>可能有更好的架构方案</em>)快速落地。</p></li></ul><h5 id="2、为什么还不用组件化"><a href="#2、为什么还不用组件化" class="headerlink" title="2、为什么还不用组件化"></a>2、为什么还不用组件化</h5><ul><li><p>虽然组件化的风吹了好几年了，但是依然很多团队没有使用组件化方案；主要还是开发资源有限，组件化的改造成本较高，收益相对不大。</p></li><li><p>蘑菇街和支付宝等团队实现组件化方案，一是业务发展的必然选择；二是其技术沉淀深，能为自己和兄弟团队打造出质量上乘的组件化服务。</p></li></ul><h5 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h5><ul><li>组件化是趋势，是大中型App团队的选择。</li></ul><blockquote><h4 id="二、组件化四要素"><a href="#二、组件化四要素" class="headerlink" title="二、组件化四要素"></a>二、组件化四要素</h4></blockquote><p>完成组件化，先考虑四要素。</p><h5 id="1、组件拆分"><a href="#1、组件拆分" class="headerlink" title="1、组件拆分"></a>1、组件拆分</h5><ul><li><p>首先需要对原有的<strong>基础模块</strong>，如网络模块、存储模块、网络图片加载模块、日志上报模块从原有代码中独立出来，用Cocoapods或Submodule管理起来。（<em>这部分相对简单</em>）</p></li><li><p><strong>业务模块</strong>的拆分比较麻烦，这部分代码的规范性不强，文件之间的引用乱且杂，且代码阅读性较差，是个坑多的地方。</p></li><li><p>除了业务模块之外，还有一块代码是<strong>重灾区</strong>，是<strong>AppDelegate的初始化部分</strong>；这里包含太多的逻辑，如SDK和基础模块的初始化，参数设置，注册通知，网络请求等等。我的想法是：将不同的工作分配到不同的Category中，使其职责明确清晰。</p></li></ul><h5 id="2、组件间通信"><a href="#2、组件间通信" class="headerlink" title="2、组件间通信"></a>2、组件间通信</h5><p>组件之前的通信，更多是指业务组件之间的通信吧。目前蘑菇街团队公开的方案是：<strong>URLRouter</strong>、<strong>Protocol Class Binding</strong>这两类方案。</p><h5 id="2-1-URLRouter"><a href="#2-1-URLRouter" class="headerlink" title="2-1 URLRouter"></a>2-1 URLRouter</h5><ul><li><p><strong>简介</strong>：蘑菇街团队实现<a href="https://github.com/meili/MGJRouter" target="_blank" rel="noopener">MGJRouter</a>库，可以根据URL处理执行对应的Block；其核心在于，先注册URL 和 <strong>服务Block</strong> &amp; <strong>参数字典</strong>的对应关系（<em>保存在router字典中</em>），然后利用URL找到对应的Block，将参数字典交给Block，唤起对应的服务。</p><pre><code>  // 注册 [MGJRouter registerURLPattern:@&quot;mgj://foo/bar&quot; toHandler:^(NSDictionary *routerParameters) {[self appendLog:[NSString stringWithFormat:@&quot;routerParameters:%@&quot;, routerParameters]]; }]; //传参 [MGJRouter openURL:@&quot;mgj://foo/bar&quot; withUserInfo:@{@&quot;param1&quot;:@&quot;hello world&quot;} completion:nil]; //同步获取object NSNumber *orderCount = [MGJRouter objectForURL:@&quot;mgj://cart/ordercount&quot;]</code></pre></li><li><p><strong>优势</strong>：解耦方便；各个组件依赖MGJRouter就可以；打破组件间的相关依赖关系；</p></li><li><p><strong>不足</strong>：组件本身依赖中间件，但是分散注册又使得<strong>耦合较多</strong>。<br>需要专门维护URL(<em>蘑菇街使用后台维护，自动生成URL短链的方式</em>)；</p></li></ul><h5 id="2-2-Protocol-Class-Binding（协议和类绑定"><a href="#2-2-Protocol-Class-Binding（协议和类绑定" class="headerlink" title="2-2 Protocol Class Binding（协议和类绑定)"></a>2-2 Protocol Class Binding（协议和类绑定)</h5><ul><li><p><strong>简介</strong>：可以看做是蘑菇街团队URLRouter的升级方案。其核心在于，为组件定义Protocol，Protocol指定返回的数据，然后在组件中新建Class实现Protocol，如此将Protocol和Class关联起来。</p><pre><code> //以购物车组件为例//1、组件定义MGJCart，执行返回订单数方法 @protocol MGJCart &lt;NSObject&gt; + (NSInteger)orderCount;   @end//2、MGJCartImpl 实现MGJCart ，实现略 //3、关联[ModuleManager registerClass:MGJCartImpl forProtocol:@protocol(MGJCart)]，//4、获取MGJCartImpl，接下来可以访问到参数了[ModuleManager classForProtocol:@protocol(MGJCart)]</code></pre></li><li><p><strong>优势</strong>：把公共的协议统一放到同一文件中，组件依赖该文件即可。</p></li></ul><h5 id="3、组件的单元测试"><a href="#3、组件的单元测试" class="headerlink" title="3、组件的单元测试"></a>3、组件的单元测试</h5><p>每一个组件都需要提供单元测试，保证代码质量。</p><p><em>实践后，再来补充</em></p><h5 id="4、组件开发、集成、发版"><a href="#4、组件开发、集成、发版" class="headerlink" title="4、组件开发、集成、发版"></a>4、组件开发、集成、发版</h5><p><em>实践后，再来补充</em></p><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote><ul><li><p>个人认为，<strong>组件化</strong>是<strong>业务、团队快速扩张</strong>下的新的<strong>合作分工方式</strong>；</p></li><li><p>虽然我们团队还没有这类变革诉求，但是我们能够要在各个垂直、细分领域打开局面，形成自己的<strong>产品矩阵</strong>，组件化方案或类组件化方案是必须要有人去踩坑的。</p><p>参考文章：<a href="https://www.jianshu.com/p/48fbcbb36c75" target="_blank" rel="noopener">iOS App组件化开发实践</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;没有做过组件化，先自行了解下&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h5 id=&quot;1、为什么用组件
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>速览FLAnimatedImage库笔记</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/14/iOS14-readFLAnimatedImage/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/14/iOS14-readFLAnimatedImage/</id>
    <published>2018-01-14T04:05:17.000Z</published>
    <updated>2019-03-23T05:07:42.054Z</updated>
    
    <content type="html"><![CDATA[<p>FLAnimatedImage库很不错，分享下我的学习笔记</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><ul><li><p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>处理网络GIF播放，是在<a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>基础上做的。</p></li><li><p><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>就主要的类是：<strong>FLAnimatedImage类</strong>和<strong>FLAnimatedImageView类</strong>。<strong>FLAnimatedImage</strong>看做个生产者，负责将GIF图片转换成一帧帧图片，提供给<strong>FLAnimatedImageView</strong>；后者可以看做是消费者，将一帧帧图片刷新显示到屏幕中。</p></li><li><p><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>中涉及一些<strong>线程安全</strong>、<strong>weakProxy</strong>、<strong>内存警告处理</strong>还是很值得借鉴的。</p></li></ul><blockquote><h4 id="二、FLAnimatedImage-类"><a href="#二、FLAnimatedImage-类" class="headerlink" title="二、FLAnimatedImage 类"></a>二、FLAnimatedImage 类</h4></blockquote><p>重要的两个方法，分别是<strong>initWithAnimatedGIFData:方法</strong> 和  <strong>imageLazilyCachedAtIndex:方法</strong></p><h5 id="1、initWithAnimatedGIFData-方法"><a href="#1、initWithAnimatedGIFData-方法" class="headerlink" title="1、initWithAnimatedGIFData: 方法"></a>1、initWithAnimatedGIFData: 方法</h5><ul><li><p>其一、获取<strong>GIF图片的信息</strong>，包括图片大小、图片帧数、首帧图片、每帧图片的属性信息(播放时间)、循环播放次数，最大缓存帧个数等。其中<strong>最大缓存帧个数</strong>是根据图片大小获得 或者 手动指定。</p></li><li><p>其二、设置个弱代理(weakProxy)，用来<strong>防止循环引用</strong>用的。</p></li><li><p>其三、将自己添加<strong>allAnimatedImagesWeak</strong>对象中（添加操作使用@synchronized保证线程安全），这是一个NSHashTable对象，当哈希表中的FLAnimatedImage对象的引用计数是0时，表中会清除该对象。</p><p><strong>说明</strong>：线程同步中，一说<strong>同步锁</strong>，很多人直觉反应，性能最差，不用；但是FLAnimatedImage库和SDWebImage都在用，应该是其<strong>使用方便</strong>所致；其本身实现很有意思，利用对象的内存地址去获取互斥锁；还添加了异常处理，如果同步某对象抛出异常时，还会释放掉锁。</p></li></ul><h5 id="2、imageLazilyCachedAtIndex-方法"><a href="#2、imageLazilyCachedAtIndex-方法" class="headerlink" title="2、imageLazilyCachedAtIndex:方法"></a>2、imageLazilyCachedAtIndex:方法</h5><ul><li><p>通过<strong>imageLazilyCachedAtIndex:方法</strong>将帧每一帧图片给FLAnimatedImageView对象展示。</p></li><li><p>根据<strong>当前的帧号</strong>(index)和<strong>当前缓存帧数</strong>(frameCacheSizeCurrent)获取接下来需要缓存的帧图片，并异步绘制出位图，并保存在内存缓存中。</p><p><strong>说明</strong>：都是提前绘制后面需要展示的图片，第一帧图片在init方法时就获得了。</p></li></ul><h5 id="3、内存警告的处理"><a href="#3、内存警告的处理" class="headerlink" title="3、内存警告的处理"></a>3、内存警告的处理</h5><ul><li><p>位图比较大，将位图缓存在内存中，即使FLAnimatedImage做了优化，当时GIF较大，或多张GIF同时播放，内存的压力会很大，很大概率收到内存警告。</p></li><li><p><strong>allAnimatedImagesWeak</strong>保存所有的FLAnimatedImage对象，收到内存警告时，通知所有FLAnimatedImage对象，当前只允许缓存一帧图片；如果接下来没有新的内存警告，慢慢恢复到定义的缓存的图片帧数；但是如果内存警告次数超过三次，以后只能缓存一帧图片。</p></li><li><p>在内存警告处理中，使用了些<strong>延迟执行</strong>的方法，防止循环引用，使用了弱代理(weakProxy)。</p></li><li><p>weakProxy是FLWeakProxy 对象；FLWeakProxy是NSProxy类子类，持有一个 weak 对象的代理，利用消息转发机制将消息的处理交给weak 对象；用来避免循环引用的一种方法，具体可以看我之前写的<a href="https://www.jianshu.com/p/5068b6f02238" target="_blank" rel="noopener">解决NSTimer/CADisplayLink的循环引用</a>。</p></li></ul><blockquote><h4 id="三、FLAnimatedImageView"><a href="#三、FLAnimatedImageView" class="headerlink" title="三、FLAnimatedImageView"></a>三、FLAnimatedImageView</h4></blockquote><h5 id="1、CADispalyLink"><a href="#1、CADispalyLink" class="headerlink" title="1、CADispalyLink"></a>1、CADispalyLink</h5><ul><li><p>CADispalyLink是个和屏幕刷新率相同的定时器，将帧图片刷新显示在屏幕上。</p></li><li><p>使用FLWeakProxy这类弱引用代理，打破循环引用；</p></li><li><p>多个处理器情况下，CADispalyLink对象默认以NSRunLoopCommonModes添加到Runloop上，避免因为列表滑动不刷新显示。</p></li><li><p>CADispalyLink的刷新时间是：每帧图片播放时间的最大公约数；因为不能保证每帧图片的播放时间是一样的，取他们的最大公约数，使得每一帧都尽可能获得其播放时间。当然也可以暴力使用平均停留时间作为CADispalyLink的刷新时间。</p></li></ul><blockquote><h4 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h4></blockquote><ul><li><p>这是之前阅读FLAnimatedImage库的笔记整理，一是本着学习的目的，二是为了评估 <strong>在列表页缩放裁剪播放n张GIF图的需求</strong>的可行性；</p></li><li><p>将<strong>GIF图片的裁剪和合成小GIF图</strong>的重任交给客户端，本身就很冒险；裁剪过程中，GIF图片的帧数多，GIF图片多，对内存的挑战是很大的，在列表中下发小的GIF图播放比较好（后台表示压力大）。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FLAnimatedImage库很不错，分享下我的学习笔记&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>代码自动生成笔记</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/13/iOS12-generateCode/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/13/iOS12-generateCode/</id>
    <published>2018-01-13T12:05:09.000Z</published>
    <updated>2019-03-23T05:07:30.419Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，使用脚本语言(Ruby或Python)生成些Objective-C代码，提高代码生产力。</p><blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><ul><li><p>使用脚本生成简单的Objective-C代码，这件工作并不复杂；</p></li><li><p>先介绍<strong>Xcode自动运行脚本相关设置</strong>和 <strong>自动添加类文件到项目</strong>；</p></li><li><p>最后介绍一个使用Ruby生成Objective-C代码的<strong>实例</strong>；</p></li></ul><blockquote><h4 id="二、Xcode自动运行脚本"><a href="#二、Xcode自动运行脚本" class="headerlink" title="二、Xcode自动运行脚本"></a>二、Xcode自动运行脚本</h4></blockquote><p><strong>目标</strong>：在运行项目时自动运行脚本。考虑到可能在项目中引入比较多的脚本，建议在项目的根路径下新建一个存放脚本的文件夹；在这个文件夹中，集中管理脚本。推荐两个比较常见的设置自动运行脚本的办法。</p><h5 id="方法1：External-Build-System-外部编译系统"><a href="#方法1：External-Build-System-外部编译系统" class="headerlink" title="方法1：External Build System(外部编译系统)"></a>方法1：External Build System(外部编译系统)</h5><p>具体步骤分为以下 5 步</p><h6 id="1）新建External-Build-System"><a href="#1）新建External-Build-System" class="headerlink" title="1）新建External Build System"></a>1）新建External Build System</h6><p>在工程下添加一个<strong>target</strong>：选择Cross-platform &gt; Other &gt; External Build System，取名为CodeGenerator。</p><h6 id="2）新建shell脚本文件"><a href="#2）新建shell脚本文件" class="headerlink" title="2）新建shell脚本文件"></a>2）新建shell脚本文件</h6><p>在工程的根路径下新建一个<strong>ToolScripts</strong>文件夹，新建脚本文件，名为start.sh</p><h6 id="3）设置CodeGenerator"><a href="#3）设置CodeGenerator" class="headerlink" title="3）设置CodeGenerator"></a>3）设置CodeGenerator</h6><p>选择Targets &gt; CodeGenerator &gt;Info &gt; External Build Tool Configuration，<strong>Build Tools</strong>中填入start.sh所在的路径；<strong>Directory</strong>中填入存放所有脚本的文件夹，本例中是ToolScripts所在的位置。如果编译失败，请检查这里Directory的设置，修改成对应的位置。</p><h6 id="4）添加运行依赖"><a href="#4）添加运行依赖" class="headerlink" title="4）添加运行依赖"></a>4）添加运行依赖</h6><p>选择Targets &gt; QSRunScriptDemo &gt; Build Phase &gt; Target Dependencies,添加运行依赖。</p><h6 id="5）编译运行"><a href="#5）编译运行" class="headerlink" title="5）编译运行"></a>5）编译运行</h6><p>编译运行，选择Show the report navigator -&gt; build，可以看到对应的日志输出。</p><h5 id="方法2：项目中直接添加脚本执行"><a href="#方法2：项目中直接添加脚本执行" class="headerlink" title="方法2：项目中直接添加脚本执行"></a>方法2：项目中直接添加脚本执行</h5><p>具体步骤分为以下 4 步</p><h6 id="1）新建shell脚本文件"><a href="#1）新建shell脚本文件" class="headerlink" title="1）新建shell脚本文件"></a>1）新建shell脚本文件</h6><p>在工程的根路径下新建一个<strong>ToolScripts</strong>文件夹，新建脚本文件，名为start.sh，这步骤和方法1一样。</p><h6 id="2）添加Run-Script"><a href="#2）添加Run-Script" class="headerlink" title="2）添加Run Script"></a>2）添加Run Script</h6><p>选择Targets &gt; QSRunScriptDemo &gt; Build Phase中添加 New Run Script Phase 即可。</p><h6 id="3）设置Run-Script"><a href="#3）设置Run-Script" class="headerlink" title="3）设置Run Script"></a>3）设置Run Script</h6><p>在Run Script中设置执行start.sh命令即可。</p><h6 id="4）编译运行"><a href="#4）编译运行" class="headerlink" title="4）编译运行"></a>4）编译运行</h6><p>编译运行，选择Show the report navigator -&gt; build，可以看到对应的日志输出。</p><h5 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h5><ul><li><p>我们并没有直接设置<strong>执行Ruby 或 Python 代码</strong>，是因为这两类脚本可能并存在项目中，编译前执行shell脚本，在shell脚本中定义执行Ruby 或 Python脚本。</p></li><li><p>接下来介绍如何将生成的类文件自动添加到项目中。</p></li></ul><blockquote><h4 id="三、自动添加类文件到项目"><a href="#三、自动添加类文件到项目" class="headerlink" title="三、自动添加类文件到项目"></a>三、自动添加类文件到项目</h4></blockquote><p><strong>目标</strong>：将通过Ruby 脚本来生成类文件自动添加到项目。（手动添加也可以，但是我想偷点懒）</p><h5 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h5><ul><li><p>在Xcode项目中，我们手动添加和删除类文件，其实是在修改<strong>project.pbxproj</strong>文件。</p></li><li><p>Cocoapods提供了一个可以创建和修改 Xcode 工程文件的工具：<a href="https://github.com/CocoaPods/Xcodeproj" target="_blank" rel="noopener">Xcodeproj</a>，该工具中有<strong>Ruby 的开源库xcodeproj</strong>，可以帮助我们实现<strong>自动添加类文件到项目</strong>。（Cocoapods也是通过它自动添加文件到到项目）</p></li><li><p>我们可以通过<strong>安装Cocoapods实现安装ruby的xcodeproj库</strong>；当然也可以<strong>直接安装</strong>，执行命令gem install xcodeproj即可。无论是选择哪种方案，都需要注意使用正确的ruby源。</p></li><li><p>因为一直在使用<strong>Cocoapods</strong>，恰好在升级系统到<strong>macOS 10.13</strong>后，发现使用xcodeproj库有问题，原因是Cocoapods版本过旧，需要升级Cocoapods，升级过程中，要注意现在“taobao Gems 源已停止维护”，使用 ruby-china 提供镜像服务。下面以安装Cocoapods为例：</p><pre><code>sudo gem update --system    //升级gem，很有必要gem sources --remove https://rubygems.org/gem sources --remove https://ruby.taobao.org/       //如果安装了淘宝的镜像gem sources -a https://gems.ruby-china.org/          //保证只使用ruby-china镜像gem sources -l                                       //查看更换源结果，保证只有ruby-china镜像sudo gem uninstall cocoapods                           //如果有旧的CocoaPods，先卸载sudo gem install -n /usr/local/bin cocoapods          //安装最新的</code></pre></li></ul><h5 id="2、主要代码实现"><a href="#2、主要代码实现" class="headerlink" title="2、主要代码实现"></a>2、主要代码实现</h5><pre><code>#添加类文件到项目def add_files_to_projects(oc_file_paths,group_path)  #1、获取.xcodeproj  xcodeproj_path = File.expand_path File.join(__dir__, &quot;../&quot;, &quot;QSRunScriptDemo.xcodeproj&quot;)  project = Xcodeproj::Project.open(xcodeproj_path)  #2、获取target  target = project.targets.first  #3、创建group  generator_group = project.main_group.find_subpath(group_path, true)  generator_group.clear  generator_group.set_source_tree(&apos;SOURCE_ROOT&apos;)  #4、向group中添加文件  file_refs = []  oc_file_paths.each do |f|      unless generator_group.find_file_by_path(f)          file_ref = generator_group.new_reference(f)          file_refs &lt;&lt; file_ref      end  end  #5、将文件加入 Build Phases  target.add_file_references(file_refs)  #6、保存 project  project.saveend</code></pre><blockquote><h4 id="四、自动生成Objective-C代码实例"><a href="#四、自动生成Objective-C代码实例" class="headerlink" title="四、自动生成Objective-C代码实例"></a>四、自动生成Objective-C代码实例</h4></blockquote><p>#####1、输入：txt模板（文件名user_model.txt） #####</p><pre><code>varchar,nameint,agevarchar,addressvarchar,password</code></pre><p><strong>说明</strong>：文件名和OC类名相关，文本内每一行描述属性类型和名称。</p><p>#####2、执行脚本（自动执行） #####</p><p>在start.sh文件中输入执行脚本命令</p><pre><code>ruby generator_model/model_generator.rb</code></pre><p>#####3、输出：OC类文件及代码 #####</p><pre><code>// QSUserModel.h文件// Generated by Ruby.  DO NOT EDIT!//  Copyright © 2017年 shaoqing. All rights reserved.#import &lt;UIKit/UIKit.h&gt;@interface QSUserModel : NSObject@property (nonatomic,copy)NSString *name;@property (nonatomic,assign)NSInteger age;@property (nonatomic,copy)NSString *address;@property (nonatomic,copy)NSString *password;@end//QSUserModel.m文件// Generated by Ruby.  DO NOT EDIT!//  Copyright © 2017年 shaoqing. All rights reserved.#import &quot;QSUserModel.h&quot;@implementation QSUserModel@end</code></pre><p><strong>说明</strong>：类名QSUserModel，根据模板文件名而来；属性定义根据模板内容而来。</p><p>#####4、总结 #####</p><ul><li><p>通过ruby脚本，实现了根据模板实现了<strong>自动生成Model类</strong>和<strong>自动添加文件到项目</strong>。</p></li><li><p>在iOS项目中，脚本生成代码这类做法，不单单是帮助iOS开发减少重复工作量，从更广的范围来看，其实是为了让跨团队，跨部门的合作更加高效，更好地达成目标。</p></li><li><p>本例只是一个简单例子，主要为了说清思路，设计比较粗糙；在实际工程中，模板中需要定义的信息很多，txt并不是一个很好的选择；ruby脚本还需要更多完善的地方。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS开发中，使用脚本语言(Ruby或Python)生成些Objective-C代码，提高代码生产力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈iOS图片优化</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/13/iOS04-imageOptimize/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/13/iOS04-imageOptimize/</id>
    <published>2018-01-13T11:40:12.000Z</published>
    <updated>2019-03-23T05:06:33.430Z</updated>
    
    <content type="html"><![CDATA[<p>根据我自己的经验，说一下我对图片优化的理解。</p><blockquote><h4 id="一、他山之石"><a href="#一、他山之石" class="headerlink" title="一、他山之石"></a>一、他山之石</h4></blockquote><h5 id="1、图片的加载步骤"><a href="#1、图片的加载步骤" class="headerlink" title="1、图片的加载步骤"></a>1、图片的加载步骤</h5><p>从磁盘中加载图片，并通过UIImageVIew显示在屏幕上，需要经过以下步骤：</p><pre><code>1、从磁盘拷贝数据到内核缓冲区2、从内核缓冲区复制数据到用户空间3、生成UIImageView，把图像数据赋值给UIImageView4、如果图像数据为未解码的PNG/JPG，解码为位图数据5、CATransaction捕获到UIImageView layer树的变化6、主线程Runloop提交CATransaction，开始进行图像渲染  6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。  6.2 GPU处理位图数据，进行渲染。</code></pre><p><strong>说明1</strong>：这部分摘抄自<a href="http://blog.cnbang.net/tech/2578/" target="_blank" rel="noopener">iOS图片加载速度极限优化—FastImageCache解析</a>，它介绍了<a href="https://github.com/path/FastImageCache" target="_blank" rel="noopener">FastImageCache</a>极限优化的手段。</p><h5 id="2、FastImageCache的优化手段"><a href="#2、FastImageCache的优化手段" class="headerlink" title="2、FastImageCache的优化手段"></a>2、FastImageCache的优化手段</h5><p><em>优化有三</em>：</p><ul><li><p>使用<strong>mmap这样的内存映射方案</strong>，将文件映射进内存；比普通的<strong>read()读取</strong>少了一次内存拷贝（内核缓存区拷贝到用户内存空间）</p></li><li><p><strong>图像子线程解码</strong>，将耗时的解码工作从主线程移到了子线程; <strong>缓存解码后的位图数据</strong>到磁盘，避免重复解码。</p></li><li><p><strong>字节对齐</strong>；生成字节对齐的数据，防止CoreAnimation在渲染时再拷贝一份数据。</p></li></ul><h5 id="3、FastImageCache的缺点"><a href="#3、FastImageCache的缺点" class="headerlink" title="3、FastImageCache的缺点"></a>3、FastImageCache的缺点</h5><p><em>缺点有三</em>：</p><ul><li><p>位图数据缓要保存在磁盘，<strong>占据空间大</strong>。</p></li><li><p><strong>接口不友好</strong>，需预定义好缓存的图像尺寸。FastImageCache无法像SDWebImage那样无缝接入UIImageView。</p></li><li><p>FastImageCache库已经快4年没有新的版本更新，很多项目使用SDWebImage这样的活跃库。</p></li></ul><h5 id="4、我的拙见"><a href="#4、我的拙见" class="headerlink" title="4、我的拙见"></a>4、我的拙见</h5><ul><li><p>在项目中，为了优化，直接颠覆原来的，风险很大；但是借鉴其他好的方法，对原有的进行优化，是个值得做的事情。</p></li><li><p>图片的优化，绕不开图片的<strong>解码</strong>、<strong>缓存</strong>和<strong>下载</strong>三大件。</p></li><li><p>优化工作需要考虑 <strong>低代价高回报</strong> 这件事。</p></li></ul><blockquote><h4 id="二、本地图片加载的优化"><a href="#二、本地图片加载的优化" class="headerlink" title="二、本地图片加载的优化"></a>二、本地图片加载的优化</h4></blockquote><h5 id="1、优化的目的"><a href="#1、优化的目的" class="headerlink" title="1、优化的目的"></a>1、优化的目的</h5><p><em>目的有三：</em></p><ul><li><p><strong>减少App包的大小</strong>；图片体积的暴增最大原因之一；可能是新业务引入大量图片资源。</p></li><li><p><strong>提高图片加载的性能</strong>；使用UIImage的方法imageNamed:方法加载图片，<strong>默认在主线程解码</strong>会拖累你的APP性能。可以考虑<strong>将图片的解码放在子线程</strong>。</p></li><li><p><strong>图像不失真</strong>；JPG或PNG格式的图片展示时，可能会失真。PNG比JPG好一些。</p></li></ul><h5 id="2、优化手段"><a href="#2、优化手段" class="headerlink" title="2、优化手段"></a>2、优化手段</h5><p><em>手段有三：</em></p><ul><li><p><strong>PNG图片虽好不作为唯一的选择</strong>，本地图片可以使用其他方案代替。如<strong>矢量图PDF</strong>、<strong>ICONFONT</strong>、<strong>CG绘制</strong>。（像运营类色彩比较丰富的图片，优先使用PNG图片）</p></li><li><p><strong>缓存的使用</strong>。无论是图片的解码，还是绘制CG图片，都是个耗时耗CPU的操作，将这些结果缓存(到内存中)下来，避免重复解码和绘制，是个好的选择，这里推荐<a href="https://github.com/ibireme/YYCache" target="_blank" rel="noopener">YYCache</a>这样的方案（线程安全、LRU淘汰算法）。</p></li><li><p><strong>及时清理旧的图片资源</strong>。使用类似<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a> 清理旧的图片文件。</p><p><strong>说明</strong>：导入项目中的图片记得压缩。</p></li></ul><blockquote><h4 id="三、网络图片的优化"><a href="#三、网络图片的优化" class="headerlink" title="三、网络图片的优化"></a>三、网络图片的优化</h4></blockquote><p>相比较本地图片，它面临复杂的网络环境、复杂的图片来源。</p><h5 id="1、优化目的"><a href="#1、优化目的" class="headerlink" title="1、优化目的"></a>1、优化目的</h5><p><em>目的有三：</em></p><ul><li><p><strong>异步下载</strong>，不阻塞主线程操作；</p></li><li><p>图片<strong>快速加载显示</strong>；</p></li><li><p><strong>良好的接口</strong>，让使用者用的<em>开心</em> ；（不必关心复杂的网络环境、图片加载性能等）</p></li></ul><h5 id="2、优化手段-1"><a href="#2、优化手段-1" class="headerlink" title="2、优化手段"></a>2、优化手段</h5><p><em>手段有三：</em></p><ul><li><p><strong>使用优秀的第三方库</strong>，如<a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>。关于SDWebImage我在简书上写了文章<a href="https://www.jianshu.com/p/f3cb4ea0d14c" target="_blank" rel="noopener">SDWebImage源码理解</a>,可以看看。</p></li><li><p><strong>使用压缩比高，质量小，失真小的图片格式</strong>，如Google的Webp、Tencent的SharpP格式，这两图片文件小，很适合在网络中传输，消耗的流量少，下载快,解码快（SharpP和webp的编码慢）。</p></li><li><p><strong>结合业务需要优化图片</strong>；网络环境获取图片比较复杂，且难以预测；对下载下来的图片进行<strong>裁剪</strong>（按显示的<em>目标大小</em>、<em>是否需要圆角</em>、<em>描边</em>、<em>阴影</em>等），能很大程度上避免<strong>图片像素不对齐</strong>(图片大小和显示大小不一致)、<strong>像素混合</strong>（图层透明）、<strong>离屏渲染</strong>（圆角和阴影等）等问题。</p><p>  <strong>参考</strong>：<a href="https://cloud.tencent.com/developer/article/1004404" target="_blank" rel="noopener">图片流量节省大杀器：基于 CDN 的 sharpP 自适应图片技术实践</a></p></li></ul><h5 id="3、一些小的优化手段"><a href="#3、一些小的优化手段" class="headerlink" title="3、一些小的优化手段"></a>3、一些小的优化手段</h5><ul><li><p>要从网络中获取的<strong>重要图片</strong>（如广告、运营相关的图片），要<strong>先校验图片的完整性</strong>，校验通过才去真正处理并显示，否则不处理。</p></li><li><p>纯显示的视图，CALayer代替UIImageVIew，可以减少GPU计算（去透明/像素对齐）</p></li></ul><blockquote><h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4></blockquote><ul><li>这篇文章算是对之前写的 <a href="https://www.jianshu.com/p/a38a7c7bccbb" target="_blank" rel="noopener">网络图片的优化显示</a> 和 <a href="https://www.jianshu.com/p/26402bc4ddac" target="_blank" rel="noopener">iOS中本地图片的缩放、裁剪和压缩</a>的<strong>补充</strong>和<strong>扩展</strong>吧。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据我自己的经验，说一下我对图片优化的理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、他山之石&quot;&gt;&lt;a href=&quot;#一、他山之石&quot; class=&quot;headerlink&quot; title=&quot;一、他山之石&quot;&gt;&lt;/a&gt;一、他山之石&lt;/h4&gt;&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈代码混淆</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/04/iOS03-codeConfuse/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/04/iOS03-codeConfuse/</id>
    <published>2018-01-04T15:21:30.000Z</published>
    <updated>2019-03-23T05:06:24.797Z</updated>
    
    <content type="html"><![CDATA[<p>代码混淆的目的，是为了对抗<strong>反编译</strong>。</p><blockquote><h4 id="一、反编译工具"><a href="#一、反编译工具" class="headerlink" title="一、反编译工具"></a>一、反编译工具</h4></blockquote><p>虽然AppleStore会对App加壳保护，但是在越狱手机上，破壳App并非不可能，失去保护的App，可以利用工具去反编译；常见的反编译工具有： <strong>class-dump</strong> 和 <strong>Hopper Disassembler</strong>；</p><h5 id="1、class-dump简介"><a href="#1、class-dump简介" class="headerlink" title="1、class-dump简介"></a>1、class-dump简介</h5><ul><li><p>下载并安装<a href="https://link.jianshu.com/?t=http://stevenygard.com/projects/class-dump/" target="_blank" rel="noopener">class-dump</a>，将class-dump复制到/usr/local/bin/目录下，使用下面命令可以反编译出头文件</p><pre><code>class-dump -H xxx.app -o /Users/xxxx/Desktop/heads </code></pre></li></ul><h5 id="2、Hopper-Disassembler简介"><a href="#2、Hopper-Disassembler简介" class="headerlink" title="2、Hopper Disassembler简介"></a>2、Hopper Disassembler简介</h5><ul><li><p>下载并安装<a href="http://xclient.info/s/hopper-disassembler.html?_=ccf82bf7d0f9ec485d8d0e11710f4561" target="_blank" rel="noopener">Hopper Disassembler</a></p><pre><code>//破解办法：将Hopper Disassembler v4.app移动至应用程序文件夹双击HopperV4Patcher，将应用程序中的Hopper Disassembler v4.app拖进HopperV4Patcher完成注册</code></pre></li><li><p>解压缩App文件，获得二进制文件，直接拖进Hopper Disassembler，选择点右上角的if(b)f(x)，就可以看到类名、方法、伪代码，字符串等信息。</p></li></ul><p><strong>说明</strong>：开发中，我们可以利用Xcode在debug下编译后产生的（.app）文件, 作为反编译练习的<strong>原材料</strong>。这个文件放在<strong>/Users/user name/Library/Developer/Xcode/DerivedData/ xx Project Name/Build/Products/Debug-iphonesimulator</strong>。</p><blockquote><h4 id="二、代码混淆"><a href="#二、代码混淆" class="headerlink" title="二、代码混淆"></a>二、代码混淆</h4></blockquote><h5 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h5><ul><li><p><strong>代码混淆</strong>： 主要是混淆重要的 <strong>方法名</strong> 、 <strong>类名</strong> 和 <strong>字符串常量</strong>。（大面积的混淆没有太大意义），手段主要是利用宏定义。</p></li><li><p><strong>宏定义</strong>的关键就是<strong>替换</strong>，将A替换成B；A可以是<strong>见名知意</strong>函数名、类名或字符串常量，B可以是<strong>百思不得其解</strong>的名字或 函数 等等。</p></li><li><p>利用宏定义，做到扰乱耳目，迷惑他人的目的。</p><p><strong>说明</strong>：具体宏方便的知识，可以参考<a href="https://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">宏定义的黑魔法 - 宏菜鸟起飞手册</a></p></li></ul><h5 id="2、具体方案"><a href="#2、具体方案" class="headerlink" title="2、具体方案"></a>2、具体方案</h5><ul><li><p><strong>混淆方法名 和 类名</strong></p><pre><code>单段的selector，如func: ，可以通过#define func 来实现字符串替换。多段的selector，如a:b:c: ，可以通过分别#define a 、b、c 来实现字符串替换。</code></pre></li><li><p><strong>混淆字符串常量</strong></p><p>  代码中使用的都是密文（密文通过脚本生成）；OC中定义对应的 <strong>密文转成明文</strong> 方法；这样编译出来的只有字符串常量只有密文，反编译者难以根据字符串信息，去推敲逻辑。</p></li></ul><h5 id="3、方案实现"><a href="#3、方案实现" class="headerlink" title="3、方案实现"></a>3、方案实现</h5><ul><li>脚本实现方法名 、 类名 和 字符串常量的混淆，输入是想要混淆的对象，输出是 <strong>#define 要混淆的对象  混淆内容</strong>。混淆内容可以是随机字符串等难以理解的信息。</li></ul><ul><li>考虑到方便自己、恶心别人的目的，我们将混淆结果合并在一个.h中，在工程Prefix.pch的最前面#import这个.h文件。不导入也可以编译、导入则实现混淆。</li></ul><p><strong>脚本实现如下</strong>：</p><pre><code>#!/usr/bin/python # -*- coding: utf-8 -*-import sysimport osfrom random import Randomimport time;  import base64## 执行脚本命令：python Confuse.py## ***** 工具类 *****class Util(object):    def __init__(self, arg):        super(Util, self).__init__()        self.arg = arg    # 生成随机串    @classmethod    def randomString(self,randomlength=16):        str = &apos;&apos;        chars = &apos;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz&apos;        length = len(chars) - 1        random = Random()        for i in range(randomlength):            str += chars[random.randint(0, length)]        return str    @classmethod    def loadFileCotent(self,filePath):        contents = []        with open(filePath) as f:            line = f.readline()            while line:                contents.append(line.rstrip(&apos;\n&apos;))                 line = f.readline()        return contents    #加密（可以换成你想要的加密方法）    @classmethod    def encrypt(self,content):        res = &apos; &apos;.join([bin(ord(c)).replace(&apos;0b&apos;, &apos;&apos;) for c in content])        return base64.b64encode(res)    # 解密 (需要OC代码实现一份)    @classmethod    def decrypt(self,content):        return &apos;&apos;.join([chr(i) for i in [int(b, 2) for b in base64.b64decode(content).split(&apos; &apos;)]])#混淆函数名和方法名def confuseFunc(filePath):    originContents = Util.loadFileCotent(filePath)    confuseRes = &apos;&apos;    for i in range(0,len(originContents)):        outStr = &quot;#define &quot; + originContents[i] + &quot; &quot; + Util.randomString() + &quot;\n&quot;        confuseRes = confuseRes + outStr    #返回混淆结果    return confuseRes#混淆字符串def confuseText(filePath):    originContents = Util.loadFileCotent(filePath)    confuseRes = &apos;&apos;    for i in range(0,len(originContents)):        text = originContents[i]        text_encrypted = Util.encrypt(text)        # print &quot;decrypt&quot;,Util.decrypt(text_encrypted)        outStr = &quot;#define kKBParameter%sKey  QSString(@\&quot;%s\&quot;)\n&quot; %(text.capitalize(),text_encrypted)        confuseRes = confuseRes + outStr    #返回混淆结果    return confuseResconfuse_file_name =  &quot;QSConfuseHeader&quot;if __name__ == &apos;__main__&apos;:    fileContent = &apos;&apos;&apos;////  &apos;&apos;&apos; + confuse_file_name + &apos;&apos;&apos;//  XXProject////  Created on&apos;&apos;&apos; + time.asctime( time.localtime(time.time()) ) + &apos;&apos;&apos;!\n #ifndef &apos;&apos;&apos; + confuse_file_name + &apos;&apos;&apos;_h#define &apos;&apos;&apos; + confuse_file_name + &apos;&apos;&apos;_h\n\n&apos;&apos;&apos;    confuseFuncContent = confuseFunc(&quot;func_class.txt&quot;)    if len(confuseFuncContent) &gt; 0:        fileContent += &quot;\n//函数混淆\n&quot; + confuseFuncContent    confuseTextContent = confuseText(&quot;string.txt&quot;)    if len(confuseTextContent) &gt; 0:        fileContent += &quot;\n//字符串混淆\n&quot; + confuseTextContent    endFileContent = &quot;\n\n#endif /* &quot; + confuse_file_name + &quot;_h */&quot;    if len(fileContent) &gt; 0:        fileContent+= endFileContent        print fileContent        # 打开一个文件        outputFile = open(confuse_file_name + &quot;.h&quot;, &quot;wb&quot;)        outputFile.write(fileContent)        # 关闭打开的文件        outputFile.close()</code></pre><p>​<br>   <strong>说明1</strong>：目前需要混淆内容放在txt文件（需要混淆函数名和类名放在func_class.txt，需要混淆字符串常量放在string.txt中）；进一步做法是，给需要混淆的字符串打上标记，然后用脚本搜索这些需要混淆的对象，实现混淆；</p><p>  <strong>说明2</strong>：代码混淆需要考虑代码的可读性，建议做法是，对应混淆后的结果使用<strong>宏定义</strong>替换，类似于</p><pre><code>//QSString(x)是个宏方法，定义是解密实现，在OC中实现#define kKBParameterGoodKey  QSString(@&quot;MTEwMDExMSAxMTAxMTExIDExMDExMTEgMTEwMDEwMA==&quot;)</code></pre><p>  <strong>说明3</strong>：在脚本中，加密方法并非真正的加密，只是将字符串转成二进制，再Base64编码而已；这个根据自己业务需要增加真正的加密算法，对应的解密算法放在OC中实现。</p><p>  <strong>其他参考</strong><a href="http://blog.csdn.net/yiyaaixuexi/article/details/29201699" target="_blank" rel="noopener">iOS安全攻防（二十三）：Objective-C代码混淆</a></p><blockquote><h4 id="三、关键逻辑混淆"><a href="#三、关键逻辑混淆" class="headerlink" title="三、关键逻辑混淆"></a>三、关键逻辑混淆</h4></blockquote><p>提供两种方案</p><h5 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h5><ul><li><p>把函数名隐藏在结构体里，以函数指针成员的形式存储。</p></li><li><p>编译后，只留了下地址，去掉了名字和参数表，提高了逆向成本和攻击门槛。</p></li><li><p>具体参考<a href="http://blog.csdn.net/yiyaaixuexi/article/details/29210413" target="_blank" rel="noopener">iOS安全攻防（二十四）：敏感逻辑的保护方案（1）</a></p></li></ul><h5 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h5><ul><li><p>使用C/C++语言实现逻辑，这里利用到Objective-C 与 C/C++混编的知识。下面以C++为例，混编最需要注意的是<strong>OC 调用 C++</strong>和<strong>C++ 调用 OC</strong></p></li><li><p><strong>OC 调用 C++</strong>：这种情况比较简单，因为编译器做了优化，把 .m 文件直接改为 <strong>.mm</strong> ，然后直接用就好了。</p></li><li><p><strong>C++ 调用 OC</strong>：分为两种情况：1）完全的 C++ ，实现文件以 .cpp 结尾，里面不允许直接OC的方法；通过编写接口，间接调用 OC 方法，实际上 C++ 调用的是OC编译过后的 .o 文件；2）部分 C++ 部分 OC ，实现文件以 .mm 结尾，里面允许直接使用 OC 方法。</p></li></ul><blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></blockquote><ul><li>代码混淆只是提高了破解的门槛和难度，不能百分百保证代码安全，但是如果不做这些，你的核心业务无疑在裸奔，这是很危险的事情。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码混淆的目的，是为了对抗&lt;strong&gt;反编译&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;一、反编译工具&quot;&gt;&lt;a href=&quot;#一、反编译工具&quot; class=&quot;headerlink&quot; title=&quot;一、反编译工具&quot;&gt;&lt;/a&gt;一、反编译工具&lt;/h
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈AES</title>
    <link href="http://buaa0300/nanhuacoder.com/2018/01/03/iOS02-AESInfo/"/>
    <id>http://buaa0300/nanhuacoder.com/2018/01/03/iOS02-AESInfo/</id>
    <published>2018-01-03T15:23:50.000Z</published>
    <updated>2019-03-23T05:06:11.702Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote><ul><li><p><strong>对称加密</strong>比<strong>非对称加密</strong>要快。频繁的数据加密，优先考虑使用<strong>对称加密</strong>。</p></li><li><p>DES -&gt; 3DES -&gt; <strong>AES</strong>（Advanced Encryption Standard，高级加密标准）；目前对称加密使用<strong>AES</strong>为佳，它已经取代DES和3DES对称算法了。</p></li><li><p>AES是项目中使用较多的对称加密算法，本文简单介绍下AES。</p></li></ul><blockquote><h4 id="二、AES算法的重要组成"><a href="#二、AES算法的重要组成" class="headerlink" title="二、AES算法的重要组成"></a>二、AES算法的重要组成</h4></blockquote><h5 id="1、密钥长度（Key-Size）"><a href="#1、密钥长度（Key-Size）" class="headerlink" title="1、密钥长度（Key Size）"></a>1、密钥长度（Key Size）</h5><p>  AES算法规定密钥长度有三种：128bits、192bits和256 bits。其中<strong>128 bits的key可以满足大部分业务需求</strong>。</p><h5 id="2、加密模式（Cipher-Mode）"><a href="#2、加密模式（Cipher-Mode）" class="headerlink" title="2、加密模式（Cipher Mode）"></a>2、加密模式（Cipher Mode）</h5><p>   AES属于块加密（Block Cipher），加密数据块（Block）必须为<strong>128bits（16字节）</strong>；加密模式主要有以下<strong>六种</strong>模式：</p><p><strong>1) ECB (Electronic Codebook Book，电子密码本模式)</strong></p><ul><li><p><strong>简介</strong>：将数据分成若干块，分别对每块进行加密，最后将这些密文块组成最后的加密结果</p></li><li><p><strong>说明</strong>：最简单的模式，安全性较低。因为ECB的明文分组与密文分组是一一对应的关系，如果明文中存在多个相同的明文分组，其对应的密文分组也是相同的；<strong>不推荐使用</strong>。</p></li></ul><p><strong>2) CBC（Cipher Block Chaining，密码分组链接模式)</strong></p><ul><li><p><strong>简介</strong>：将数据分块后，每一块数据与上一块密文XOR（异或）后，再进行加密；</p></li><li><p><strong>说明</strong>：比较推荐使用的模式（但Apple已经不推荐使用CBC模式，建议使用<strong>GCM</strong>模式）。</p></li></ul><p><strong>3) CTR(Counter，计数器模式)</strong></p><ul><li><p><strong>简介</strong>：通过将<strong>逐次累加的计数器</strong>进行加密来生成密钥流的流密码；最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR得到的。</p></li><li><p><strong>说明</strong>：比较推荐使用的模式</p></li></ul><p><strong>4) CFB(Cipher FeedBack,密码反馈模式)</strong></p><ul><li><p><strong>简介</strong>：和CBC类似，加密模式和CBC类似，但其可以将块密码变为自同步的流密码。</p></li><li><p><strong>说明</strong>：不推荐使用的模式</p></li></ul><p><strong>5) OFB(Output FeedBack, 输出反馈模式)</strong></p><ul><li><p><strong>简介</strong>：将块密码变成同步的流密码，它产生密钥流的块，然后将其与明文块进行异或，得到密文。</p></li><li><p><strong>说明</strong>：不推荐使用的模式</p></li></ul><p><strong>6) GCM(Galois/Counter Mode,)</strong></p><ul><li><p><strong>简介</strong>：GCM中的G就是指GMAC(消息验证码)，C就是指CTR(计数器模式)</p></li><li><p><strong>说明</strong>：GCM可以提供对消息的加密和完整性校验，AES模式最好选择。</p></li></ul><p><strong>总结</strong>: 推荐先后顺序：<strong>GCM &gt; CTR &gt; CBC</strong>；详细内容可以参考<a href="https://xiaoxueying.gitbooks.io/graphic-cryptology/content/block_cipher_mode.html" target="_blank" rel="noopener">Block cipher mode</a>、<a href="http://blog.csdn.net/T0mato_/article/details/53160772" target="_blank" rel="noopener">AES-GCM加密算法</a></p><h5 id="3、填充方式（Padding）"><a href="#3、填充方式（Padding）" class="headerlink" title="3、填充方式（Padding）"></a>3、填充方式（Padding）</h5><p>  1）<strong>块加密</strong>要求对<strong>特定长度的数据块</strong>进行加密，因此<strong>CBC模式</strong>、<strong>ECB模式</strong>需要在最后一数据块加密前进行数据填充。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）。</p><p>  2）iOS SDK中提供了<strong>PKCS7Padding</strong>，Java提供了<strong>PKCS5Padding</strong>。原则上PKCS5Padding限制了填充的Block Size为8 字节（大于8 字节，填充和PKCS7Padding相同），而PKCS7Padding的Block Size可以为1到255字节; 填充值的算法（需要填充x个字节，填充的值就是x）都是一样的：</p><pre><code>value = k - (l mod k)  ,K = 块大小，l = 数据长度；假设k是16，I是5,那么value是11，也就是说，需要填充11个byte的 0x0B(十进制是11)</code></pre><p>  3）因为<strong>AES加密数据块</strong>Block Size规定为16字节(<em>128bits</em>), 大于8 字节(64 bits), 所以<strong>PKCS5Padding和PKCS7Padding填充效果</strong>是一样的。</p><p>  <strong>说明</strong>：数据块的长度如果是16倍数，padding长度为16，padding值为0x10。即在输入后面补齐16字节的0x10；如果数据块的长度不是16倍数，padding长度为16-L%16，padding值为16-L%16。即在输入后面补齐16-L%16的字节，值为16-L%16。</p><p>  4）平时使用最多的是PKCS7Padding，NoPadding、ISO10126Padding和ZeroPadding忽略不提。</p><h5 id="4、初始向量（Initialization-Vector）"><a href="#4、初始向量（Initialization-Vector）" class="headerlink" title="4、初始向量（Initialization Vector）"></a>4、初始向量（Initialization Vector）</h5><p>  CBC、CFB和OFB这些加密模式需要传入一个初始向量，其大小与Block Size相等；当不传入初始向量时，系统将默认使用一个全0的初始向量。</p><blockquote><h4 id="三、AES算法Python实现"><a href="#三、AES算法Python实现" class="headerlink" title="三、AES算法Python实现"></a>三、AES算法Python实现</h4></blockquote><p><strong>说明</strong>：使用Python的加密包<a href="https://pypi.python.org/pypi/pycrypto" target="_blank" rel="noopener">pycrypto</a> (下载后，执行<em>python setup.py build + python setup.py install</em>)，实现AES的ECB、CBC、CTR、CFB和OFB模式下的加密和解密；定义一个PaddingHelper类，实现PKCS7Padding；</p><pre><code>#!/usr/bin/python # -*- coding:utf-8 -*-import sysimport osimport base64from Crypto.Cipher import AESfrom Crypto.Util import Counter# ***** Padding Helper For AES *****class  PaddingHelper(object):    &quot;&quot;&quot;docstring for  Padding Helper&quot;&quot;&quot;    def __init__(self, arg):        super(PaddingHelper, self).__init__()        self.arg = arg    # 保证keyStr的长度是16    @classmethod    def validKeyStr(self,keyStr):            keySize = 16        if len(keyStr) &lt; keySize:            zeroCount = keySize - len(keyStr) % keySize              for i in range(0, zeroCount):                  keyStr = keyStr + &apos;\0&apos;         else:            return keyStr[0:keySize]        return keyStr      # 实现PKCS7Padding/PKCS7Padding    @classmethod    def PKCS7Padding(self,text,blockSize=16):            count = len(text)            mod_num = count % blockSize        add_num = blockSize - mod_num        return text + chr(add_num) * add_num        @classmethod    def MovePKCS7Pading(self,text,blockSize=16):        lastChar = text[-1]            paddingLen = ord(lastChar)        # 截取最后一部分填充快        lastChunk = text[-paddingLen:]        if lastChunk == chr(paddingLen) * paddingLen:            # 移除填充部分           return text[:-paddingLen]        return text     # AES PSK7/PSK5填充class AESUtil():    def __init__(self, key, model):        self.key = PaddingHelper.validKeyStr(key)        self.mode = model        self.iv = key   #初始向量初始化k，可以是别的值，但必须16字节    #加密函数，如果text不是16的倍数,那就补足为16的倍数    def encrypt(self, text):        if self.mode == AES.MODE_CTR:             # Create new AES CTR object #            cryptor = AES.new(self.key, self.mode, counter=Counter.new(128))        else:            cryptor = AES.new(self.key, self.mode, self.iv)        text = PaddingHelper.PKCS7Padding(text,16)        ciphertext = base64.b64encode(cryptor.encrypt(text))        return ciphertext    #解密后，去掉补足的空格用strip() 去掉    def decrypt(self, text):           if self.mode == AES.MODE_CTR:             # Create new AES CTR object #            cryptor = AES.new(self.key, self.mode, counter=Counter.new(128))        else:                cryptor = AES.new(self.key, self.mode, self.iv)        plainText = cryptor.decrypt(base64.b64decode(text))        return PaddingHelper.MovePKCS7Pading(plainText)if __name__ == &apos;__main__&apos;:    encrykey = &quot;0123456789abcdef&quot;    # plainText = &apos;1234567891234567&apos;    plainText = &apos;hello world&apos;    dict = {&quot;CBC模式&quot;: AES.MODE_CBC,             &quot;CFB模式&quot;: AES.MODE_CFB,             &quot;CTR模式&quot;: AES.MODE_CTR,            &quot;ECB模式&quot;: AES.MODE_ECB,            &quot;OFB模式&quot;: AES.MODE_OFB};    for key, value in dict.iteritems():        aes = AESUtil(encrykey,value)        encryptText = aes.encrypt(plainText)        print &quot;**********%s 加解密*******&quot; %(key)        print &quot;密文:&quot;,encryptText        print &quot;明文:&quot;,aes.decrypt(encryptText)</code></pre><p><strong>执行脚本的输出结果如下</strong></p><pre><code>**********ECB模式 加解密*******密文: gWm+1O9JqIdFWcWyANqt5w==明文: hello world**********CFB模式 加解密*******密文: GsZEtzHsqRLRjxfUU6T0Zg==明文: hello world**********CBC模式 加解密*******密文: wem0Upqsl5MBD0Z39jWO/g==明文: hello world**********OFB模式 加解密*******密文: GhcS5HH8im5yy3xtfAywYA==明文: hello world**********CTR模式 加解密*******密文: adUgVHVGk4Y3/LZatTZf6Q==明文: hello world</code></pre><blockquote><h4 id="四、AES算法使用说明"><a href="#四、AES算法使用说明" class="headerlink" title="四、AES算法使用说明"></a>四、AES算法使用说明</h4></blockquote><ul><li><p>对AES加密的结果，要使用<strong>Base64编码</strong>。因为其加密结果得到的字符串可能有不可见字符，保存和传输都有问题；把数据做Base64编码，统统变成可见字符。（Base64编码 将二进制流中每6个bit一组表示数据, 不足的部分补零,每两个0 用 一个 = 表示，把含有不可见字符串的信息用可见字符串表示出来 ）；对应的AES解密时，先要进行Base64解码</p></li><li><p>AES有很明显的优势：<strong>安全</strong>、<strong>加解密快</strong>（AES比RSA的加解密快1000倍）；但是劣势也明显，需重点保护<strong>密钥</strong>的安全；在实践中推荐组合使用<strong>AES</strong>和<em>*RSA</em>技术。</p></li><li><p>实践中<strong>常见的方案</strong>是：1）用AES来加密数据；2）AES的密钥通过<strong>伪随机数生成器</strong>生成；3）AES的密钥通过<strong>RSA公钥加密</strong>；4）最终将AES密钥的密文 和 数据的密文交给后台，后台利用对应的策略解密。</p></li><li><p>AES算法流程可以参考<a href="http://www.cnblogs.com/luop/p/4334160.html" target="_blank" rel="noopener">密码算法详解——AES</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h4&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;对称加密&lt;/strong&gt;比&lt;str
      
    
    </summary>
    
      <category term="iOS2018" scheme="http://buaa0300/nanhuacoder.com/categories/iOS2018/"/>
    
    
      <category term="iOS" scheme="http://buaa0300/nanhuacoder.com/tags/iOS/"/>
    
      <category term="加密" scheme="http://buaa0300/nanhuacoder.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
</feed>
