<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="南华coder的空间" type="application/atom+xml" />






<meta name="description" content="天之道，损有余而补不足">
<meta property="og:type" content="website">
<meta property="og:title" content="南华coder的空间">
<meta property="og:url" content="http://buaa0300/nanhuacoder.com/index.html">
<meta property="og:site_name" content="南华coder的空间">
<meta property="og:description" content="天之道，损有余而补不足">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南华coder的空间">
<meta name="twitter:description" content="天之道，损有余而补不足">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://buaa0300/nanhuacoder.com/"/>





  <title>南华coder的空间</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">南华coder的空间</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2019/03/30/iOS-DBSQlite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/iOS-DBSQlite/" itemprop="url">iOS数据库方案小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T10:44:32+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS进阶/" itemprop="url" rel="index">
                    <span itemprop="name">iOS进阶</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,883 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>技术不能解决所有事情</em></p>
<h4 id="一、移动端数据库方案"><a href="#一、移动端数据库方案" class="headerlink" title="一、移动端数据库方案"></a>一、移动端数据库方案</h4><h5 id="1、关系型数据库"><a href="#1、关系型数据库" class="headerlink" title="1、关系型数据库"></a>1、<strong>关系型数据库</strong></h5><ul>
<li><strong>SQlite</strong>：轻量级的<strong>关系数据库</strong>, 占用资源非常少，目前广泛应用于Android、iOS等手机操作系统。iOS使用时SQLite，只需要加入libsqlite3.0.tbd依赖以及引入sqlite3.h头文件即可。</li>
<li>Apple内建的CoreData底层的持久化方式也可以是<code>SQLite</code>数据库，当然也可以是XML文件、甚至是内存; 比较流行的第三方框架FMDB是对SQlite操作的封装</li>
</ul>
<h5 id="2、非关系数据库"><a href="#2、非关系数据库" class="headerlink" title="2、非关系数据库"></a>2、非关系数据库</h5><ul>
<li><strong>Realm</strong>：适用于iOS (同样适用于Swift&amp;Objective-C)和Android的跨平台移动数据库，是NoSQL框架，官方定位是取代SQLite。具体可参考<a href="https://zhuanlan.zhihu.com/p/26173366" target="_blank" rel="noopener">Realm(Java)那些事</a></li>
<li><p>Realm非常的特色是数据变更通知，查询，存储性能比SQlite好，但是体积大、存入Realm的对象必须继承RealmObject，侵入性强，Realm中存储对象不允跨线程访问</p>
</li>
<li><p>非关系型数据库还有LevelDB、RocksDB</p>
</li>
</ul>
<h5 id="3、一些看法"><a href="#3、一些看法" class="headerlink" title="3、一些看法"></a>3、一些看法</h5><ul>
<li>16年左右，Realm兴起，部分客户端团队开始使用Realm，但是更多的团队还是继续使用SQlite及其衍生方案；使用Realm并非就一定Cool，使用SQlite并非就一定Out，<strong>方案的选择应该是基于业务本身和团队的技术积累。</strong></li>
<li><p>日活上亿和几十万的App的团队思考问题方案会一样吗？在16年时候，微信分享了自己对优化SQLite的源码，具体可见<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286361&amp;idx=1&amp;sn=78bbcda7f41a14291ad71289e4821f71&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">微信iOS SQLite源码优化实践</a>，随后推出了自己的数据库方案WCDB(<em>基于SQLite</em>)</p>
</li>
<li><p>希望对SQlite的了解多一些，对已经有的成熟方案了解再多一些。</p>
</li>
</ul>
<h4 id="二、SQlite基础操作"><a href="#二、SQlite基础操作" class="headerlink" title="二、SQlite基础操作"></a>二、SQlite基础操作</h4><h5 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h5><ul>
<li><strong>表</strong>：是数据库中一个非常重要的对象，是其他对象的基础。根据信息的分类情况，一个数据库中可能包含若干个数据表</li>
<li><strong>字段</strong>：表的“列”称为“字段”，每个字段包含某一专题的信息</li>
<li><strong>记录</strong>：是指对应于数据表中一行信息的一组完整的相关信息</li>
<li>iOS使用SQLite，需要引入libsqlite3.0.tbd框架，并引入<sqlite3.h>头文件</sqlite3.h></li>
</ul>
<h5 id="2、关键API-打开数据库"><a href="#2、关键API-打开数据库" class="headerlink" title="2、关键API-打开数据库"></a>2、关键API-打开数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//打开数据库 定义</span><br><span class="line">SQLITE_API int sqlite3_open(</span><br><span class="line">  const char *filename,   /* Database filename (UTF-8) */</span><br><span class="line">  sqlite3 **ppDb          /* OUT: SQLite db handle */</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">//db是sqlite3对象，sqlite3 *db = nil;</span><br><span class="line"> sqlite3_open([sqlPath UTF8String], &amp;db);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数1：数据库的路径（因为需要的是C语言的字符串，而不是NSString所以必须进行转换）</p>
</li>
<li><p>参数2：SQLite的数据库的操作句柄（指向指针的指针）</p>
</li>
</ul>
<h5 id="3、关键API-执行sql语句"><a href="#3、关键API-执行sql语句" class="headerlink" title="3、关键API - 执行sql语句"></a>3、关键API - 执行sql语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//执行sql语句 定义</span><br><span class="line">SQLITE_API int sqlite3_exec(</span><br><span class="line">  sqlite3*,                                  /* An open database */</span><br><span class="line">  const char *sql,                           /* SQL to be evaluated */</span><br><span class="line">  int (*callback)(void*,int,char**,char**),  /* Callback function */</span><br><span class="line">  void *,                                    /* 1st argument to callback */</span><br><span class="line">  char **errmsg                              /* Error msg written here */</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line"> int result = sqlite3_exec(db, sql.UTF8String, nil, nil, nil);   </span><br><span class="line"> if (result == SQLITE_OK) &#123;</span><br><span class="line">     //exec ok</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     //exec failed</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数1：sqlite3对象</li>
<li>参数2：sql语句</li>
<li>参数3：sql执行后回调函数</li>
<li>参数4：回调函数的参数</li>
<li>参数5：错误信息</li>
</ul>
<h5 id="4、关键API-执行查询语句"><a href="#4、关键API-执行查询语句" class="headerlink" title="4、关键API - 执行查询语句"></a>4、关键API - 执行查询语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//将sql文本转换成一个准备语句（prepared statement）对象，同时返回这个对象的指针,它实际上并不执行（evaluate）这个SQL语句，它仅仅为执行准备这个sql语句。</span><br><span class="line">SQLITE_API int sqlite3_prepare_v2(</span><br><span class="line">  sqlite3 *db,            /* Database handle */</span><br><span class="line">  const char *zSql,       /* SQL statement, UTF-8 encoded */</span><br><span class="line">  int nByte,              /* Maximum length of zSql in bytes. */</span><br><span class="line">  sqlite3_stmt **ppStmt,  /* OUT: Statement handle */</span><br><span class="line">  const char **pzTail     /* OUT: Pointer to unused portion of zSql */</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">result = sqlite3_prepare_v2(_db, [sql UTF8String], -1, &amp;pStmt, 0);</span><br><span class="line">if (result == SQLITE_OK) &#123;</span><br><span class="line">     //exec ok</span><br><span class="line">&#125; else &#123;</span><br><span class="line">     //exec failed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5、关键API-关闭数据库"><a href="#5、关键API-关闭数据库" class="headerlink" title="5、关键API - 关闭数据库"></a>5、关键API - 关闭数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//关闭数据库 定义</span><br><span class="line">SQLITE_API int sqlite3_close(sqlite3*);</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">sqlite3_close(db);</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：具体API参考<a href="https://www.sqlite.org/capi3ref.html" target="_blank" rel="noopener">C-language Interface Specification for SQLite</a>，FMDB中对sqlite3的操作做了很好的封装，具体可参考FMDB的FMDatabase文件</p>
<h4 id="四、SQLite的线程模式"><a href="#四、SQLite的线程模式" class="headerlink" title="四、SQLite的线程模式"></a>四、SQLite的线程模式</h4><h5 id="1、三种线程模式"><a href="#1、三种线程模式" class="headerlink" title="1、三种线程模式"></a>1、三种线程模式</h5><ul>
<li><strong>单线程模式</strong>（Single-thread）：所有互斥锁都被禁用，<strong>SQLite连接不能在多个线程中使用</strong>（多线程使用不安全）。</li>
<li><strong>多线程模式</strong>（Multi-thread）：可以由多个线程使用，但是<strong>一个数据库连接在同一个时间只能在一个线程操作</strong>  （在多线程中使用单个数据库连接是不安全的）</li>
<li><strong>串行模式</strong>（Serialized），在此模式下，SQLite可以被多个线程安全地使用而没有任何限制（多线程下是安全的）。</li>
<li>默认是串行模式，此种情况下是线程安全的。</li>
</ul>
<h5 id="2、编译时选择线程模式"><a href="#2、编译时选择线程模式" class="headerlink" title="2、编译时选择线程模式"></a>2、编译时选择线程模式</h5><ul>
<li>通过定义<strong>SQLITE_THREADSAFE</strong>宏来指定线程模式。如果没有指定，默认为串行模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//0：单线程模式；</span><br><span class="line">//1：串行模式;</span><br><span class="line">//2：多线程模式</span><br></pre></td></tr></table></figure>
<ul>
<li>sqlite3_threadsafe()函数的返回值可以确定编译时指定的线程模式。如果指定了单线程模式，函数返回false。如果指定了串行或者多线程模式，函数返回true。</li>
<li>由于sqlite3_threadsafe()函数要早于多线程模式以及启动时和运行时的模式选择，所以它既不能区别多线程模式和串行模式也不能区别启动时和运行时的模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//FMDB 中代码</span><br><span class="line">+ (BOOL)isSQLiteThreadSafe &#123;</span><br><span class="line">    // make sure to read the sqlite headers on this guy!</span><br><span class="line">    return sqlite3_threadsafe() != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果编译时指定了单线程模式，那么临界互斥逻辑在构造时就被省略，因此也就<strong>无法在启动时或运行时指定串行模式或多线程模式。</strong></li>
</ul>
<h5 id="3、启动时选择线程模式"><a href="#3、启动时选择线程模式" class="headerlink" title="3、启动时选择线程模式"></a>3、启动时选择线程模式</h5><ul>
<li><p>假如在编译时没有指定单线程模式，就可以在应用程序初始化时使用sqlite3_config()函数修改线程模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLITE_CONFIG_SINGLETHREAD  //单线程模式</span><br><span class="line">SQLITE_CONFIG_MULTITHREAD   //多线程模式</span><br><span class="line">SQLITE_CONFIG_SERIALIZED    //串行模式</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4、运行时选择线程模式"><a href="#4、运行时选择线程模式" class="headerlink" title="4、运行时选择线程模式"></a>4、运行时选择线程模式</h5><ul>
<li>如果没有在编译时 和 启动时指定为单线程模式，那么每个数据库连接在创建时，可单独的被指定为多线程模式或者串行模式，<strong>但是不能指定为单线程模式</strong>。</li>
<li>如果在编译时或启动时指定为单线程模式，就无法在创建连接时指定多线程或者串行模式。</li>
<li>创建连接时可以用sqlite3_open_v2()函数的第三个参数来指定线程模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQLITE_OPEN_NOMUTEX  //创建多线程模式的连接</span><br><span class="line">SQLITE_OPEN_FULLMUTEX  //创建串行模式的连接</span><br></pre></td></tr></table></figure>
<h5 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h5><p>要保证数据库使用的安全，一般可以采用如下几种模式</p>
<ul>
<li><code>SQLite</code> 采用<strong>单线程模型</strong>，用专门的线程/队列（同时只能有一个任务执行访问） 进行访问</li>
<li><code>SQLite</code> 采用多线程模型，每个线程都使用各自的数据库连接 （即 <code>sqlite3 *</code>）</li>
<li><code>SQLite</code> 采用串行模型，所有线程都公用同一个数据库连接。</li>
</ul>
<p>因为写操作的并发性并不好，当多线程进行访问时实际上仍旧需要互相等待，而读操作所需要的 <code>SHARED</code> 锁是可以共享的，所以为了保证最高的并发性，推荐</p>
<ul>
<li>使用多线程模式</li>
<li>使用 <code>WAL</code> 模式</li>
<li>单线程写，多线程读 （各线程都持有自己对应的数据库连接)</li>
<li>避免长时间事务</li>
<li>缓存 <code>sqlite3_prepare</code> 编译结果</li>
<li>多语句通过 <code>BEGIN</code> 和 <code>COMMIT</code> 做显示事务，减少多次的自动事务消耗</li>
</ul>
<p>参考 <a href="http://wereadteam.github.io/2016/08/19/SQLite/" target="_blank" rel="noopener">SQLite线程模式探讨</a></p>
<h4 id="五、FMDB"><a href="#五、FMDB" class="headerlink" title="五、FMDB"></a>五、FMDB</h4><h5 id="1、源码组成"><a href="#1、源码组成" class="headerlink" title="1、源码组成"></a>1、源码组成</h5><ul>
<li><strong>FMDatabase</strong> : 对sqlite3的封装，可以看做是sqlite3数据库操作实例，通过它可以对sqlite3进行增删改查等等操作。</li>
<li><strong>FMResultSet</strong> : FMDatabase执行查询之后的结果集。</li>
<li><strong>FMDatabaseAdditions</strong> : FMDatabase的Extension，新增对查询结果只返回单个值的方法进行简化，对表、列是否存在，版本号，校验SQL等等功能。</li>
<li><p><strong>FMDatabaseQueue</strong> : 使用GCD串行队列保证线程安全，所有的线程共用一个SQLite Handle(<strong>单句柄</strong>)，在多线程并发时，能够使各个线程的数据库操作按顺序同步进行，但正是因为各线程同步进行，导致后来的线程会被阻塞较长时间，无论是读操作还是写操作，都必须等待前面的线程执行完毕，使得性能无法得到更好的保障</p>
</li>
<li><p><strong>FMDatabasePool</strong> : 使用任务池的形式，对多线程的操作提供支持。（不过官方对这种方式并不推荐使用，优先选择FMDatabaseQueue的方式）</p>
</li>
</ul>
<h5 id="2、数据库创建和打开"><a href="#2、数据库创建和打开" class="headerlink" title="2、数据库创建和打开"></a>2、数据库创建和打开</h5><ul>
<li><p><code>FMDatabase</code>通过一个 SQLite 数据库文件路径创建的，此路径可以是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个文件的系统路径。磁盘中可以不存在此文件，因为如果不存在会自动为你创建。</span><br><span class="line">一个空的字符串 `@&quot;&quot;`。会在临时位置创建一个空的数据库，当 `FMDatabase` 连接关闭时，该数据库会被删除。</span><br><span class="line">NULL`。会在内存中创建一个数据库，当 `FMDatabase` 连接关闭时，该数据库会被销毁。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>FMDatabase</code>必须执行open，在这里才能正在创建并打开sqlite3对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FMDatabase *db = [FMDatabase databaseWithPath:dbpath];</span><br><span class="line">[db open];</span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line">//关闭</span><br><span class="line">[db close];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3、数据库查询"><a href="#3、数据库查询" class="headerlink" title="3、数据库查询"></a>3、数据库查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//数据库查询</span><br><span class="line">FMResultSet *rs = [db executeQuery:@&quot;select * from people&quot;];</span><br><span class="line">//利用next函数</span><br><span class="line">while ([rs next]) &#123;</span><br><span class="line">    NSLog(@&quot;%@ %@&quot;,[rs stringForColumn:@&quot;name&quot;],[rs stringForColumn:@&quot;age&quot;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>FMResultSet</code>通过调用 <code>-executeQuery...</code> 方法之一执行 <code>SELECT</code> 语句返回数据库查询结果<code>FMResultSet</code> 对象，然后就可以遍历查询结果了。</li>
</ul>
<h5 id="4、数据库更新"><a href="#4、数据库更新" class="headerlink" title="4、数据库更新"></a>4、数据库更新</h5><ul>
<li><p>SQL 语句中除过 <code>SELECT</code> 语句都可以称之为更新操作。包括 <code>CREATE</code>，<code>UPDATE</code>，<code>INSERT</code>，<code>ALTER</code>，<code>COMMIT</code>，<code>BEGIN</code>，<code>DETACH</code>，<code>DROP</code>，<code>END</code>，<code>EXPLAIN</code>，<code>VACUUM</code>，<code>REPLACE</code> 等。</p>
</li>
<li><p>执行更新语句后会返回一个 <code>BOOL</code> 值，返回 <code>YES</code> 表示执行更新语句成功，返回 <code>NO</code> 表示出现错误，可以通过调用 <code>-lastErrorMessage</code> 和 <code>-lastErrorCode</code> 方法获取更多错误信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建表</span><br><span class="line">[db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS people (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER DEFAULT 1)&quot;];</span><br><span class="line"></span><br><span class="line">//插入操作</span><br><span class="line">[db executeUpdate:@&quot;INSERT INTO people(name,age) VALUES (?,?)&quot;, @&quot;LiLei&quot;,[NSNumber numberWithInteger:28]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5、多线程数据库访问"><a href="#5、多线程数据库访问" class="headerlink" title="5、多线程数据库访问"></a>5、多线程数据库访问</h5><ul>
<li>FMDatabase 本身不是线程安全的，不要实例化一个 FMDatabase 单例来跨线程使用，但是可以通过FMDatabaseQueue保证跨线程操作是同步的，是线程安全的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *databaseQueue = [FMDatabaseQueue databaseQueueWithPath:dbpath];</span><br><span class="line">[databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        //</span><br><span class="line">    [db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS people (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER DEFAULT 1)&quot;];</span><br><span class="line"> &#125;];</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">           BOOL isSuccess = [db executeUpdate:@&quot;INSERT INTO people(name,age) VALUES (?,?)&quot;, @&quot;LiLei&quot;,[NSNumber numberWithInteger:28]];</span><br><span class="line">            if (isSuccess) &#123;</span><br><span class="line">                NSLog(@&quot;插入成功1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">            BOOL isSuccess = [db executeUpdate:@&quot;INSERT INTO people(name,age) VALUES (?,?)&quot;, @&quot;LiLei&quot;,[NSNumber numberWithInteger:28]];</span><br><span class="line">            if (isSuccess) &#123;</span><br><span class="line">                NSLog(@&quot;插入成功2&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>FMDatabaseQueue 将块代码 block 运行在一个串行队列上，即使在多线程同时调用 FMDatabaseQueue 的方法，它们仍然还是顺序执行。这种查询和更新方式不会影响其它，是线程安全的。</li>
</ul>
<h4 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h4><h5 id="1、GYDataCenter"><a href="#1、GYDataCenter" class="headerlink" title="1、GYDataCenter"></a>1、GYDataCenter</h5><ul>
<li><p>基于FMDB实现的ORM框架</p>
</li>
<li><p>具体参考<a href="https://wereadteam.github.io/2016/07/06/GYDataCenter/" target="_blank" rel="noopener">GYDataCenter：高性能数据库框架</a></p>
</li>
</ul>
<h5 id="2、WCDB"><a href="#2、WCDB" class="headerlink" title="2、WCDB"></a>2、WCDB</h5><ul>
<li>微信开源的移动端数据库组件，基于SQlite，支持ORM（Object Relational Mapping）(将一个ObjC的类，映射到数据库的表和索引,将类的property，映射到数据库表的字段）</li>
<li>具体参考 <a href="https://github.com/buaa0300/article/blob/master/%E5%BE%AE%E4%BF%A1%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%84%E4%BB%B6WCDB%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-iOS%E5%9F%BA%E7%A1%80%E7%AF%87.md" target="_blank" rel="noopener">微信移动端数据库组件WCDB系列（一）-iOS基础篇</a></li>
</ul>
<h5 id="3、Realm"><a href="#3、Realm" class="headerlink" title="3、Realm"></a>3、Realm</h5><ul>
<li>具体参考 <a href="https://www.jianshu.com/p/50e0efb66bdf" target="_blank" rel="noopener">Realm数据库 从入门到“放弃”</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2019/03/24/iOS-RAC01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/iOS-RAC01/" itemprop="url">ReactiveCocoa-信号基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T10:48:59+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS第三方库/" itemprop="url" rel="index">
                    <span itemprop="name">iOS第三方库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,092 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  13 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h4><p>ReactiveCocoa火了一段时间(大概15，16年)，在谈及MVVM的双向绑定时候，必然提及ReactiveCocoa，但是这几年，ReactiveCocoa似乎不怎么火了，之前没有用过，最近在一个项目中遇到，简单了解下。</p>
<h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><ul>
<li><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>（简称为RAC）,是一个开源的，可应用于iOS开发的<strong>函数式</strong> <strong>响应式</strong>编程框架，它提供了一系列用来组合和转换值流的 API</p>
</li>
<li><p>函数响应式编程（Functional reactive programming，简称FRP</p>
</li>
<li><p>RAC 5.0 对自身项目结构的也进行了大幅度的调整。这个调整就是将 RAC 拆分为四个库：ReactiveCocoa、ReactiveSwift、ReactiveObjC、ReactiveObjCBridge，Swift版本是ReactiveSwift，OC版本是ReactiveObjc。</p>
</li>
</ul>
<h5 id="2、编程思想"><a href="#2、编程思想" class="headerlink" title="2、编程思想"></a>2、编程思想</h5><ul>
<li><p><strong>面向过程</strong>：处理事情以过程为核心，一步一步的实现。</p>
</li>
<li><p><strong>面向对象</strong>:  万物皆对象</p>
</li>
<li><p><strong>链式编程</strong>：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好，代表作 : masonry</p>
</li>
<li><p><strong>响应式编程</strong>：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆流。代表KVO</p>
</li>
<li><p><strong>函数式编程思想</strong>：是把操作尽量写成一系列嵌套的函数或者方法调用</p>
</li>
</ul>
<p><strong>说明</strong>：<strong>ReactiveCocoa</strong>结合<strong>函数式编程</strong>（Functional Programming）和 <strong>响应式编程</strong>（Reactive Programming）编程思想，简记为 <strong>函数响应式</strong>编程（Functional reactive programming，简称FRP) ; 所以使用RAC时候，不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</p>
<h5 id="3、竞品"><a href="#3、竞品" class="headerlink" title="3、竞品"></a>3、竞品</h5><ul>
<li><p><strong>RxSwift</strong> 是 Rx的 Swift 版本，<strong>Rx</strong>是<strong>ReactiveX</strong>（Reactive Extensions）的简写，它致力于提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持.NET、JavaScript、C++、Swift, 但是没有支持Objective。</p>
</li>
<li><p><a href="https://github.com/meituan/EasyReact" target="_blank" rel="noopener">EasyReact</a> 美团18年开源的响应式编程框架，从官方纰漏信息说，比RAC性能更好 (<a href="https://www.raywenderlich.com/1190-reactivecocoa-vs-rxswift" target="_blank" rel="noopener">ReactiveCocoa vs RxSwift</a>)</p>
</li>
</ul>
<h4 id="二、信号RACSignal"><a href="#二、信号RACSignal" class="headerlink" title="二、信号RACSignal"></a>二、信号RACSignal</h4><p><strong>RACSignal是RAC的核心，RACSignal是RACStream子类。本质是是数据流，可以用来传递和绑定</strong>。</p>
<h5 id="1、基础操作"><a href="#1、基础操作" class="headerlink" title="1、基础操作"></a>1、基础操作</h5><ul>
<li><p><strong>创建信号</strong>（createSignal）：创建了一个 RACDynamicSignal 类型的信号，并将传入的代码块保存起来，留待以后调用。</p>
</li>
<li><p><strong>订阅信号</strong>（subscribeNext）：创建了一个 RACPassthroughSubscriber 类型的订阅者，并将传入的代码块保存起来，留待以后调用，同时调用了第一步创建信号中保存的代码块，并传入创建的订阅者。</p>
</li>
<li><p><strong>发送信号</strong>（sendNext）:执行订阅信号时对应的block</p>
</li>
<li><p><strong>取消订阅（disposable):</strong> 把订阅信号获得的disposable进行dispose，即可在调度器调度该部分代码之前禁止调用。</p>
</li>
</ul>
<h5 id="2、Code"><a href="#2、Code" class="headerlink" title="2、Code"></a>2、Code</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建信号</span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber ) &#123;</span><br><span class="line">        </span><br><span class="line">        //3.发送信号</span><br><span class="line">        [subscriber sendNext:@&quot;123&quot;];</span><br><span class="line">        //3.发送完成并取消订阅</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        </span><br><span class="line">        //4、用于取消订阅时清理资源用，比如释放资源</span><br><span class="line">        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            NSLog(@&quot;信号被取消订阅了&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 2.订阅信号</span><br><span class="line">    [signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">       </span><br><span class="line">        NSLog(@&quot;xxxx-%@&quot;,x);</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 2.订阅信号</span><br><span class="line">    [signal subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;yyyy-%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // xxxx-123</span><br><span class="line">	// 信号被取消订阅了</span><br><span class="line">	// yyyy-123</span><br><span class="line">	// 信号被取消订阅了</span><br></pre></td></tr></table></figure>
<h4 id="三、信号操作源码解读"><a href="#三、信号操作源码解读" class="headerlink" title="三、信号操作源码解读"></a>三、信号操作源码解读</h4><p><img src="https://upload-images.jianshu.io/upload_images/201701-e7bf63b105cdf58a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<h5 id="1、源码-创建信号"><a href="#1、源码-创建信号" class="headerlink" title="1、源码-创建信号"></a>1、源码-创建信号</h5><ul>
<li><strong>createSignal</strong>（<strong>创建信号</strong>）<strong>，实际上是创建 RACDynamicSignal 类型的信号，并把定义的</strong>block存储到<strong>didSubscribe</strong>。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-9c730e8e40ddaf05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="create.png">               </p>
<h5 id="2、源码-订阅信号"><a href="#2、源码-订阅信号" class="headerlink" title="2、源码-订阅信号"></a>2、源码-订阅信号</h5><p><strong>subscribeNext (订阅信号)</strong>分为两步：第一步<strong>创建一个订阅者subscriber，存入nextBlock,  </strong>第二步<strong>该subscriber订阅信号</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-c55b5d564d2439d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="subscribe.png">               </p>
<ul>
<li><strong>第一步代码如下</strong>：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-881dc25b7d62026e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="subscribe-next.png">               </p>
<ul>
<li><strong>第二步：有三个关键点</strong>，一个是<strong>创建一个RACCompoundDisposable</strong>对象，这里存储的是取消订阅后需要做的清除工作；另一个是 <strong>创建RACPassthroughSubscriber对象</strong>，将subscriber、信号和disposable处理存储下来，完成订阅者转换( 可以理解 RACPassthroughSubscriber 是订阅者的装饰器)。最后一个是使用在<strong>RACScheduler.subscriptionScheduler schedule:</strong> 来执行<strong>didSubscribe</strong>(这是创建信号穿过来的block), 最后返回RACCompoundDisposable对象</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-69b14dca5a123e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="subscribe-next2.png"></p>
<h5 id="3、源码-发送信号"><a href="#3、源码-发送信号" class="headerlink" title="3、源码-发送信号"></a>3、源码-<strong>发送信号</strong></h5><ul>
<li><p>在发送信号里，执行<strong>didSubscribe</strong>时候<strong>，</strong>传入的是<strong>RACPassthroughSubscriber</strong>对象，在执行sendNext: 时候，先执行<strong>RACPassthroughSubscriber对象的sendNext: 方法</strong>，</p>
</li>
<li><p>在这里<strong>：先检查disposable状态</strong>，如果已经disposed直接返回；没有disposed才调用内部的innerSubscriber的sendNext:方法（RACSubscriber对象方法）</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-66b346feb1e6c953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="send.png">               </p>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-1377630b1862cc71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="send2.png">               </p>
<p><strong>说明</strong>：</p>
<ul>
<li><p>发送信号就是执行相应block，此处执行的就是第二步中保存的<strong>相应的block</strong>。</p>
</li>
<li><p>对于 sendError 和 sendCompleted 都是<strong>先取消订阅，再执行相应的代码块</strong>，而 sendNext 并未<strong>取消</strong>订阅，所以，一般sendNext: 和 sendCompleted组合出现。</p>
</li>
</ul>
<h5 id="4、源码-取消订阅"><a href="#4、源码-取消订阅" class="headerlink" title="4、源码-取消订阅"></a>4、源码-取消订阅</h5><ul>
<li><p>在 执行sendCompleted后，<strong>RACPassthroughSubscriber</strong>对象执行dispose方法，完成整个过程</p>
</li>
<li><p>如果不调用sendCompleted，当订阅者被销毁的时候，<strong>RACPassthroughSubscriber</strong>对象也会执行dispose方法。</p>
</li>
</ul>
<h4 id="四、RACSubscriber-amp-RACDisposable"><a href="#四、RACSubscriber-amp-RACDisposable" class="headerlink" title="四、RACSubscriber &amp; RACDisposable"></a>四、RACSubscriber &amp; RACDisposable</h4><h5 id="1、RACSubscriber"><a href="#1、RACSubscriber" class="headerlink" title="1、RACSubscriber"></a>1、RACSubscriber</h5><ul>
<li><p><strong>订阅者协议</strong>，主要遵守这个协议，并且实现方法才能成为订阅者。设计者特意设计同名的RACSubscriber类，实现RACSubscriber协议</p>
</li>
<li><p><strong>RACSubscriber协议定义如下</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@protocol RACSubscriber &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">/// Sends the next value to subscribers.</span><br><span class="line">- (void)sendNext:(nullable id)value;</span><br><span class="line"></span><br><span class="line">/// Sends the error to subscribers.</span><br><span class="line">- (void)sendError:(nullable NSError *)error;</span><br><span class="line"></span><br><span class="line">/// Sends completed to subscribers.</span><br><span class="line">- (void)sendCompleted;</span><br><span class="line"></span><br><span class="line">/// Sends the subscriber a disposable that represents one of its subscriptions.</span><br><span class="line">- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>RACSubscriber类定义如下</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// A simple block-based subscriber.</span><br><span class="line">@interface RACSubscriber : NSObject &lt;RACSubscriber&gt;</span><br><span class="line"></span><br><span class="line">// Creates a new subscriber with the given blocks.</span><br><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>RACPassthroughSubscriber</strong>也是实现了RACSubscriber协议，而不是继承RACSubscriber类</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-73824afb1d8ac9db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RACPassthroughSubscriber.png">               </p>
<h5 id="2、RACDisposable及其子类"><a href="#2、RACDisposable及其子类" class="headerlink" title="2、RACDisposable及其子类"></a>2、RACDisposable及其子类</h5><ul>
<li><p>用于<strong>取消订阅</strong>或者<strong>清理资源</strong>，当信号发送完成 或者 发送错误的时候，就会自动触发它。</p>
</li>
<li><p><strong>使用场景</strong>:不想监听某个信号时，可以通过它主动取消订阅信号。</p>
</li>
<li><p>子类：RACCompoundDisposable、RACScopedDisposable、RACKVOTrampoline、RACSerialDisposable等。</p>
</li>
<li><p><strong>RACCompoundDisposable</strong>可以存放<strong>多个RACDisposable</strong> 。当RACCompoundDisposable 执行dispose方法时，它所存放的disposable都会被释放。</p>
</li>
</ul>
<h4 id="五、信号组合"><a href="#五、信号组合" class="headerlink" title="五、信号组合"></a>五、信号组合</h4><h5 id="1、concat"><a href="#1、concat" class="headerlink" title="1、concat"></a>1、concat</h5><p><strong>组合信号，让信号按照顺序去执行。</strong></p>
<p>模拟发送两个请求，第一个请求返回数据后执行第二个请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//创建一个信号A</span><br><span class="line">    RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;发送请求1...&quot;);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;请求1返回的数据&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            NSLog(@&quot;取消订阅1...&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //创建一个信号B</span><br><span class="line">    RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;发送请求2...&quot;);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;请求2返回的数据&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">           NSLog(@&quot;取消订阅2...&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //串联信号A和B</span><br><span class="line">    RACSignal *concatSignal = [signalA concat:siganlB];</span><br><span class="line">    [concatSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;value = %@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    output:</span><br><span class="line">	//发送请求1...</span><br><span class="line">	//value = 请求1返回的数据</span><br><span class="line">	//取消订阅1...</span><br><span class="line">	//发送请求2...</span><br><span class="line">	//value = 请求2返回的数据</span><br><span class="line">	//取消订阅2...</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：使用concat 连接信号时，第一个信号发送后，一定要执行<strong>sendCompleted</strong>方法，否则不会发送第二个信号。</p>
<h5 id="2、concat源码实现"><a href="#2、concat源码实现" class="headerlink" title="2、concat源码实现"></a>2、concat源码实现</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-7a5f43720da0d05f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="concat.png"></p>
<ul>
<li><p>当调用concat时，会创建一个<strong>拼接信号（RACDynamicSignal对象）</strong></p>
</li>
<li><p>当拼接信号被订阅，就会执行拼接信号的didSubscribe</p>
</li>
<li><p>在<strong>didSubscribe</strong>中会<strong>先订阅</strong>第一个信号（signalA），此时会执行第一个信号（signalA）的didSubscribe。</p>
</li>
<li><p>第一个信号（signalA）didSubscribe中，发送值，就调用第一个信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来。</p>
</li>
<li><p>第一个信号（signalA）didSubscribe中发送完成，<strong>就会调用第一个源信号（signalA）订阅者的completedBlock</strong>,订阅第二个源信号（signalB）这时候才激活（signalB）。</p>
</li>
<li><p>订阅第二个信号（signalB）,执行第二个源信号（signalB）的didSubscribe</p>
</li>
<li><p>第二个信号（signalB）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来.</p>
</li>
</ul>
<h5 id="3、then"><a href="#3、then" class="headerlink" title="3、then"></a>3、then</h5><p>用于连接连个信号，<strong>当第一个信号完成，才会连接then返回的信号</strong>，then底层也是使用了concat实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//创建信号A</span><br><span class="line">    RACSignal*signalA = [RACSignal createSignal:^RACDisposable*(id subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;send data A&quot;);</span><br><span class="line">        //发送信号</span><br><span class="line">        [subscriber sendNext:@&quot;dataA&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //创建信号B</span><br><span class="line">    RACSignal *signalB = [RACSignal createSignal:^RACDisposable*(id subscriber) &#123;</span><br><span class="line">        //发送请求</span><br><span class="line">        NSLog(@&quot;send data B&quot;);</span><br><span class="line">        //发送信号</span><br><span class="line">        [subscriber sendNext:@&quot;dataB&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    //创建组合信号</span><br><span class="line">    //then会忽略点第一个信号的所有值</span><br><span class="line">    RACSignal *signalThen = [signalA then:^RACSignal*&#123;</span><br><span class="line">        //返回的信号就是需要组合的信号，这里回将signalA信号忽略掉</span><br><span class="line">        return signalB;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //订阅信号</span><br><span class="line">    [signalThen subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //send data A</span><br><span class="line">    //send data B</span><br><span class="line">    //dataB</span><br></pre></td></tr></table></figure>
<h5 id="4、then源码实现"><a href="#4、then源码实现" class="headerlink" title="4、then源码实现"></a>4、then源码实现</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-64c023e296a0dd9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="then.png">            </p>
<ul>
<li><p>先过滤掉之前的信号发出的值。</p>
</li>
<li><p>使用concat连接then返回的信号</p>
</li>
</ul>
<h5 id="5、其他信号组合"><a href="#5、其他信号组合" class="headerlink" title="5、其他信号组合"></a>5、其他信号组合</h5><ul>
<li><p><strong>merge</strong>：把两个信号合并为一个信号，任何一个信号有新值的时候就会调用。</p>
</li>
<li><p><strong>zipWith</strong>：把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发事件。当一个界面有多个网络请求时，要等所有请求完成才更新UI，这时我们就可以用zipWith</p>
</li>
<li><strong>combineLatest</strong>：将<strong>多个信号合并起来，拿到各个信号的最新的值</strong>，每个合并的signal至少都有过一次sendNext,才会触发合并的信号，底层也是用 zipWith实现的。 一般拿来跟 reduce 一起使用。</li>
</ul>
<h4 id="六、应用"><a href="#六、应用" class="headerlink" title="六、应用"></a>六、应用</h4><p>老说源码比较枯燥，说下信号是怎么让开发变得更有意思。</p>
<h5 id="1、监听Control事件"><a href="#1、监听Control事件" class="headerlink" title="1、监听Control事件"></a>1、监听Control事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line"> [[self.btn1 rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *btn) &#123;</span><br><span class="line">     @strongify(self);</span><br><span class="line">     NSLog(@&quot;点击事件了&quot;);</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<h5 id="2、监听-textField-的-text-改变"><a href="#2、监听-textField-的-text-改变" class="headerlink" title="2、监听 textField 的 text 改变"></a>2、监听 textField 的 text 改变</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.textField.frame = CGRectMake(15, 200, 300, 40);</span><br><span class="line">    [[self.textField rac_textSignal] subscribeNext:^(NSString * _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;textField input = [%@]&quot;,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h5 id="3、把-label-的属性-text-绑定在-UITextField-上"><a href="#3、把-label-的属性-text-绑定在-UITextField-上" class="headerlink" title="3、把 label 的属性 text 绑定在 UITextField 上"></a>3、把 label 的属性 text 绑定在 UITextField 上</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//self.label1.text 随着 self.textField.text 的改变而改变</span><br><span class="line">RAC(self.label1,text) = self.textField.rac_textSignal;</span><br></pre></td></tr></table></figure>
<h5 id="4、告别繁琐的KVO"><a href="#4、告别繁琐的KVO" class="headerlink" title="4、告别繁琐的KVO"></a>4、告别繁琐的KVO</h5><ul>
<li>不需要手动移除了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(self.person, name) subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;name = %@&quot;,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h5 id="5、监听通知"><a href="#5、监听通知" class="headerlink" title="5、监听通知"></a>5、监听通知</h5><ul>
<li>不需要手动移除了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//监听通知</span><br><span class="line">   [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillChangeFrameNotification object:nil] subscribeNext:^(NSNotification * _Nullable notification) &#123;</span><br><span class="line">       NSLog(@&quot;-----%@&quot;, notification.description);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<h5 id="6、数组-amp-字典遍历"><a href="#6、数组-amp-字典遍历" class="headerlink" title="6、数组 &amp; 字典遍历"></a>6、数组 &amp; 字典遍历</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//数组遍历</span><br><span class="line">    NSLog(@&quot;array filter:&quot;);</span><br><span class="line">    NSArray *array = @[@(1), @(2), @(3), @(4), @(5)];</span><br><span class="line">    [array.rac_sequence.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;x = %@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;after array filter:&quot;);</span><br><span class="line">    //过滤 filter，并获取过滤后的数组</span><br><span class="line">    NSArray *filter = [[array.rac_sequence filter:^BOOL(id  _Nullable value) &#123;</span><br><span class="line">        return [value integerValue] &gt; 2;</span><br><span class="line">    &#125;] array];</span><br><span class="line">    </span><br><span class="line">    //</span><br><span class="line">    [filter.rac_sequence.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;y = %@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //匹配、映射 map，变换元素并获取新数组</span><br><span class="line">    NSArray *map = [[array.rac_sequence map:^id _Nullable(id  _Nullable value) &#123;</span><br><span class="line">         NSInteger a = [value integerValue] * [value  integerValue];</span><br><span class="line">        return [NSNumber numberWithInt:a];</span><br><span class="line">    &#125;] array];</span><br><span class="line">    </span><br><span class="line">     [map.rac_sequence.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        NSLog(@&quot;z = %@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //字典</span><br><span class="line">    NSDictionary *dic = @&#123;@&quot;name&quot;: @&quot;lion&quot;, @&quot;age&quot;: @18&#125;;</span><br><span class="line">    [dic.rac_sequence.signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">       </span><br><span class="line">        RACTupleUnpack(NSString *key, NSString *value) = x;</span><br><span class="line">        NSLog(@&quot;\r\nkey: %@\r\nvalue: %@&quot;, key, value);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;];​</span><br></pre></td></tr></table></figure>
<h5 id="7、按钮是否点击"><a href="#7、按钮是否点击" class="headerlink" title="7、按钮是否点击"></a>7、按钮是否点击</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 先联合两个信号，再解析信号结果，最后把结果绑定到信号上</span><br><span class="line">    RAC(self.btn1, enabled) = [RACSignal combineLatest:@[self.textField.rac_textSignal] reduce:^id _Nonnull(NSString *username)&#123;</span><br><span class="line">        return @(username.length &gt; 0);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h5 id="8、节流throttle"><a href="#8、节流throttle" class="headerlink" title="8、节流throttle"></a>8、节流throttle</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//节流(0.5 秒内 text 没有改变时，才会进行搜索请求)</span><br><span class="line">    [[[self.textField rac_textSignal] throttle:0.5] subscribeNext:^(NSString * _Nullable x) &#123;</span><br><span class="line">       //发送请求</span><br><span class="line">        NSLog(@&quot;开始搜索请求==%@&quot;, x);</span><br><span class="line">    &#125;]</span><br></pre></td></tr></table></figure>
<h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4><h5 id="1、总结"><a href="#1、总结" class="headerlink" title="1、总结"></a>1、总结</h5><ul>
<li>ReactiveCocoa提供了一个单一的、统一的方法去处理异步的行为，<strong>包括delegate方法,blocks回调,target-action机制,notifications和KVO.</strong></li>
<li><strong>冷信号和热信号</strong>：冷信号是被动的，只会在被订阅时向订阅者发送通知；热信号是主动的，它会在任意时间发出通知，与订阅者的订阅时间无关；也就是说冷信号所有的订阅者会在订阅时收到完全相同的序列；而订阅热信号之后，只会收到在订阅之后发出的序列。</li>
</ul>
<h5 id="2、参考"><a href="#2、参考" class="headerlink" title="2、参考"></a>2、参考</h5><p><a href="https://blog.csdn.net/yutaotst/article/details/58608829" target="_blank" rel="noopener">iOS Reactivecocoa（RAC）知其所以然</a></p>
<p><a href="https://yyn835314557.github.io/ios/2015/10/07/iOS-ReactiveCocoa%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">iOS ReactiveCocoa详解</a></p>
<p><a href="https://www.jianshu.com/p/912c69dfb55a" target="_blank" rel="noopener">ReactiveCocoa信号发送详解</a></p>
<p><a href="https://juejin.im/entry/58b2f26aac502e0069d9ff42" target="_blank" rel="noopener">RAC 之引起你的兴趣</a></p>
<p><a href="https://www.jianshu.com/p/912c69dfb55a" target="_blank" rel="noopener">ReactiveCocoa信号发送详解</a></p>
<p><a href="https://www.jianshu.com/p/a027898612e6" target="_blank" rel="noopener">ReactiveCocoa代码分析之UITextField</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2019/03/13/iOS-PicDecode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/iOS-PicDecode/" itemprop="url">图片解码小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T12:56:46+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,308 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>KeyPoints</strong></p>
<ul>
<li><p>图片如何显示到屏幕上的</p>
</li>
<li><p>为什么要图片解码</p>
</li>
<li><p>图片解码方案及其对比</p>
</li>
</ul>
<h4 id="一、图像知识"><a href="#一、图像知识" class="headerlink" title="一、图像知识"></a>一、图像知识</h4><h5 id="1、图片"><a href="#1、图片" class="headerlink" title="1、图片"></a>1、图片</h5><ul>
<li><p>计算机能以<strong>矢量图</strong>(vector)或<strong>位图</strong>(bitmap)格式显示图像，其中<strong>矢量图</strong> 使用线段和曲线描述图像，同时图像还包含了<strong>色彩</strong>和<strong>位置</strong>信息；而<strong>位图</strong> 使用像素点来描述图像，也称为点阵图像，位图图片格式有RGB、CMYK等颜色模式；其中RGB是最常用的颜色模式，它通过红(R)、绿(G)、蓝(B)三个颜色通道的数值表示颜色。手机显示屏使用自带Aphal通道(<strong>RGBA</strong>)的<strong>RGB32</strong>格式。</p>
</li>
<li><p>我们平时接触到的JPG或PNG图片格式，他们是<strong>压缩的位图</strong>图形格式，其中 PNG 图片是<strong>无损压缩</strong>，并且支持 alpha 通道，而 JPEG 图片则是<strong>有损压缩</strong>，可以指定 0-100% 的压缩比。JPG或PNG图片显示到屏幕之前，需要将JPG/PNG格式的图片<strong>解码</strong>成<strong>位图图像。</strong></p>
</li>
</ul>
<h5 id="2、16位色、24位色、32位色、真彩色"><a href="#2、16位色、24位色、32位色、真彩色" class="headerlink" title="2、16位色、24位色、32位色、真彩色"></a>2、16位色、24位色、32位色、真彩色</h5><ul>
<li><p>16位色表示描绘图像时有<strong>2^16种颜色可供选择， 颜色</strong>总数65536。</p>
</li>
<li><p>24位色表示描绘图像时有<strong>2^24</strong>种颜色可供选择；颜色总数是16777216。通常也被简称为1600万色或千万色；24位色被称为真彩色，它可以达到人眼分辨的极限</p>
</li>
<li><p>32位色在1677万多色基础上，不过它增加了256阶颜色的灰度，为了方便称呼，就规定它为32位色。</p>
</li>
<li><p>真彩色指用三个或更多字节描述颜色，24位色、32位色都是真彩色。</p>
</li>
</ul>
<h5 id="3、动图GIF"><a href="#3、动图GIF" class="headerlink" title="3、动图GIF"></a>3、动图GIF</h5><ul>
<li><p>GIF格式的图像只有256种颜色用以描绘图片，并且只能通过抖动、差值等方式模拟较多丰富的颜色。</p>
</li>
<li><p>GIF的alpha通道只有1bit，一个像素要么完全透明，要么完全不透明，而不像现在PNG的RGBA的8bit alpha通道，alpha值也可以和RGB一样都有255个透明值。</p>
</li>
<li><p>所有GIF的图片带上透明度以后，边缘会出现明显的锯齿。如果客户端需要展示带透明度的动图，不考虑GIF。</p>
</li>
</ul>
<h4 id="二、iOS背景知识"><a href="#二、iOS背景知识" class="headerlink" title="二、iOS背景知识"></a>二、iOS背景知识</h4><h5 id="1、图像显示到屏幕"><a href="#1、图像显示到屏幕" class="headerlink" title="1、图像显示到屏幕"></a>1、图像显示到屏幕</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-60465ee3a4d45e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<p>图像显示到屏幕上，是CPU和GPU协作完成渲染的。具体工作如下:</p>
<ul>
<li><p><strong>CPU</strong>: 计算视图frame，图片解码，需要绘制纹理图片通过数据总线交给GPU</p>
</li>
<li><p><strong>GPU</strong>: 纹理混合，顶点变换与计算,像素点的填充计算，渲染到帧缓冲区。</p>
</li>
<li><p><strong>时钟信号</strong>：垂直同步信号V-Sync / 水平同步信号H-Sync。</p>
</li>
<li><p><strong>iOS设备双缓冲机制</strong>：显示系统通常会引入两个帧缓冲区，双缓冲机制</p>
</li>
</ul>
<h5 id="2、图片的显示流程"><a href="#2、图片的显示流程" class="headerlink" title="2、图片的显示流程"></a>2、图片的显示流程</h5><ul>
<li><p>假设本地从本地加载一张图片，将值赋给UIImageView</p>
</li>
<li><p>一次Runloop结束后，CATransaction遍历所有layer的contents(寄宿图)，发现UIImageView layer的contents的变化(CGImage类型)；</p>
</li>
<li><p>发现图片不是位图，解码成位图；</p>
</li>
<li><p>如果图像数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐；</p>
</li>
<li><p>Core Animation提交渲染树CA::render::<strong>commit</strong>，将渲染任务和数据交给Render server线程去处理；</p>
</li>
<li><p>Render server调用Open GL、Core Graphics相关程序,最终由GPU完成图像渲染并显示到屏幕。</p>
</li>
</ul>
<p><strong>说明</strong>：图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</p>
<h5 id="3、为什么要解压图片"><a href="#3、为什么要解压图片" class="headerlink" title="3、为什么要解压图片"></a>3、为什么要解压图片</h5><ul>
<li><p>JPEG 和 PNG 图片是位图的压缩格式</p>
</li>
<li><p>本质上，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点</p>
</li>
<li><p>将磁盘中/网络上获取的 图片渲染到屏幕之前，必须<strong>先要得到图片的原始像素数据</strong>，才能执行后续的绘制操作。</p>
</li>
</ul>
<p><strong>参考</strong>：<a href="https://www.jianshu.com/p/4008ec3cacaa" target="_blank" rel="noopener">https://www.jianshu.com/p/4008ec3cacaa</a></p>
<h4 id="三、Image-I-O-iOS图片解码方案"><a href="#三、Image-I-O-iOS图片解码方案" class="headerlink" title="三、Image I/O: iOS图片解码方案"></a>三、Image I/O: iOS图片解码方案</h4><h5 id="1、Image-I-O是什么"><a href="#1、Image-I-O是什么" class="headerlink" title="1、Image I/O是什么"></a>1、Image I/O是什么</h5><ul>
<li><p>Image/IO是Apple提供的一套用于<strong>图片编码解码</strong>的系统库，详细参考 <a href="http://link.zhihu.com/?target=https%3A//developer.apple.com/documentation/imageio" target="_blank" rel="noopener">Apple Image/IO</a></p>
</li>
<li><p>Image/IO的解码，支持了常见的图像格式，包括PNG（包括APNG）、JPEG、GIF、BMP、TIFF（具体的，可以通过CGImageSourceCopyTypeIdentifiers来打印出来，不同平台不完全一致）。在iOS 11之后另外支持了HEIC（即使用了HEVC编码的HEIF格式）；</p>
</li>
<li><p>Image/IO支持的解码和编码格式可通过以下方法查询</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)printImageSupportTypes &#123;</span><br><span class="line">	CFArrayRef mySourceTypes = CGImageSourceCopyTypeIdentifiers();</span><br><span class="line">    //支持解码的图片格式</span><br><span class="line">    CFShow(mySourceTypes);</span><br><span class="line">    </span><br><span class="line">    //支持编码的图片格式</span><br><span class="line">    CFArrayRef myDestinationTypes = CGImageDestinationCopyTypeIdentifiers();</span><br><span class="line">    CFShow(myDestinationTypes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2、解码流程"><a href="#2、解码流程" class="headerlink" title="2、解码流程"></a>2、解码流程</h5><ul>
<li><strong>静态图（PNG、JPG）解码流程</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建CGImageSource</span><br><span class="line">读取图像格式元数据（可选）</span><br><span class="line">**解码得到CGImage**</span><br><span class="line">CGImage转成UIImage，资源清理</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>动态图(GIF、APNG)解码流程</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态图的步骤1</span><br><span class="line">遍历所有图像帧，重复静态图的步骤2-4</span><br><span class="line">生成动图UIImage</span><br></pre></td></tr></table></figure>
<h5 id="3、解码关键API"><a href="#3、解码关键API" class="headerlink" title="3、解码关键API"></a>3、解码关键API</h5><ul>
<li><p><strong>CGImageSourceCreateWithData</strong>：从一个内存中的二进制数据（CGData）中创建ImageSource。ImageSource代表一个待解码数据，还可以通过CGImageSourceCreateWithURL、CGImageSourceCreateWithDataProvider分别从URL、DataProvide中创建ImageSource，DataProvider提供了很多种输入，包括内存，文件，网络，流等。很多CG的接口会用到这个来避免多个额外的接口。</p>
</li>
<li><p><strong>CGImageSourceCreateImageAtIndex</strong>: 获取<strong>CGImage</strong>，对于静态图来说，index始终是0。</p>
</li>
</ul>
<h5 id="4、动态图解码Demo"><a href="#4、动态图解码Demo" class="headerlink" title="4、动态图解码Demo"></a>4、动态图解码Demo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CGImageSourceRef source = **CGImageSourceCreateWithData**((__bridge CFDataRef)data, NULL);</span><br><span class="line">if (!source) &#123; // 一般这时候都是输入图像数据的格式不支持</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">NSUInteger frameCount = CGImageSourceGetCount(source); //帧数</span><br><span class="line">NSMutableArray &lt;UIImage *&gt; *images = [NSMutableArray array];</span><br><span class="line">double totalDuration = 0;</span><br><span class="line">for (size_t i = 0; i &lt; frameCount; i++) &#123;</span><br><span class="line">    NSDictionary *frameProperties = (__bridge NSDictionary *) CGImageSourceCopyPropertiesAtIndex(source, i, NULL);</span><br><span class="line">    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary]; // GIF属性字典</span><br><span class="line">    double duration = [gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime] doubleValue]; // GIF原始的帧持续时长，秒数</span><br><span class="line">    CGImagePropertyOrientation exifOrientation = [frameProperties[(__bridge NSString *)kCGImagePropertyOrientation] integerValue]; // 方向</span><br><span class="line">    CGImageRef imageRef = **CGImageSourceCreateImageAtIndex**(source, i, NULL); // CGImage</span><br><span class="line">    UIImageOrientation imageOrientation = [self imageOrientationFromExifOrientation:exifOrientation];</span><br><span class="line">    UIImage *image = [[UIImage imageWithCGImage:imageRef scale:[UIScreen mainScreen].scale orientation:imageOrientation];</span><br><span class="line">    totalDuration += duration;</span><br><span class="line">    [images addObject:image];</span><br><span class="line">&#125;</span><br><span class="line">// 最后生成动图</span><br><span class="line">UIImage *animatedImage = [UIImage animatedImageWithImages:images duration:totalDuration];</span><br></pre></td></tr></table></figure>
<h5 id="5、说明"><a href="#5、说明" class="headerlink" title="5、说明"></a>5、说明</h5><ul>
<li><p>Image/IO所有的方法都是线程安全的，而且基本上也都是同步的；</p>
</li>
<li><p>通过CGImageSourceCreateImageAtIndex生成的CGImage，其实它的Bitmap还没有立即创建，他只是一个包含了一些<strong>元信息的空壳Image</strong>。这个CGImage，在最终需要获取它的Bitmap Buffer的时候（即，通过相应的API，如CGDataProviderCopyData，CGDataProviderRetainBytePtr），<strong>才会触发最后的Bitmap Buffer的创建和内存分配；</strong></p>
</li>
<li><p>图片的解码默认发生在主线程，在图片多或图片过大的情况下，第一次加载会导致滚动帧率下滑，后续帧率会好些，解码完成后的Bitmap Buffer会复用；</p>
</li>
<li><p>Image/IO是Appple提供的<strong>图片编码解码库，使用简单，性能也有保证，</strong> 但是对于不支持的格式如webp，编解码是无能为力。</p>
</li>
</ul>
<h4 id="四、子线程解码方案"><a href="#四、子线程解码方案" class="headerlink" title="四、子线程解码方案"></a>四、子线程解码方案</h4><h5 id="1、空间换时间"><a href="#1、空间换时间" class="headerlink" title="1、空间换时间"></a>1、空间换时间</h5><ul>
<li><p>通过CGContext创建一个位图画布 <strong>CGBitmapContextCreate</strong></p>
</li>
<li><p>通过<strong>CGContextDrawImage</strong>绘制位图，CGContextDrawImage在执行过程中会触发Image/IO进行解码并分配Bitmap内存。得到的产物用来真正产出一个CGImage-based的UIImage，交由UIImageView渲染。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        BOOL hasAlpha = NO;</span><br><span class="line">        if (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        // BGRA8888 (premultiplied) or BGRX8888</span><br><span class="line">        // same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        CGContextRef context = **CGBitmapContextCreate**(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">        if (!context) return NULL;</span><br><span class="line">        **CGContextDrawImage**(context, CGRectMake(0, 0, width, height), imageRef); // decode</span><br><span class="line">        CGImageRef newImage = **CGBitmapContextCreateImage**(context);</span><br><span class="line">        CFRelease(context);</span><br><span class="line">        return newImage;</span><br></pre></td></tr></table></figure>
<h5 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h5><ul>
<li><p>可以提升图第一次渲染到屏幕上的性能和滚动帧率; </p>
</li>
<li><p>因为解码后的位图要保留在内存中，会给内存带来压力，要注意内存的清理;</p>
</li>
<li><p>注意控制处理图片解码的子线程数量，子线程过多同样会影响性能。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解码后的图像大小和图片的宽高像素有关，宽高像素越大，位图图像就越大。假设一个3MB的图片，其宽高像素为2048 * 2048 的图片，解码后的位图图像大小是16MB（2048 * 2048 * 4）</span><br></pre></td></tr></table></figure>
<h5 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h5><ul>
<li><p>SDWebImage中有两个解码方法decodedImageWithImage 和 decodedAndScaledDownImageWithImage ，分别对应处理普通图，大图（默认位图大小超过60MB），对于大图，建议使用后者。其主要思路是：将大的原图切块，按块缩放成指定大小的图片填充到目标图片中去。</p>
</li>
<li><p>Apple大大没有采用此类方案，猜测原因是：因为早期设备内存有限，UIKit整套渲染机制很多地方采用时间换空间的策略。</p>
</li>
<li><p>现在，大部分业务使用的是小图，大图的场景少，导致SDWebImage这类子线程解码方案很欢迎，内存开销比较稳定，性能也能提升。</p>
</li>
</ul>
<h4 id="五、后续"><a href="#五、后续" class="headerlink" title="五、后续"></a>五、后续</h4><ul>
<li><p>子线程解码最终还是利用Image I/O解码，对于Image I/O不支持的图片格式，第三方解码方案？</p>
</li>
<li><p>图片编解中遇到的图像方面的知识</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2019/02/21/iOS-iOSDesignMode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/iOS-iOSDesignMode/" itemprop="url">iOS架构小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T22:29:49+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS进阶/" itemprop="url" rel="index">
                    <span itemprop="name">iOS进阶</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,922 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h5><ul>
<li>谈及iOS的架构，绕不开组件化、MVC、MVVM这些关键词</li>
<li>对于几个人的小团队，组件化未必是适合的方案，当然遇到业务扩张，新App需要落地，将相同的功能沉库，可以汲取组件化的精髓，提高生产效率。</li>
<li>组件化是大中型App团队的选择。</li>
<li>对于百人以上的客户端超级大团队，组件化非常值得拥有，当然实施起来也非常复杂，包括业务划分，业务组件和基础组件的设计和开发、测试、集成和发版。</li>
</ul>
<h5 id="2、MVC和MVVM"><a href="#2、MVC和MVVM" class="headerlink" title="2、MVC和MVVM"></a>2、MVC和MVVM</h5><ul>
<li>好像一说起Controller代码臃肿，就把锅求给MVC，就鼓吹MVVM，其实MVC虽然有明显的缺点，但是合理使用，绝对满足大部分需求，造成代码的臃肿和难以管理，很大原因和开发者认知有关系。</li>
<li>MVVM可以用，使用MVVM不必要一定引入RAC,</li>
</ul>
<h5 id="3、组件化"><a href="#3、组件化" class="headerlink" title="3、组件化"></a>3、组件化</h5><ul>
<li><strong>业务快速发展、复杂的业务场景、团队的快速扩张等</strong>带来的变革诉求，希望通过<strong>组件化</strong>来提高团队的协作能力、减低开发成本，提高开发质量。</li>
<li>组件化直接效果：代码解耦，功能模块化；代码的复用性高；代码管理更加科学。</li>
<li>从<strong>蘑菇街</strong>(<a href="https://www.jianshu.com/p/cdf94a963c27" target="_blank" rel="noopener">蘑菇街 App 的组件化之路</a>)、<strong>支付宝(<a href="http://www.sohu.com/a/129493438_536622" target="_blank" rel="noopener">从支付宝红包揭秘亿级APP的移动开发</a>)</strong>等团队公开的信息来看：业务的增加、开发团队的扩张、快速迭代的要求，催生组件化方案(<em>可能有更好的架构方案</em>)快速落地。</li>
<li>蘑菇街和支付宝等团队实现组件化方案，一是业务发展的必然选择；二是其技术沉淀深，能为自己和兄弟团队打造出质量上乘的组件化服务。</li>
</ul>
<h4 id="二、组件化实施"><a href="#二、组件化实施" class="headerlink" title="二、组件化实施"></a>二、组件化实施</h4><h5 id="1、实施步骤"><a href="#1、实施步骤" class="headerlink" title="1、实施步骤"></a>1、实施步骤</h5><ul>
<li>剥离产品公共库和基础库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将网络请求、数据存储、图片下载和存储、第三方SDK(微信，支付宝)、UI基础组件、自定义相机等、UIKit和Foundation的扩展等，拆分出来，各自沉库，使用cocopods管理。</span><br></pre></td></tr></table></figure>
<ul>
<li>独立业务模块单独成库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将登录、分享、支付、日志上报等模块封装成组件，也可以将一些通用模块，如资讯详情页、XX模块拆分出来，拆分粒度可以先粗后细，将相对独立的功能封装成组件，统一对外提供服务，保证体验一致性。</span><br></pre></td></tr></table></figure>
<ul>
<li>对外服务最小化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在前两步都完成的情况下，根据组件被调用的需求来抽象出组件对外的最小化接口(遵循SOLID原则中的接口分离原则)</span><br></pre></td></tr></table></figure>
<h5 id="2、组件通信"><a href="#2、组件通信" class="headerlink" title="2、组件通信"></a>2、组件通信</h5><p>组件之间的通信，更多是指业务组件之间的通信吧。目前蘑菇街团队公开的方案是：<strong>URLRouter</strong>、<strong>Protocol Class Binding</strong>和<strong>Target-Action</strong>这三类方案。</p>
<h6 id="1）URLRouter"><a href="#1）URLRouter" class="headerlink" title="1）URLRouter"></a>1）URLRouter</h6><ul>
<li><p><strong>简介</strong>：蘑菇街团队实现<a href="https://github.com/meili/MGJRouter" target="_blank" rel="noopener">MGJRouter</a>库，可以根据URL处理执行对应的Block；其核心在于，先注册URL 和 <strong>服务Block</strong> &amp; <strong>参数字典</strong>的对应关系（<em>保存在router字典中</em>），然后利用URL找到对应的Block，将参数字典交给Block，唤起对应的服务。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 注册</span><br><span class="line">[MGJRouter registerURLPattern:@&quot;mgj://foo/bar&quot; toHandler:^(NSDictionary *routerParameters) &#123;</span><br><span class="line">[self appendLog:[NSString stringWithFormat:@&quot;routerParameters:%@&quot;, routerParameters]];</span><br><span class="line">      &#125;];</span><br><span class="line"></span><br><span class="line">//传参</span><br><span class="line">[MGJRouter openURL:@&quot;mgj://foo/bar&quot; withUserInfo:@&#123;@&quot;param1&quot;:@&quot;hello world&quot;&#125; completion:nil];</span><br><span class="line"></span><br><span class="line">//同步获取object</span><br><span class="line">NSNumber *orderCount = [MGJRouter objectForURL:@&quot;mgj://cart/ordercount&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优势</strong>：解耦方便；各个组件依赖MGJRouter就可以；打破组件间的相互依赖；</p>
</li>
<li><p><strong>不足</strong>：组件本身依赖中间件，但是分散注册又使得<strong>耦合较多</strong>。<br>需要专门维护URL(<em>蘑菇街使用后台维护，自动生成URL短链的方式</em>)；</p>
</li>
<li><p><strong>补充</strong>：<a href="https://github.com/meili/MGJRouter" target="_blank" rel="noopener">MGJRouter</a>是URL Router的OC版本实现，<a href="https://github.com/devxoul/URLNavigator" target="_blank" rel="noopener">URLNavigator</a>是URL Router的Swift版本实现，核心都是：注册URL和对应的处理，然后根据URL解析去做事情，如页面跳转。</p>
</li>
</ul>
<h6 id="2）Protocol-Class-Binding-协议和类绑定"><a href="#2）Protocol-Class-Binding-协议和类绑定" class="headerlink" title="2）Protocol Class Binding(协议和类绑定)"></a>2）Protocol Class Binding(协议和类绑定)</h6><ul>
<li><p><strong>简介</strong>：核心在于，为组件定义Protocol，Protocol指定返回的数据，然后在组件中新建Class实现Protocol，如此将Protocol和Class关联起来。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//以购物车组件为例</span><br><span class="line">//1、组件定义MGJCart，执行返回订单数方法</span><br><span class="line">@protocol MGJCart &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (NSInteger)orderCount;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//2、MGJCartImpl 实现MGJCart ，实现略</span><br><span class="line">   	   </span><br><span class="line">//3、关联</span><br><span class="line">[ModuleManager registerClass:MGJCartImpl forProtocol:@protocol(MGJCart)]，</span><br><span class="line">	</span><br><span class="line"> //4、获取MGJCartImpl，接下来可以访问到参数了</span><br><span class="line">[ModuleManager classForProtocol:@protocol(MGJCart)]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优势</strong>：把公共的协议统一放到同一文件中，组件依赖该文件即可。</p>
</li>
<li><p><strong>补充</strong>：阿里的beehive属于此类方案实现，具体参考<a href="https://halfrost.com/beehive/" target="_blank" rel="noopener">BeeHive —— 一个优雅但还在完善中的解耦框架</a>，核心思想涉及：各个模块间从直接调用对应模块，变成以Service的形式，避免了直接依赖；App生命周期的分发，将耦合在AppDelegate中的逻辑拆分，每个模块以微应用的形式独立存在。</p>
</li>
</ul>
<h6 id="3）Target-Action方案"><a href="#3）Target-Action方案" class="headerlink" title="3）Target-Action方案"></a>3）Target-Action方案</h6><ul>
<li><strong>简介</strong>: <a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">CTMediator</a>方案，在此类中对外提供明确参数类型的接口，接口内部通过performTarget方法调用服务方组件的Target、Action。由于CTMediator类的调用是通过runtime主动发现服务的，所以服务方对此类是完全解耦的。但如果CTMediator类对外提供的方法都放在此类中，将会对CTMediator造成极大的负担和代码量。解决方法就是对每个服务方组件创建一个CTMediator的Category，并将对服务方的performTarget调用放在对应的Category中，这些Category都属于CTMediator中间件，从而实现了感官上的接口分离。</li>
<li><strong>特点</strong>: 侵入小，但硬编码较多，Runtime编译阶段不检查,运行时才检查对应类或者方法是否存在，对开发要求较高。</li>
</ul>
<h5 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h5><p>需要一个组件的管理平台，管理这些组件的单元测试、集成和发版</p>
<p>参考文章：<a href="https://www.jianshu.com/p/48fbcbb36c75" target="_blank" rel="noopener">iOS App组件化开发实践</a>、<a href="http://cocoafei.top/2018/06/iOS%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/#3_2" target="_blank" rel="noopener">iOS组件化方案选型</a></p>
<h4 id="三、MVC"><a href="#三、MVC" class="headerlink" title="三、MVC"></a>三、MVC</h4><h5 id="1、苹果推荐的MVC"><a href="#1、苹果推荐的MVC" class="headerlink" title="1、苹果推荐的MVC"></a>1、苹果推荐的MVC</h5><ul>
<li>我们常说的MVC主要包括以下三部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制器（Controller）- 数据的加工者</span><br><span class="line">视图（View） - 数据显示</span><br><span class="line">模型（Model）- 数据管理</span><br></pre></td></tr></table></figure>
<ul>
<li>在苹果推荐的MVC中，<strong>View和Model是没有通信的</strong>，但是Controller可以Model和View通信；</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-77b1b371629ba8d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="MVC"></p>
<ul>
<li>Controller是可以直接访问Model，然后Model不知道Controller是谁，当Model发生变化时候，利用通知、代理或KVO等方式通知Controller</li>
<li><p>Controller也可以直接访问View，Controller可以直接根据Model来决定View的展示。View接收到响应事件, 通过delegate、target-action、block等方式告诉Controller的状态变化。Controller进行业务的处理，然后再控制View的展示。</p>
</li>
<li><p>随着Controller和Model、View的交互(通信)越来越多，Controller中的代码就越来越多，造成Controller中代码过于臃肿。</p>
</li>
</ul>
<h5 id="2、MVC的优化实践"><a href="#2、MVC的优化实践" class="headerlink" title="2、MVC的优化实践"></a>2、MVC的优化实践</h5><ul>
<li>MVC是非常经典的设计模式，虽然有很多问题，但是使用得当的话，其实能搞定大部分项目。很多时候，代码的臃肿很大原因是开发者代码不规范造成的，比如将网络请求逻辑，数据的存储逻辑都放在Controller中，或者Controller中展示聚集太多的UI元素，这如何不造成Controller的代码臃肿呢。</li>
<li>在使用MVC模式，需要划分好MVC的职责</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Model应该做的事：</span><br><span class="line">1.给ViewController提供数据</span><br><span class="line">2.给ViewController存储数据提供接口</span><br><span class="line">3.提供经过抽象的业务基本组件，供Controller调度</span><br><span class="line"></span><br><span class="line">Controller应该做的事：</span><br><span class="line">1.管理View Container的生命周期</span><br><span class="line">2.负责生成所有的View实例，并放入View Container</span><br><span class="line">3.监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。</span><br><span class="line"></span><br><span class="line">View应该做的事：</span><br><span class="line">1.响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。</span><br><span class="line">2.界面元素表达</span><br></pre></td></tr></table></figure>
<ul>
<li>对软件结构做好分层，将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。</li>
</ul>
<h4 id="四、MVVM"><a href="#四、MVVM" class="headerlink" title="四、MVVM"></a>四、MVVM</h4><h5 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-7584653944d3e889.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="MVVM.png"></p>
<ul>
<li>在MVVM中，将和视图、数据的交互处理从Controller中移到ViewModel中；VM负责和Model通信，可以直接访问Model，当Model改变时候通知VM；同时，VM负责和视图的通信，直接访问视图，当视图接收到响应事件时，通知VM去处理。而Controller仅仅是协调各个部分的绑定关系以及必要的逻辑处理。</li>
<li>MVVM的核心是：<strong>实现MVVM的双向绑定</strong>，很多项目组因此引入RAC框架(函数响应式框架)，其实使用KVO机制也可以实现双向绑定也可以，直接使用KVO，会有一些问题，建议直接使用facebook的KVOController</li>
</ul>
<h5 id="2、MVVM和MVC的对比"><a href="#2、MVVM和MVC的对比" class="headerlink" title="2、MVVM和MVC的对比"></a>2、MVVM和MVC的对比</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-ea78e2837ecc0db4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="mvvm和mvc.png"></p>
<ul>
<li><strong>MVVM优点</strong>：方便测试，VM可以方便做单元测试，MVC下的Controller里面逻辑太多，无法做单元测试；耦合度低； 复用性高； 层次更清晰； 重构成本低；</li>
<li><strong>MVVM缺点</strong>：类文件增多(每个VC多一个ViewModel)，ViewModel的代码复杂度增大(处理各种交互)</li>
<li><strong>MVC优点</strong>：通用架构； 处理耦合度高的逻辑方便； </li>
<li><strong>MVC缺点：</strong> 耦合度高； 复用性差； 测试性差；</li>
</ul>
<h5 id="3、补充个MVP"><a href="#3、补充个MVP" class="headerlink" title="3、补充个MVP"></a>3、补充个MVP</h5><ul>
<li>MVP分别是<strong>Mode</strong>、<strong>View</strong>和<strong>Presenter</strong>，对应数据<strong>、</strong>视图<strong>和</strong>主持者，在Android开发中使用普遍。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-7fdab1dde3415a38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="MVP.png"></p>
<ul>
<li>MVC模式下，Android的Activity承担繁杂的业务逻辑，导致代码臃肿，使用MVP模式，将View层和Mode层隔离开，增加Presenter层，作为Mode层和View层通讯的桥梁</li>
<li>Presenter同时持有Mode层和View层的引用，在需要数据改变 或 视图显示时直接改变数据或者视图的显示状态。同样View层持有Presenter层的引用，这样就能将一些处理事件的逻辑放在Presenter层中进行处理，处理完成后通知View层改变显示状态。</li>
<li>具体参考 <a href="https://juejin.im/post/5a61559051882573351a5fb6" target="_blank" rel="noopener">MVP模式的经典封装</a></li>
</ul>
<h4 id="五、SOLD原则"><a href="#五、SOLD原则" class="headerlink" title="五、SOLD原则"></a>五、SOLD原则</h4><h5 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h5><ul>
<li>根据项目的复杂度来决定选择MVC或MVVM，但是无论哪种模式，都做好代码设计，结构分层，类设计遵守SOLID原则</li>
</ul>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>中文</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>The Single Responsibility Principle</td>
<td>单一责任原则</td>
<td>一个类只应承担一种责任</td>
</tr>
<tr>
<td>O</td>
<td>The Open Closed Principle</td>
<td>开放封闭原则</td>
<td>可扩展，不可修改</td>
</tr>
<tr>
<td>L</td>
<td>Liskov Substitution Principle</td>
<td>里氏替换原则</td>
<td>子类可以在任意地方替换基类且软件功能不受影响</td>
</tr>
<tr>
<td>I</td>
<td>The Interface Segregation Principle</td>
<td>接口分离原则</td>
<td>将接口拆分成更小和更具体的接口，有助于解耦</td>
</tr>
<tr>
<td>D</td>
<td>The Dependency Inversion Principle</td>
<td>依赖倒置原则</td>
<td>一个方法应该遵从“依赖于抽象而不是一个实例”。依赖注入 是该原则的一种实现方式。</td>
</tr>
</tbody>
</table>
<h5 id="2、IOC和DI"><a href="#2、IOC和DI" class="headerlink" title="2、IOC和DI"></a>2、IOC和DI</h5><p>控制反转(IOC)和依赖注入(DI)是Spring中最重要的核心概念之一，而两者实际上是一体两面的。</p>
<ul>
<li>依赖注入<ul>
<li>一个类依赖另一个类的功能，那么就通过注入，如构造器、setter方法等方式将这个类的实例引入。</li>
<li>侧重于实现。</li>
</ul>
</li>
<li>控制反转<ul>
<li>创建实例的控制权由一个实例的代码剥离到IOC容器控制，如xml配置中。</li>
<li>侧重于原理。</li>
<li>反转了什么：原先是由类本身去创建另一个类，控制反转后变成了被动等待这个类的注入。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2019/01/05/iOS-AppThinning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/05/iOS-AppThinning/" itemprop="url">瘦身优化小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T17:39:47+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/App优化/" itemprop="url" rel="index">
                    <span itemprop="name">App优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,175 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>18年年初(2018-01-27)写了篇瘦身优化，18年年底亲手操刀一个App的瘦身优化，在此次的实践的基础上，更新此篇文章</em>。</p>
<h4 id="一、安装包组成分析"><a href="#一、安装包组成分析" class="headerlink" title="一、安装包组成分析"></a>一、安装包组成分析</h4><h5 id="1、组成情况"><a href="#1、组成情况" class="headerlink" title="1、组成情况"></a>1、组成情况</h5><p>​    将IPA包修改后缀名为ZIP，解压缩后，获取payload中的App文件，查看App文件的内容，你会发现该文件主要包含以下内容</p>
<ul>
<li><strong>Exectutable</strong>: 可执行文件</li>
<li><strong>Resources</strong>：资源文件<ul>
<li>图片资源：<strong>Assets.car</strong>/bundle/png/jpg 等</li>
<li>视频/音频资源：mp4/mp3 等</li>
<li>静态网页资源：html/css/js 等</li>
<li>视图资源：xib/storyboard 等</li>
<li>其他：文本/字体/证书 等</li>
</ul>
</li>
<li><strong>Framework</strong>：<ul>
<li>SwiftSupport: libSwiftxxx 等一系列 Swift 库</li>
<li>其他依赖库：Embeded Framework</li>
</ul>
</li>
<li><strong>Pulgins</strong>：Application Extensions<ul>
<li>appex：其组成大致与 ipa 包组成一致</li>
</ul>
</li>
</ul>
<h5 id="2、组成分析"><a href="#2、组成分析" class="headerlink" title="2、组成分析"></a>2、组成分析</h5><ul>
<li>一般来说，可执行文件、图片资源(asset.car)和动态库的占比最大，如果是Swift和OC混编，可执行文件比纯OC大很多</li>
<li>从优化的效果上看，优化图片资源的ROI比较大，如果是首次优化，建议从图片资源的优化开始。</li>
<li>项目中使用Swift，会增加安装包大小，因为FrameWork中会加入为了支持 Swift 的动态库集合，如果纯Swift项目，不会引入这些东西。</li>
</ul>
<h4 id="二、资源文件优化"><a href="#二、资源文件优化" class="headerlink" title="二、资源文件优化"></a>二、资源文件优化</h4><p>​    理论上，资源文件包括：图片<strong>、</strong>视频<strong>、</strong>音频和字体等；实际上，视频和音频文件一般不会集成到安装包中，在安装包中的资源文件主要是图片。</p>
<h5 id="1、优化手段1：App-Slicing"><a href="#1、优化手段1：App-Slicing" class="headerlink" title="1、优化手段1：App Slicing"></a>1、优化手段1：App Slicing</h5><ul>
<li>iOS  9之后提供了App Thinning三件套：<strong>App Slicing</strong>、<strong>On Demand Resouces</strong>、<strong>Bitcode</strong>；</li>
</ul>
<table>
<thead>
<tr>
<th>App Thinning</th>
<th>理想</th>
<th>现实</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>App Slicing</strong></td>
<td>将App Bundle资源根据不同的设备特性分为不同的版本。对于图片资源，会根据设备所需图片分辨率不同分发给对应设备所需对应的图片资源。</td>
<td>主要是图片资源的Slicing，我们有自己的方案，没有采用</td>
</tr>
<tr>
<td><strong>On Demand Resources</strong></td>
<td>App的资源只有要使用时才下载，如果其他资源需要空间这些资源可以被移除</td>
<td>更适合游戏类App，项目没有使用</td>
</tr>
<tr>
<td><strong>Bitcode</strong></td>
<td>Bitcode可以作为中间产物一起提交AppStore。包含Bitcode配置的程序将会在AppStore上被编译和链接。Bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到AppStore上</td>
<td>使用BitCode的要求所有代码都支持BitCode，改动项目较大，没有使用</td>
</tr>
</tbody>
</table>
<p><strong>说明</strong>：可以充分利用App Slicing实现图片资源的瘦身</p>
<ul>
<li>在项目中引入图片时候，直接在 <strong>Assets.xcassets</strong>中添加就可以（资源文件用<strong>Asset Catalog</strong>管理），这样能使用到<strong>App Slicing</strong>功能，这样当用户从App Store上下载App时，可以只下载适用于其设备的App架构版本和所需资源，从而减少App所占的空间。</li>
<li>在实践中发现，有的新同学在<strong>Assets.xcassets</strong>中引入@1x的图片，iPhone手机目前需要的@2x和@3x图片，所以@1x的图片显然是不需要的。</li>
<li>在实践中还发现，有的图片资源游离在Assets.xcassets之外，这些可以考虑是否可以放入<strong>Assets.xcassets</strong>中(大部分情况下是可以放入的)</li>
</ul>
<h5 id="2、优化手段2：Xcode编译项"><a href="#2、优化手段2：Xcode编译项" class="headerlink" title="2、优化手段2：Xcode编译项"></a>2、优化手段2：Xcode编译项</h5><ul>
<li><p>因为绝大部分引入的图片是PNG格式，Xcode 提供的给我们两个编译选项来帮助压缩 PNG 资源：</p>
</li>
<li><p><strong>Compress PNG Files</strong>：设置为YES，打包的时候自动对图片进行无损压缩，使用的工具为 <a href="https://en.wikipedia.org/wiki/Pngcrush" target="_blank" rel="noopener">pngcrush</a>，压缩比还是相当高的，比较流行的压缩软件 <a href="https://imageoptim.com/mac" target="_blank" rel="noopener">ImageOptim</a> 也是使用 pngcrush 进行压缩 PNG 的。</p>
</li>
<li><strong>Remove Text Medadata From PNG Files</strong>：设置为YES，能帮助我们移除 PNG 资源的文本字符，比如图像名称、作者、版权、创作时间、注释等信息。</li>
<li>引入项目的PNG资源自动被 Xcode 进行压缩了，但是如果是使用Bundle管理的资源，不会被Xcode压缩，可以使用<a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng</a>压缩。</li>
</ul>
<h5 id="3、优化手段3：清理无用的资源"><a href="#3、优化手段3：清理无用的资源" class="headerlink" title="3、优化手段3：清理无用的资源"></a>3、优化手段3：清理无用的资源</h5><ul>
<li><strong>及时清理不使用的图片资源</strong>。使用类似<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a> 清理旧的图片文件。</li>
<li>LSUnusedResources的思路是，先获取图片文件(imageset, jpg, png, gif)集合A，然后搜索代码文件中所有字符串名称得到B，然后从A集合中排除集合B就得到未使用的图片资源。  </li>
</ul>
<h5 id="4、优化手段4：图片文件去重"><a href="#4、优化手段4：图片文件去重" class="headerlink" title="4、优化手段4：图片文件去重"></a>4、优化手段4：图片文件去重</h5><ul>
<li>遍历图片文件，计算每个文件的MD5值，然后以MD5值为key，文件路径存入key对应的数组；</li>
<li>遍历字典values，将value的数组大小大于1的路径输出，这样就找到重复图片的路径了。</li>
</ul>
<h5 id="5、优化手段5：更适合的图片格式"><a href="#5、优化手段5：更适合的图片格式" class="headerlink" title="5、优化手段5：更适合的图片格式"></a>5、优化手段5：更适合的图片格式</h5><ul>
<li><strong>iconfont</strong>代替项目中纯色小图标，也省去很多@2x和@3x的图片切图。</li>
<li>PNG切图的替换方案，如<strong>PDF矢量图来代替大部分简单的png切图</strong>；然后在代码中自己解码并展示出来，一套PDF矢量图可以等效大部分2x和3x的png图片；</li>
<li>网络图片选择压缩比更好的图片格式，如webp</li>
</ul>
<p><strong>说明</strong>：PNG切图不可能被完全替换，在表现颜色丰富图片时候，PNG效果很不错，其他详见<a href="https://buaa0300.github.io/2018/01/13/imageOptimize/" target="_blank" rel="noopener">浅谈iOS图片优化</a></p>
<h4 id="三、可执行文件优化"><a href="#三、可执行文件优化" class="headerlink" title="三、可执行文件优化"></a>三、可执行文件优化</h4><h5 id="1、优化手段1：编译器优化"><a href="#1、优化手段1：编译器优化" class="headerlink" title="1、优化手段1：编译器优化"></a>1、优化手段1：编译器优化</h5><ul>
<li>Xcode 支持编译器层面的一些优化优化选项，可以让我们介于<strong>更快的编译速度</strong>、<strong>更小的二进制大小</strong>和<strong>更快的执行速度</strong>之间自由选择想要进行的优化粒度；</li>
</ul>
<ul>
<li>在Xcode中，使用<strong>Clang</strong>来编译Objective-C，可以在 Build Setting -&gt; Apple Clang - Code Generation -&gt; <strong>Optimization Level</strong> 设置，Release下为<strong>Fastest Smallest[-Os]</strong>。编译器会开启除了会明显增加包大小以外的所有优化选项；</li>
</ul>
<ul>
<li>在Xcode中，使用<strong>SwiftLang</strong>来编译Swift语言，同样也是基于 LLVM 后端的。Xcode 9.3 版本之后可以在Build Setting -&gt;  <strong>Optimization Level</strong> 设置，Release下为<strong>Optimize for Speed[-O]</strong>，这可能会增加安装包大小</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No optimization[-Onone]：不进行优化，能保证较快的编译速度。</span><br><span class="line">Optimize for Speed[-O]：编译器将会对代码的执行效率进行优化，一定程度上会增加包大小。</span><br><span class="line">Optimize for Size[-Osize]：编译器会尽可能减少包的大小并且最小限度影响代码的执行效率</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：Xcode 9.3/Swift4.1编译器不是特别稳定，特别是开启 Osize 选项之后，编译器很多情况下会莫名其妙的崩溃(Segmentation fault)，目前放弃 [-Osize]，选择[-O]</p>
<h5 id="2、优化手段2：去除符号信息"><a href="#2、优化手段2：去除符号信息" class="headerlink" title="2、优化手段2：去除符号信息"></a>2、优化手段2：去除符号信息</h5><ul>
<li>可执行文件中的符号：程序中的所有的<strong>变量、类、函数、枚举、变量和地址映射关系</strong>，以及一些在调试的时候使用到的用于定位代码在源码中的位置的调试符号，符号和断点定位以及堆栈符号化有很重要的关系。</li>
</ul>
<ul>
<li><strong>Strip Style</strong>表示的是我们需要去除的符号的类型的选项，可以在Build Setting -&gt;  Strip Style设置， Release下为<strong>All Symbols</strong>，其分为三个选择项：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">All Symbols: 去除所有符号，一般是在主工程中开启。</span><br><span class="line"></span><br><span class="line">Non-Global Symbols: 去除一些非全局的 Symbol（保留全局符号，Debug Symbols 同样会被去除），链接时会被重定向的那些符号不会被去除，此选项是静态库/动态库的建议选项。</span><br><span class="line"></span><br><span class="line">Debug Symbols: 去除调试符号，去除之后将无法断点调试。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：iOS 的调试符号是 <strong>DWARF</strong> 格式的，使用 Xcode 编译打包的时候会先通过可执行文件的 Debug Map 获取到所有对象文件的位置，然后使用 <strong>dysmutil</strong> 来将对象文件中的 DWARF 提取出来生成 dSYM 文件。</p>
<ul>
<li><strong>Strip Linked Product</strong>去除不必要的符号信息，去除了符号信息之后我们就只能使用 dSYM 来进行符号化了，所以需要将 Debug Information Format 修改为 DWARF with dSYM file。Release下为YES。</li>
</ul>
<ul>
<li>Strip Linked Product 选项在 <strong>Deployment Postprocessing 设置为 YES</strong> 的时候才生效，而在 Archive 的时候 Xcode 总是会把 Deployment Postprocessing 设置为 YES，Debug下,Deployment Postprocessing 设置为 NO。</li>
</ul>
<ul>
<li><strong>Strip Debug Symbols During Copy</strong>将那些拷贝进项目包的三方库、资源或者 Extension 的  Debug Symbol 去除掉，在Build Settings -&gt; Strip Debug Symbols During Copy设置，Release下设置为YES。</li>
</ul>
<ul>
<li>Cocoapods 管理的动态库(use_framework!)的情况就相对要特殊一点，因为 Cocoapods 中的的动态库是使用自己实现的脚本 Pods-xxx-frameworks.sh 来实现拷贝的，所以并不会走 Xcode 的流程，当然也就不受 Strip Debug Symbols During Copy 的影响。当然 Cocoapods 是源码管理的，所以只需要将源码 Target 中的 Strip Linked Product 设置为 YES 即可。</li>
</ul>
<ul>
<li><strong>Strip Swift Symbols</strong>能帮助我们移除相应 Target 中的所有的 Swift 符号，这个选项也是默认打开的。Strip Swift symbols需要在打包的发布选项中勾选(默认勾选)，在Swift ABI 稳定之前，Swift 标准库是会打进目标文件的。</li>
</ul>
<h5 id="3、优化手段3：BitCode"><a href="#3、优化手段3：BitCode" class="headerlink" title="3、优化手段3：BitCode"></a>3、优化手段3：BitCode</h5><ul>
<li>Bitcode可以作为中间产物一起提交AppStore。包含Bitcode配置的程序将会在AppStore上被编译和链接。Bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到AppStore上。</li>
</ul>
<ul>
<li>开启 BitCode 之后编译器后端(Backend)的工作都由 Apple 接管了。所以假如以后苹果推出了新的 CPU 架构或者以后 LLVM 推出了一系列优化，我们也不再需要为其发布新的安装包了。</li>
</ul>
<ul>
<li>工程开启 BitCode 之后必须要求所有打进 Bundle 的 Binary 都需要支持 BitCode，也就是说我们依赖的静态库和动态库都是含有 BitCode 的，不然就会打包失败。对于 Cocoapods 等源码管理工具来管理的依赖库来说操作会比较简单，我们只需要开启 Pods 工程中的 BitCode 就行。但是对于一些三方的闭源库，我们就无能为力了。</li>
</ul>
<ul>
<li>开启 BitCode 之后，由于最终的可执行文件是 Apple 自动生成的，同时产生新的符号表文件，所以我们使用原本打包生成的 dSYM 符号化文件是无法完成符号化的。所以我们需要在上传至 App Store 时需要勾选 Include app symbols for your application to receive symboilcated crash logs from Apple：勾选之后 Apple 会给我们生成 dSYM，然后就可以在 Xcode -&gt; Organizer 或者 iTunes Connect 中下载对应的 dSYM 来进行符号化了。</li>
</ul>
<h5 id="4、优化手段4：清除无用代码"><a href="#4、优化手段4：清除无用代码" class="headerlink" title="4、优化手段4：清除无用代码"></a>4、优化手段4：清除无用代码</h5><ul>
<li><strong>Dead Code Stripping</strong>：Xcode 默认会开启此选项，C/C++/Swift 等<strong>静态语言</strong>编译器会在 link 的时候<strong>移除未使用的代码</strong>，但是对于 Objective-C 等动态语言是无效的。因为 Objective-C 是建立在运行时上面的，底层暴露给编译器的都是 Runtime 源码编译结果，所有的部分应该都是会被判别为有效代码。</li>
</ul>
<ul>
<li><strong>扫描查找无用代码</strong>：基本思路都是查找已经使用的方法/类和所有的类/方法，然后从所有的类/方法当中剔除已经使用的方法/类剩下的基本都是无用的类/方法，但是由于 Objective-C 是动态语言，可以使用字符串来调用类和方法，所以检查结果一般都不是特别准确，需要二次确认。目前市面上的扫描的思路大致可以分为 3 种：<ul>
<li>基于 Clang 扫描</li>
<li>基于可执行文件扫描</li>
<li>基于源码扫描</li>
</ul>
</li>
</ul>
<ul>
<li><strong>及时下线不需要的功能</strong>，如完成使命的ABTest代码、被产品抛弃的功能代码等。</li>
</ul>
<ul>
<li>移除不需要的系统库和第三方库。</li>
</ul>
<h5 id="5、优化手段5：代码重构"><a href="#5、优化手段5：代码重构" class="headerlink" title="5、优化手段5：代码重构"></a>5、优化手段5：代码重构</h5><ul>
<li>功能合并：相似功能的代码，只需维护一份就可以了。如定制通用UI组件，大家可以有类似需求，可以给通用UI组件的开发提，没必要自己单独实现。</li>
</ul>
<h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4><h5 id="1、优化之后"><a href="#1、优化之后" class="headerlink" title="1、优化之后"></a>1、优化之后</h5><ul>
<li><p>保持良好的开发习惯。及时清理无用代码和无效库</p>
</li>
<li><p>持续关注安装包大小的变化，</p>
</li>
<li>定期Review安装包大小变化</li>
<li>建议预警机制，监控每个版本的体积大小，体积图片突然变大，要去找原因。</li>
</ul>
<h5 id="2、参考资料"><a href="#2、参考资料" class="headerlink" title="2、参考资料"></a>2、参考资料</h5><p><a href="https://juejin.im/post/5800ef71a0bb9f0058736caa" target="_blank" rel="noopener">iOS App 瘦身实践总结</a></p>
<p><a href="https://sq.163yun.com/blog/article/200385709022117888" target="_blank" rel="noopener">iOS 安装包瘦身（上篇)</a></p>
<p><a href="https://sq.163yun.com/blog/article/200384401846304768" target="_blank" rel="noopener">iOS 安装包瘦身（下篇)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/11/30/Recommend02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/30/Recommend02/" itemprop="url">推荐迷雾(一):话说ABTest实验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-30T23:17:13+08:00">
                2018-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/推荐/" itemprop="url" rel="index">
                    <span itemprop="name">推荐</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,028 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>雄兔脚扑朔，雌兔眼迷离；双兔傍地走，安能辨我是雄雌？</em></p>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1、什么是ABTest实验"><a href="#1、什么是ABTest实验" class="headerlink" title="1、什么是ABTest实验"></a>1、什么是ABTest实验</h4><ul>
<li>今天ABTest已经是一门显学了，主流的产品，无论是算法模型优化，还是UI或体验的调整，上线后都会做ABTest实验，这种线上实验离用户更近，收益大于离线评估方案；</li>
<li>ABTest实验是为了避免盲目决策带来不确定性和随机性，将各种不同的实验同时放到线上，然后利用数据分析来辅助决策，总之一句话，让数据说话 (data talk)。</li>
</ul>
<h4 id="2、ABTest实验的条件"><a href="#2、ABTest实验的条件" class="headerlink" title="2、ABTest实验的条件"></a>2、ABTest实验的条件</h4><ul>
<li><strong>比较好的两个及以上备选方案</strong>，毕竟 ABTest实验不是银弹，它只是辅助我们做<strong>更好的选择</strong>。</li>
<li><strong>量化的指标</strong>，比如App中PV、UV、CTR、CVR、CPM等</li>
<li><strong>用户群体稳定 且 用户量足够</strong></li>
</ul>
<h4 id="3、ABTest实验需要注意的问题"><a href="#3、ABTest实验需要注意的问题" class="headerlink" title="3、ABTest实验需要注意的问题"></a>3、ABTest实验需要注意的问题</h4><ul>
<li><strong>实验流量合理分配</strong>: 保证每组实验流量分配的正交性、均匀性和充足性</li>
<li><strong>排查实验自身干扰</strong>：实验中可能引入不确定因素，导致结果不可预估</li>
</ul>
<p><strong>参考</strong>：<a href="http://uxren.cn/?p=58841" target="_blank" rel="noopener">你的AB测试平台和方案，真的可靠么</a></p>
<h3 id="二、单层模型和分层模型"><a href="#二、单层模型和分层模型" class="headerlink" title="二、单层模型和分层模型"></a>二、单层模型和分层模型</h3><h4 id="1、单层模型"><a href="#1、单层模型" class="headerlink" title="1、单层模型"></a>1、单层模型</h4><ul>
<li>不同组实验在同一层拆分流量，不同组的流量是不重叠的</li>
<li>只能支持少量的实验，不利于迭代</li>
<li>实验之间不独立，策略之间可能相互影响</li>
<li>分流方式不灵活</li>
</ul>
<h4 id="2、分层模型"><a href="#2、分层模型" class="headerlink" title="2、分层模型"></a>2、分层模型</h4><ul>
<li>主流的流量分配方案，来自2010年谷歌公布的的《Overlapping Experiment Infrastructure More, Better, Faster Experimentation》论文；</li>
<li>谷歌提出将实验空间横向、纵向划分，纵向流量可以独占实验区域，可以独享实验流量，不被其他实验影响；横向分若干层，每一个可以做同一组的实验，每个独立实验为一层，层与层之间流量是正交的，一份流量穿越每层实验时，都会再次随机打散，且随机效果离散。</li>
</ul>
<p><strong>参考</strong>：<a href="http://www.woshipm.com/pd/1080730.html" target="_blank" rel="noopener">一文搞懂AB Testing的分层分流</a></p>
<h3 id="三、分层模型方案"><a href="#三、分层模型方案" class="headerlink" title="三、分层模型方案"></a>三、分层模型方案</h3><h4 id="1、技术关键点"><a href="#1、技术关键点" class="headerlink" title="1、技术关键点"></a>1、技术关键点</h4><ul>
<li><p>分流函数（流量如何在每层被打散）如何设计，如果保证每层流量分配的均匀性和正交性</p>
</li>
<li><p>如何处理实验样本的过滤(如 只选取某个地区的用户、只选取新用户)</p>
</li>
<li><p>分配多大的流量可以使实验置信</p>
</li>
</ul>
<h4 id="2、设计"><a href="#2、设计" class="headerlink" title="2、设计"></a>2、设计</h4><ul>
<li>域（domain）：划分的一部分流量</li>
<li>层（layer）：系统参数的一个子集</li>
<li>实验（exp）：在一个域上，对一个或者多个参数修改，改变请求路径的过程</li>
</ul>
<ul>
<li>相关联的策略参数位于同一实验层；</li>
<li>相互独立的策略参数分属于不同的实验层；</li>
<li>一个实验参数只能在一个实验层中出现；</li>
<li><p>不同实验层间进行独立的流量划分和独立的实验，互不影响。</p>
</li>
<li><p>每一实验层享有 100% 流量，可以避免流量切分过细，保证实验间的可对比性、客观性；</p>
</li>
<li>不同实验层之间流量正交，可以避免不同试验间的流量依赖和流量不均匀情况的出现。为了更好地评估实验的效果，每一实验层还引入了基准实验。该基准实验会采用该实验层的默认策略取值，流量配比会设定在一个合适的水平。</li>
</ul>
<h3 id="四、业内ABTest实验平台"><a href="#四、业内ABTest实验平台" class="headerlink" title="四、业内ABTest实验平台"></a>四、业内ABTest实验平台</h3><p>基于Google的分层模型，美团和微博的ABTest平台实现</p>
<h4 id="1、美团点评-的-Gemini"><a href="#1、美团点评-的-Gemini" class="headerlink" title="1、美团点评 的 Gemini"></a>1、美团点评 的 Gemini</h4><p><a href="https://www.csdn.net/article/2015-03-24/2824303" target="_blank" rel="noopener">https://www.csdn.net/article/2015-03-24/2824303</a></p>
<h4 id="2、微博的-Faraday"><a href="#2、微博的-Faraday" class="headerlink" title="2、微博的 Faraday"></a>2、微博的 Faraday</h4><p>微博广告法拉第（Faraday）全流量分层实验平台。该实验平台支持大规模广告策略并发实验，提供了多种流量均匀分流模式，全面的广告指标跟踪评估，实验效果实时反馈等。</p>
<p><a href="http://www.yunweipai.com/archives/19535.html" target="_blank" rel="noopener">http://www.yunweipai.com/archives/19535.html</a></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25685006" target="_blank" rel="noopener">携程机票的ABTest实践</a></li>
<li><a href="https://yq.aliyun.com/articles/5837" target="_blank" rel="noopener">10分钟搞懂分层实验原理</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/11/21/Recommend01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/21/Recommend01/" itemprop="url">推荐迷雾(一):再见推荐系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-21T22:55:30+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/推荐/" itemprop="url" rel="index">
                    <span itemprop="name">推荐</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,332 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><em>花非花，雾非雾。夜半来，天明去。来如春梦不多时，去似朝云无觅处。</em></p>
<p>​    用白居易的诗作为《推荐迷雾》系列的开始，本人非推荐算法工程师，但是工作中也和算法打过些交道，也曾于13年粗读过项亮博士的《推荐系统实战》，这本12年出版的“旧”书如今再读起来，更多一番体会；虽然近些年，机器学习尤其是深度学习给传统推荐学习带来新的变化，但是这些新兴的推荐技术依旧有传统的推荐算法模型的影子。</p>
<p><img src="/nanhuacoder.com/2018/11/21/Recommend01/jianghu.jpeg" alt="江湖"></p>
<h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><ul>
<li>推荐产生的背景：信息过载，用户需求不确定</li>
<li>推荐三步骤：召回，预估和排序</li>
</ul>
<h3 id="二、推荐系统的评估指标和方法"><a href="#二、推荐系统的评估指标和方法" class="headerlink" title="二、推荐系统的评估指标和方法"></a>二、推荐系统的评估指标和方法</h3><h4 id="1、评估指标"><a href="#1、评估指标" class="headerlink" title="1、评估指标"></a>1、评估指标</h4><h5 id="1-1、评分预测的评估"><a href="#1-1、评分预测的评估" class="headerlink" title="1-1、评分预测的评估"></a>1-1、评分预测的评估</h5><ul>
<li><p>RMSE (均方根误差，加大预测不准物品评分的惩罚)</p>
</li>
<li><p>MAE（平均绝对误差）</p>
</li>
</ul>
<h5 id="1-2、TopN推荐的评估"><a href="#1-2、TopN推荐的评估" class="headerlink" title="1-2、TopN推荐的评估"></a>1-2、TopN推荐的评估</h5><ul>
<li>在这里用到了<strong>准确率</strong>、<strong>召回率</strong>和<strong>F-1 Score</strong>三个度量值</li>
<li><strong>召回率</strong>（Recall）：用户消费的内容，是由推荐提供的占比</li>
<li><strong>准确率</strong>（Precision）：推荐的内容中，用户消费的占比</li>
<li><strong>F-1 Score</strong> </li>
</ul>
<p>$$<br>F_1 Score = \frac{2 x recall * precision}{recall + precision}<br>$$</p>
<p><strong>召回率</strong>表示在原始样本的正样本中，最后被正确预测为正样本的概率；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算召回率和准确率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrecisionRecall</span><span class="params">(test,N)</span>:</span></span><br><span class="line">	hit = <span class="number">0</span></span><br><span class="line">	n_recall = <span class="number">0</span></span><br><span class="line">	n_precision = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> user,item <span class="keyword">in</span> test.items():</span><br><span class="line">		rank = Recommend(user,N)</span><br><span class="line">		hit += len(rank &amp; items)</span><br><span class="line">		n_recall += len(items)</span><br><span class="line">		n_precision += N</span><br><span class="line">	<span class="keyword">return</span> [hit/(<span class="number">1.0</span> * n_recall),hit/(<span class="number">1.0</span>*n_precision)]</span><br></pre></td></tr></table></figure>
<ul>
<li>为了全面评估TopN推荐的准确率和召回率，一般选取不同推荐列表长度N，计算一组准确率/召回率，然后画出准确率/召回率曲线。</li>
<li>在工程实践中，TopN推荐更合适，因为对于推荐的内容来说，预测用户会不会看，比预测用户看了内容后给多少分更重要。</li>
</ul>
<h5 id="1-3、覆盖率"><a href="#1-3、覆盖率" class="headerlink" title="1-3、覆盖率"></a>1-3、覆盖率</h5><p>推荐系统对物品长尾的发掘能力，简单的定义是推荐物品占总物品集合的比例。当然还有更好的指标来定义覆盖率。</p>
<ul>
<li>信息熵：</li>
<li>基尼系数：</li>
</ul>
<h5 id="1-3、其他指标"><a href="#1-3、其他指标" class="headerlink" title="1-3、其他指标"></a>1-3、其他指标</h5><ul>
<li>多样性、新颖性、惊喜度、信任度、实时性、健壮性，商业目标等等，具体参考《推荐系统实战》中的内容</li>
</ul>
<h4 id="2、评估方法"><a href="#2、评估方法" class="headerlink" title="2、评估方法"></a>2、评估方法</h4><ul>
<li><p>离线评估：速度快，不需要用户参与；在用户的历史数据上做评估，和线上真实效果有偏差；只能评估少数指标。</p>
</li>
<li><p>用户调查：主要的形式是问卷调查，成本高</p>
</li>
<li><p>在线实验：目前最普遍的做法是ABtest，目前主采用多层重叠实验设计，这些在后面的文章重点介绍</p>
</li>
</ul>
<h3 id="三、推荐系统架构"><a href="#三、推荐系统架构" class="headerlink" title="三、推荐系统架构"></a>三、推荐系统架构</h3><ul>
<li>推荐系统是产品的核心，而推荐算法仅仅是推荐系统中的一部分；以NetFlix的推荐系统架构为例，介绍经典的推荐系统架构。</li>
<li>在NetFlix推荐系统架构中，分为三层：Offline层（离线层）、Nearline层（近线层）和  Online层（在线层）</li>
</ul>
<h4 id="1、Offline层（离线层）"><a href="#1、Offline层（离线层）" class="headerlink" title="1、Offline层（离线层）"></a>1、Offline层（离线层）</h4><ul>
<li>这一层批量、周期性地<strong>抽取数据</strong>，<strong>训练模型</strong>；训练得到的模型可以用于为用户计算推荐结果。协同过滤、矩阵分解一般在这层做，Hadoop、Spark分布式计算也在这一层。</li>
<li>Offline阶段的推荐结果或模型在Nearline层被更新，产生最终的推荐结果，呈现给用户。</li>
</ul>
<h4 id="2、Nearline层（近线层）"><a href="#2、Nearline层（近线层）" class="headerlink" title="2、Nearline层（近线层）"></a>2、Nearline层（近线层）</h4><ul>
<li>Nearline要处理处理实时数据流(流计算），执行计算任务：从事件队列中获取最新的一个或少许几个用户反馈行为，将这些用户已经反馈过的物品从离线推荐结果中剔除，然后用这几个反馈行为作为样本，以小批量梯度下降的优化方法去更新融合模型的参数。</li>
</ul>
<h4 id="3、Online层（在线层）"><a href="#3、Online层（在线层）" class="headerlink" title="3、Online层（在线层）"></a>3、Online层（在线层）</h4><ul>
<li>用户使用App/浏览Web，消费展示内容，产生行为事件数据，如页面曝光，按钮点击等，实时被收集走，一边进入分布式文件系统中做存储，给Offline使用，一边流向Nearline的<strong>消息队列</strong>，供Nearline的<strong>流计算</strong>使用。</li>
<li>用户发出请求，等待推荐结果；Online层必须实施响应用户请求，要快，要有兜底，Online层处理的一般是已经预处理后的推荐结果。</li>
</ul>
<h3 id="四、推荐系统中的冷启动和EE问题"><a href="#四、推荐系统中的冷启动和EE问题" class="headerlink" title="四、推荐系统中的冷启动和EE问题"></a>四、推荐系统中的冷启动和EE问题</h3><ul>
<li>在推荐系统中有两个经典问题：<strong>冷启动</strong>和<strong>EE</strong>(探索和利用问题)。</li>
<li>Bandit算法提供了一种有效的解决办法；其中<strong>冷启动</strong>的本质是：推荐系统没有历史数据，无法预测用户偏好；可分为用户冷启动，物品冷启动和系统冷启动。<strong>EE问题</strong>是指，是选择现在不确定的一些方案，但未来可能会有高收益的方案；还是选择现在可能最佳的方案；本质是一个选择的问题。</li>
<li>Bandit 算法来源于历史悠久的赌博学，它要解决这样的问题：一个赌徒去摇老虎机，赌场中有的老虎机一模一样，但是每个老虎机吐钱的概率不一样，他不知道每个老虎机吐钱的概率分布是什么，那么每次该选择哪个老虎机可以做到最大化收益呢？这就是<strong>多臂赌博机问题</strong>（Multi-armed bandit problem, K-armed bandit problem, MAB）</li>
</ul>
<p><img src="/nanhuacoder.com/2018/11/21/Recommend01/mab.png" alt="MAB问题"></p>
<ul>
<li><p>假设我们已经经过一些试验，得到了当前每个老虎机的吐钱的概率，如果想要获得最大的收益，我们会一直摇哪个吐钱概率最高的老虎机，这就是Exploitation。但是，当前获得的信息并不是老虎机吐钱的真实概率，可能还有更好的老虎机吐钱概率更高，因此还需要进一步探索，这就是Exploration问题。</p>
</li>
<li><p>Bandit解决MAB或者EE问题的策略是：有策略地走一步看一步，这些策略就是Bandit算法，经典的Bandit算法分别是：<strong>朴素Bandit、汤普森采样、UCB和Epsilon贪婪算法</strong>。</p>
</li>
</ul>
<h4 id="1、朴素Bandit"><a href="#1、朴素Bandit" class="headerlink" title="1、朴素Bandit"></a>1、朴素Bandit</h4><p><strong>原理</strong>：先随机试若干次，计算每个臂的平均收益，一直选均值最大那个臂。</p>
<h4 id="2、汤普森采样-Thompson-sampling-算法"><a href="#2、汤普森采样-Thompson-sampling-算法" class="headerlink" title="2、汤普森采样(Thompson sampling)算法"></a>2、汤普森采样(Thompson sampling)算法</h4><p><strong>原理</strong>：</p>
<ul>
<li>每个臂维护一个beta(a，b)分布，每次用现有的beta分布产生一个随机数，输出随机数最大的臂（较快，随机性高）</li>
</ul>
<p><strong>beta(a，b)分布特点</strong>：</p>
<ul>
<li>a+b值越大，分布曲线就越窄，分布就越集中；</li>
<li>a/(a+b)值越大，分布中心越靠近1，反之越靠近0；</li>
</ul>
<p><strong>采样过程</strong>：</p>
<ul>
<li><p>假设a是用户的点击次数，b是没有得到用户的点击次数</p>
</li>
<li><p>每次取出所有候选的参数a和b，用贝塔分布产生一个随机数</p>
</li>
<li><p>随机数排序，输出最大值对应的候选</p>
</li>
<li><p>如果用户点击，对应的候选a加1，反之b加1</p>
</li>
</ul>
<p><strong>分析</strong>：</p>
<ul>
<li>如果一个候选被选中的次数很多（a+b很大），分布变窄，对应的分布产生的随机数基本在中心位置，接近平均收益。</li>
<li>如果a+b很大，a/(a+b)也很大，那么分布产生的随机数越接近1，平均收益很好，进入利用阶段；</li>
<li>如果a+b很小，说明候选的好坏不能确定，分布很宽，可能得到一个较大的随机数，排序时候可能被优先输出，起到了探索的目的。</li>
</ul>
<h4 id="3、UCB算法"><a href="#3、UCB算法" class="headerlink" title="3、UCB算法"></a>3、UCB算法</h4><p><strong>原理</strong>：</p>
<ul>
<li>以每个候选的平均收益作为基准线进行选择</li>
<li>对于每次被选择不足的给与照顾</li>
<li>选择倾向于那些确定收益较好的候选</li>
</ul>
<p><strong>简言之</strong>，均值越大，标准差越小，被选中的概率会越来越大 (相对慢一点，确定性高)</p>
<h4 id="4、Epsilon贪婪-Epsilon-Greedy-算法"><a href="#4、Epsilon贪婪-Epsilon-Greedy-算法" class="headerlink" title="4、Epsilon贪婪(Epsilon-Greedy)算法"></a>4、Epsilon贪婪(Epsilon-Greedy)算法</h4><p><strong>原理：</strong></p>
<ul>
<li>先选一个(0,1)之间较小的值，作为Epsilon，然后每次以1-epsilon的概率选取当前收益最大的臂，以epsilon的随机概率选取一个臂。（后期不需要较大探索，epsilon需要衰减）</li>
<li>Epsilon可以控制探索和利用的程度，Epsilon越接近0，在探索上就越保守；Epsilon越接近1，在探索上就越激进。</li>
</ul>
<p><img src="/nanhuacoder.com/2018/11/21/Recommend01/bandit-performance.png" alt="Bandit算法算法模拟试验效果"></p>
<p><strong>总结</strong>：UCB算法和汤普森采样算法效果更好些。</p>
<h3 id="五、Bandit算法的工程实现"><a href="#五、Bandit算法的工程实现" class="headerlink" title="五、Bandit算法的工程实现"></a>五、Bandit算法的工程实现</h3><p>​    上面介绍的<strong>朴素Bandit、汤普森采样、UCB和Epsilon贪婪算法</strong>都是经典的Bandit算法，在工程中很少使用；实际中，我们采用的是上下文Bandit算法，比较常见的是LinUCB算法和COFIBA算法</p>
<h4 id="1、LinUCB"><a href="#1、LinUCB" class="headerlink" title="1、LinUCB"></a>1、LinUCB</h4><p><strong>概述</strong>：</p>
<ul>
<li><p>传统的 Bandit 算法并没有考虑臂的特征信息，也就是说并没有考虑上下文信息，而yahoo在2010年提出的，一种结合上下文的 Bandit算法——LinUCB (linear UCB)算法。</p>
</li>
<li><p>LinUCB 算法可以将当前用户的特征、物品特征构成所有的相关特征，然后根据每个臂维护的特征系数,计算出预估收益。由于加入了特征，所以收敛速度比 UCB 更快。</p>
</li>
<li>LinUCB的不足：同时处理的候选臂数量不能太多，不超过几百个最佳。因为每一次要计算每一个候选臂的期望收益和置信区间，一旦候选太多，计算代价将不可接受。其实这也是所有的 Bandit 算法的缺点。</li>
</ul>
<p><strong>原理：</strong></p>
<ul>
<li><p>LinUCB 假设一个物品推送给用户之后，获得的收益与相关特征呈<strong>线性关系</strong>，这里的相关特征就是指上下文信息。LinUCB 有两个版本：<strong>Disjoint</strong> 和 <strong>Hybrid</strong>，Disjoint 表示不同臂之间的不相关，也就是说参数不共享，Hybrid 表示臂之间共享一些参数。</p>
</li>
<li><p>Disjoint 模型：假设每个臂包含一个物品，我们在每一次选择时，用户与物品的的特征构成了上下文信息，表示为 x，维度为 d，每个臂维护了一个 d 维的表示特征系数的向量 θ，使用 c 表示本次选择的收益，如果用户点击了就为 1，否则为 0。我们假定：</p>
</li>
</ul>
<p>  根据p’ + ∆来选择合适的臂。p’的计算基于有监督的学习方法。我们为每个老虎机维护一个特征向量D，同时上下文特征我们写作θ，然后通过收集的反馈进行有监督学习：</p>
<ul>
<li><p>加入特征信息，用User和Item的特征预估回报及其置信区间，选择置信区间上界最大的Item推荐，观察回报后更新线性关系的参数，以此达到试验学习的目的。</p>
</li>
<li><p>岭回归的求解，岭回归适合样本数少于特征的数据集。</p>
</li>
<li><p>参考：<a href="http://www.naodongopen.com/908.html" target="_blank" rel="noopener">结合上下文信息的Bandit算法—LinUCB算法</a></p>
</li>
</ul>
<h4 id="2、COFIBA"><a href="#2、COFIBA" class="headerlink" title="2、COFIBA"></a>2、COFIBA</h4><ul>
<li>2016年提出，COFIBA算法的不同有两个：<ol>
<li>基于用户聚类挑选最佳的Item（相似用户集体决策的Bandit）。</li>
<li>基于用户的反馈情况调整User和Item的聚类（协同过滤部分）。</li>
</ol>
</li>
<li>在时刻t，用户来访问推荐系统，推荐系统需要从已有的候选池子中挑一个最佳的物品推荐给他，然后观察他的反馈，用观察到的反馈来更新挑选策略。 这里的每个物品都有一个特征向量，所以这里的Bandit算法是context相关的。 这里依然是用岭回归去拟合用户的权重向量，用于预测用户对每个物品的可能反馈（payoff），这一点和linUCB算法是一样的</li>
</ul>
<ul>
<li><p>bandit结合协同过滤。</p>
<p><a href="https://blog.csdn.net/heyc861221/article/details/80129310" target="_blank" rel="noopener">https://blog.csdn.net/heyc861221/article/details/80129310</a></p>
</li>
</ul>
<h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><ul>
<li>Exploit-Explore这一对矛盾一直客观存在，Bandit算法是公认的一种比较好的解决EE问题的方案。但解决Explore，势必就是要冒险，势必要走向未知，而这显然就是会伤害用户体验的：明知道用户肯定喜欢A，你还偏偏以某个小概率给推荐非A。</li>
<li>实际上，很少有公司会采用这些理性的办法做Explore，反而更愿意用一些盲目主观的方式。究其原因，可能是因为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、互联网产品生命周期短，而Explore又是为了提升长期利益的，所以没有动力做；</span><br><span class="line">2、用户使用互联网产品时间越来越碎片化，Explore的时间长，难以体现出Explore 的价值；</span><br><span class="line">3、同质化互联网产品多，用户选择多，稍有不慎，用户用脚投票，分分钟弃你于不顾；</span><br><span class="line">4、已经成规模的平台，红利杠杠的，其实是没有动力做Explore的。</span><br></pre></td></tr></table></figure>
<ul>
<li>所以做Explore要精心设计，必须保证质量。</li>
</ul>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li><p>bandit添加对应的源码实现</p>
</li>
<li><p>ABTest的分层实验设计</p>
</li>
<li>召回中的协同过滤和隐语义模型, 矩阵分解</li>
<li>CTR预估的进化，特征工程 + LR -&gt; GBDT + LR -&gt; FM -&gt;FFM -&gt; DeepFM/Wide&amp;Deep/…</li>
<li>排序怎么做</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/11/20/ML02-DTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/20/ML02-DTree/" itemprop="url">机器学习中的树模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-20T23:33:16+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,345 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><ul>
<li>在数据结构中，有树这种结构；在机器学习中，有决策树；咋一看，感觉是一回事，其实不然；</li>
<li><p>数据结构的树关注的事查找，插入，删除的效率，二叉树，平衡二叉树都是为了解决这些效率而产生的；</p>
</li>
<li><p>机器学习中的决策树关注的是，如何找到最佳分解节点，<strong>ID3算法</strong>(按最大信息增益划分)，<strong>C4.5</strong>（按信息增益比划分），<strong>CART算法</strong>（按最小基尼指数划分）都是为了达到最佳分裂的效果。</p>
</li>
<li>最大信息增益会倾向于<strong>可取值较多</strong>的特征，最大信息增益比会倾向于<strong>可取值较少的特征</strong>。</li>
</ul>
<h4 id="2、决策树和集成学习"><a href="#2、决策树和集成学习" class="headerlink" title="2、决策树和集成学习"></a>2、决策树和集成学习</h4><ul>
<li>决策树模型很简单，简单到即使你不懂机器学习，也能很快了解他，可能有人会说，这么简单的模型有什么用。哈哈，数学的伟大，在于复杂的问题简单化，深度学习的强大在于利用将简单的神经网络不断加深；决策树虽然简单，但是很多个决策树在一起，就足够让很多浅层机器学习算法忘而却步。</li>
<li><p>这个将许多决策树整合一起的方式就是集成学习，在集成学习中，决策树是个体学习器，当然个体学习器可以是别的弱学习器。</p>
</li>
<li><p>而根据个体学习器生成方式的不同，目前集成学习方法大致可分为两大类，即个体学习器间存在<strong>强依赖关系</strong>、必须串行生成的序列化方法，以及个体学习器间<strong>不存在强依赖关系</strong>、可同时生成的并行化方法；前者的代表是<strong>Boosting </strong> 和 <strong>梯度提升树</strong>(GBDT)，后者的代表是和<strong>Bagging</strong>和 <strong>随机森林</strong>（Random Forest）</p>
</li>
</ul>
<h3 id="二、决策树"><a href="#二、决策树" class="headerlink" title="二、决策树"></a>二、决策树</h3><h4 id="1、决策树中需关注问题"><a href="#1、决策树中需关注问题" class="headerlink" title="1、决策树中需关注问题"></a>1、决策树中需关注问题</h4><ul>
<li><p>一棵树是如何构建的？建树过程中，树分裂节点时，如何选出最优的属性作为分裂节点。</p>
</li>
<li><p>如何用树的减枝来避免过拟合问题。</p>
</li>
<li><p>对于含有空值的数据，如何构建树。</p>
</li>
<li><p>构建树可能存在的问题，过拟合问题，如何解决</p>
</li>
</ul>
<h4 id="2、如何构建一棵树"><a href="#2、如何构建一棵树" class="headerlink" title="2、如何构建一棵树"></a>2、如何构建一棵树</h4><p>简言之：<strong>选择最优划分属性作为分裂结点，使得分支结点中所包含的样本尽可能属于同一类</strong>。树的生成算法有三种：ID3、C4.5和CART.</p>
<h5 id="1、ID3"><a href="#1、ID3" class="headerlink" title="1、ID3"></a>1、ID3</h5><p>选择<strong>最大信息增益(Information Gain)</strong>规则去寻找最优分裂节点</p>
<h5 id="1-1、基础概念"><a href="#1-1、基础概念" class="headerlink" title="1-1、基础概念"></a>1-1、基础概念</h5><ul>
<li><p>信息熵(Information entropy)：表示随机变量不确定性的度量；<strong>熵越大，随机变量的不确定性就越大</strong>；(我们希望分类后的结果熵越小越好)。</p>
</li>
<li><p>信息增益(Information gain)：表示因特征X的信息而使得类Y信息不确定性减少的程度。(当然是越大越好）；<br>$$<br>g(D,A) = H(D) - H(D|A)<br>$$</p>
</li>
</ul>
<p>在划分过程中，找到信息增益最大的特征将样本根据此特征划分不同的结点中，新的结点中继续划分。</p>
<h5 id="1-2、不足"><a href="#1-2、不足" class="headerlink" title="1-2、不足"></a>1-2、不足</h5><ul>
<li>信息增益反应的是：给点条件后，不确定性减少的程度，<strong>特征取值越多，意味着确定性越高，也就是条件熵越小，信息增益越大。</strong>这就造成信息增益对<strong>可取值较多</strong>的属性有所偏好。</li>
<li>ID3只能处理离散型变量，只能处理分类任务</li>
<li>对样本特征缺失值比较敏感</li>
</ul>
<h5 id="2、C4-5"><a href="#2、C4-5" class="headerlink" title="2、C4.5"></a>2、C4.5</h5><p>选择<strong>最大信息增益比(Information Gain Ratio)</strong>规则去寻找最优分裂节点</p>
<h5 id="2-1、基础概念"><a href="#2-1、基础概念" class="headerlink" title="2-1、基础概念"></a>2-1、基础概念</h5><ul>
<li><strong>信息增益比(Information Gain Ratio)</strong>: 特征A对训练数据集D的信息增益比为其 信息增益与训练数据集D关于特征A的值的熵之比。<br>$$<br>g_R(D,A) =\frac{g(D,A)}{H_A(D)}<br>$$</li>
</ul>
<p>在划分过程中，找到信息增益比最大的特征将样本根据此特征划分不同的结点中，新的结点中继续划分。</p>
<h5 id="2-2、不足"><a href="#2-2、不足" class="headerlink" title="2-2、不足"></a>2-2、不足</h5><ul>
<li>C4.5 对ID3做了优化，使用信息增益比在一定程度上对取值较多的特征进行了惩罚，避免ID3出现的过拟合特性，提升了决策树的泛化能力。</li>
<li>C4.5 能处理连续型变量和离散型变量，但是只能处理分类任务。</li>
</ul>
<h5 id="3、CART"><a href="#3、CART" class="headerlink" title="3、CART"></a>3、CART</h5><p>选择<strong>最小基尼指数(Gini index)</strong>规则去寻找最优分裂节点</p>
<h5 id="3-1、基础概念"><a href="#3-1、基础概念" class="headerlink" title="3-1、基础概念"></a>3-1、基础概念</h5><ul>
<li>基尼指数：表示数据的纯度<br>$$<br>Cini(D) = 1 - \sum_{k=1}^n(\frac{|C_k|}{|D|})^2<br>$$</li>
</ul>
<p>利用基尼指数最小选择最优分裂点，采用二元切割法</p>
<h5 id="3-2、特点"><a href="#3-2、特点" class="headerlink" title="3-2、特点"></a>3-2、特点</h5><ul>
<li>不仅能处理分类任务，还能处理回归任务</li>
<li>不仅能处理离散型变量，还能处理连续型变量</li>
<li>能够处理样本特征数据缺失的情况</li>
</ul>
<h4 id="3、树的剪枝"><a href="#3、树的剪枝" class="headerlink" title="3、树的剪枝"></a>3、树的剪枝</h4><h5 id="3-1、预剪枝"><a href="#3-1、预剪枝" class="headerlink" title="3-1、预剪枝"></a>3-1、预剪枝</h5><p>阈值、</p>
<h5 id="3-2、后剪枝"><a href="#3-2、后剪枝" class="headerlink" title="3-2、后剪枝"></a>3-2、后剪枝</h5><h3 id="三、梯度提升树-和-随机森林"><a href="#三、梯度提升树-和-随机森林" class="headerlink" title="三、梯度提升树 和 随机森林"></a>三、梯度提升树 和 随机森林</h3><ul>
<li><p>梯度提升树，GBDT，特征组合的一把好手</p>
</li>
<li><p>随机森林 RF</p>
</li>
<li><p>基于决策树实现的GBDT、RF（随机森林）、Xgboost 和 lightGBM都在数据竞赛和工程中都大展身手。</p>
</li>
<li><p><a href="https://github.com/e-snail/understanding_machine_learning/tree/master/3_decision_tree" target="_blank" rel="noopener">https://github.com/e-snail/understanding_machine_learning/tree/master/3_decision_tree</a></p>
</li>
<li><p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/tree.html" target="_blank" rel="noopener">决策树API</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/11/17/ML01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/17/ML01/" itemprop="url">机器学习杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-17T22:20:28+08:00">
                2018-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,861 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>高能预警</strong>：本人非算法开发，以下是我的一些浅见。</p>
<h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><p>自有机器学习以来，算法模型中就有了区分；分为监督学习，无监督学习，半监督学习和强化学习等。</p>
<h4 id="1、监督学习"><a href="#1、监督学习" class="headerlink" title="1、监督学习"></a>1、监督学习</h4><ul>
<li><p>机器学习中<strong>大部分任务</strong>都是监督学习任务；在监督学习中，分类和回归是其两大主题。分类中名声最大的是：<strong>逻辑回归</strong>(Logistic regression)、<strong>朴素贝叶斯</strong>(Naive Bayes) 和 <strong>支持向量机</strong>(Support Vector Machine，SVM) 。</p>
</li>
<li><p>在工业界曾经有<strong>一招LR打天下</strong>的”传说”，这里的LR就是逻辑回归；早些年做CTR预估时候，<strong>人工特征海洋 + LR</strong>用得非常多，很多算法工程师大部分时间埋头搞特征工程；</p>
</li>
<li><strong>朴素贝叶斯</strong>(Naive Bayes)是个开挂的存在，它将<strong>贝叶斯原理</strong>应用到机器学习中，而后机器学习中贝叶斯学派声明鹊起，与旧贵族统计学派在机器学习中鼎足而立；它强假设输入的数据的特征都是独立的，在文本分类中表现出很好的效果，可谓是入门nlp都必须了解的算法之一了。</li>
<li><strong>支持向量机</strong>(Support Vector Machine，SVM) 当之无愧是监督学习中的无冕之王，自上世纪90年代诞生之后，在机器学习界掀起“腥风血雨”，它利用核技巧，在属于两个不同类别的两组数据之间找到良好的分类边界，将线性不可分问题转为高纬空间的线性可分问题，借此达到了分类的目的。因为SVM的存在，将<strong>多层神经网络</strong>的研究打进冷宫；多层神经网络是深度学习的前身。直到2012年，因为深度学习在ImageSet竞赛中的完胜，神经网络的研究才再次复苏，直至形成今天的野火燎原之势。</li>
<li>监督学习中另一个主题是回归，最基础的的当然是<strong>线性回归</strong>(Linear regression)，模型虽然简单，但是预测个房价，股票价格这种高大上的事情也还是有着不错的表现。</li>
<li>非监督学习比较尴尬，在工业界，更多起到打辅助的左右；有聚类，降维和关联规则三大主题，聚类中用的较多反而是简单的K-means，PCA和SVD用来做数据降维，关联规则那块好像在推荐系统用的稍微多些。</li>
</ul>
<h4 id="2、决策树和集成学习"><a href="#2、决策树和集成学习" class="headerlink" title="2、决策树和集成学习"></a>2、决策树和集成学习</h4><ul>
<li>决策树是监督学习中比较特殊的模型，说他特殊，是因为它不像LR、SVM和NB直接上手，大家喜欢使用将决策树作为集成学习的基础学习器，比较著名的是<strong>随机森林</strong>(Random Forest)、<strong>梯度提升树</strong>(GBDT)，决策树的实现经历了ID3, C4.5，CART三个阶段，在随机森林、梯度提升树里面用的是CART这个分类回归树。从CART的名字也看出来，不仅仅可以做回归，也能做分类。粗暴理解就是，分类时候好多CART投票分类结果，回归时候，取CART预测值得平均数。</li>
<li>GBDT有个超级经典的实现，XgBoost。在Kaggle比赛中，XgBoost近乎霸主级别的存在；江湖有传言，图片图像等机器学习问题用Keras（深度学习库），浅层机器学习用XgBoost。</li>
</ul>
<h4 id="3、神经网络和深度学习的渊源"><a href="#3、神经网络和深度学习的渊源" class="headerlink" title="3、神经网络和深度学习的渊源"></a>3、神经网络和深度学习的渊源</h4><ul>
<li>我认为，没有神经网络，就没有深度学习；虽然业界有说法，不用神经网络就也能实现深度学习；但是神经网络真的真的很厉害，虽然很长一段时间不被看好，因为两层的神经网络连个异或都处理不了，的确有理由被看不上；但是随着反向传播算法发现，神经网络层数不断加深，在工业界发挥牛逼闪闪的光芒。</li>
<li>你可能想不到，权重，阈值，激活函数这些简简单单的东西，怎么能解决计算机视觉、语音识别这种非常难的问题，这些问题连当年风光无限的SVM都败下阵来。</li>
</ul>
<h4 id="4、特征工程"><a href="#4、特征工程" class="headerlink" title="4、特征工程"></a>4、特征工程</h4><ul>
<li><p>有句老话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。在传统机器学习领域，做好特征工程很重要；工业界有句老话，70%多的时间在做特征工程；</p>
</li>
<li><p>比较尴尬的是，市面上多是讲解机器学习算法模型的书，讲解算法和模型的奥妙是他们的主题，提供的试验数据也都是已经处理好的，并不需要特征工程处理，但是实际工程中不是这样。特征工程的处理依赖领域知识和经验依旧是主流，但是业界很多项目处于安全、隐私等考虑，不会透露底层的特征工程的处理。</p>
</li>
</ul>
<h4 id="5、特征工程-amp-深度学习"><a href="#5、特征工程-amp-深度学习" class="headerlink" title="5、特征工程 &amp; 深度学习"></a>5、特征工程 &amp; 深度学习</h4><ul>
<li>深度学习有自动获取特征的能力，可以对输入的低阶特征进行组合、变换，得到高阶特征，但是这个能力只是对于某些领域(如图像、语音)有比较好的效果。</li>
<li>在其他领域，如自然语言处理中，输入的字或词都是离散、稀疏的值，不像图片一样是连续、稠密的。输入原始数据进行组合、变换得到的高阶特征并不是那么有效。而且有的语义并不来自数据，而来自人们的先验知识，所以利用先验知识构造的特征是很有帮助的。</li>
<li>总的来说，在深度学习中，特征工程仍然适用；神经网络能对特征自动进行排列组合，所以只要输入一阶特征就行，省去了手动构造高阶特征的工作量。</li>
</ul>
<h4 id="6、模型评估"><a href="#6、模型评估" class="headerlink" title="6、模型评估"></a>6、模型评估</h4><ul>
<li>模型评估很重要，是向别人证明你的模型怎么好的依据，我也就知道过拟合、欠拟合、交差验证、ROC、分类中查全率，查准率这些概念，没有个比较整体的认识，后面抽时间了解后再来补充。</li>
</ul>
<h3 id="二、常见的监督学习算法模型"><a href="#二、常见的监督学习算法模型" class="headerlink" title="二、常见的监督学习算法模型"></a>二、常见的监督学习算法模型</h3><p>哈哈，先留坑，后面慢慢填</p>
<h4 id="1、LR（逻辑回归）"><a href="#1、LR（逻辑回归）" class="headerlink" title="1、LR（逻辑回归）"></a>1、LR（逻辑回归）</h4><ul>
<li>线性模型的基础上增加了sigmoid函数，处理二分类问题，广义的线性模型，在CTR预估中有大作用</li>
</ul>
<h4 id="2、SVM-支持向量机"><a href="#2、SVM-支持向量机" class="headerlink" title="2、SVM(支持向量机)"></a>2、SVM(支持向量机)</h4><ul>
<li><p>可以处理非线性问题，深度学习未火之前，是学术界和工业界的热点，</p>
<p>数据规模较小时，能够构建出数据间的非线性关系，</p>
<p>1、SVM的原始公式是如何由实际问题产生，算法的灵魂</p>
<p>2、SVM原始问题到对偶问题的数学推导公式</p>
</li>
</ul>
<h4 id="3、NB-朴素贝叶斯"><a href="#3、NB-朴素贝叶斯" class="headerlink" title="3、NB(朴素贝叶斯)"></a>3、NB(朴素贝叶斯)</h4><ul>
<li>基于贝叶斯定理的一组有监督学习算法，<strong>朴素</strong>：“简单”地假设每对特征之间相互独立；</li>
<li>在很多实际情况下，朴素贝叶斯工作得很好，特别是<strong>文档分类</strong>和<strong>垃圾邮件过滤</strong>。这些工作都要求 一个小的训练集来估计必需参数。</li>
</ul>
<p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/naive_bayes.html" target="_blank" rel="noopener">http://sklearn.apachecn.org/cn/0.19.0/modules/naive_bayes.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/03/24/iOS-iOSLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/24/iOS-iOSLock/" itemprop="url">多线程锁小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T18:21:40+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,439 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>在并发编程中，<strong>锁是一种同步机制</strong>，用于限制多线程环境中对资源的访问。 ibireme 在《<a href="https://link.jianshu.com/?t=https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a>》中的一张图片说明加解锁的效率：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-514c86e036c415bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="lock"></p>
<p><strong>说明</strong>：锁的效率并不值的是加解锁的速度，而是加解锁操作在执行时的复杂程度。</p>
<h5 id="1、OSSpinLock-自旋锁"><a href="#1、OSSpinLock-自旋锁" class="headerlink" title="1、OSSpinLock(自旋锁)"></a>1、OSSpinLock(自旋锁)</h5><ul>
<li><p>OSSpinLock存在优先级反转的问题，在iOS10之后已经废弃，使用os_unfair_lock替代(中间有段时间用了pthread_mutex ), os_unfair_lock 是iOS 10.0新推出的锁，用于解决OSSpinLock优先级反转问题。</p>
</li>
<li><p>自旋锁会忙等，不会进入睡眠状态</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OSSpinLock oslock = OS_SPINLOCK_INIT;</span><br><span class="line">OSSpinLockLock(&amp;oslock);</span><br><span class="line">OSSpinLockUnlock(&amp;oslock);</span><br></pre></td></tr></table></figure>
<h5 id="2、pthread-mutex-互斥锁"><a href="#2、pthread-mutex-互斥锁" class="headerlink" title="2、pthread_mutex (互斥锁)"></a>2、pthread_mutex (互斥锁)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t _lock;</span><br><span class="line">//初始化</span><br><span class="line">pthread_mutex_init(&amp;pLock, NULL);</span><br><span class="line">//加锁和释放锁</span><br><span class="line">pthread_mutex_lock(&amp;pLock);</span><br><span class="line">pthread_mutex_unlock(&amp;pLock);</span><br><span class="line">//销毁</span><br><span class="line">pthread_mutex_destroy(&amp;_lock);</span><br></pre></td></tr></table></figure>
<p><strong>说明1</strong>：加锁后，加锁后同一个时间点只能有一个线程能访问，后面的线程需要排队，并且 lock 和 unlock 是对应出现的，**同一线程多次 lock 是不允许的。</p>
<p><strong>说明2</strong>：一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃(死锁)。如果需要在同一线程多次获取一个锁，就需要递归锁。</p>
<p><strong>说明3</strong>：对于互斥锁，假设在已经获得锁的情况下再次申请锁，线程会<strong>因为等待锁的释放而进入睡眠状态</strong>，因此就不可能再释放锁，从而导致死锁。</p>
<h5 id="3、-pthread-mutex-recursive"><a href="#3、-pthread-mutex-recursive" class="headerlink" title="3、 pthread_mutex(recursive)"></a>3、 pthread_mutex(recursive)</h5><ul>
<li>同一个线程可以多次获取同一个递归锁，不会产生死锁。</li>
<li>如果一个线程多次获取同一个非递归锁，则会产生死锁。</li>
<li>递归锁允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_sync_enter/objc_sync_exit</span><br></pre></td></tr></table></figure>
<h5 id="4、NSLock"><a href="#4、NSLock" class="headerlink" title="4、NSLock"></a>4、NSLock</h5><ul>
<li><p>NSLock 只是在内部封装了一个 <strong>pthread_mutex</strong>，属性为 <strong>PTHREAD_MUTEX_ERRORCHECK</strong>，它会损失一定性能换来错误提示。</p>
</li>
<li><p>NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</p>
</li>
</ul>
<h5 id="5、NSCondition"><a href="#5、NSCondition" class="headerlink" title="5、NSCondition"></a>5、NSCondition</h5><ul>
<li>NSCondition的底层是通过条件变量(condition variable) <strong>pthread_cond_t</strong> 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。</li>
</ul>
<h5 id="6、NSRecursiveLock"><a href="#6、NSRecursiveLock" class="headerlink" title="6、NSRecursiveLock"></a>6、NSRecursiveLock</h5><ul>
<li><p>递归锁也是通过 <strong>pthread_mutex_lock</strong> 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。</p>
</li>
<li><p>NSRecursiveLock 与 NSLock 的区别在于内部封装的 <strong>pthread_mutex_t</strong> <strong>对象的类型不同</strong>，前者的类型为 PTHREAD_MUTEX_RECURSIVE。</p>
</li>
</ul>
<h5 id="7、同步锁-synchronized"><a href="#7、同步锁-synchronized" class="headerlink" title="7、同步锁 synchronized"></a>7、同步锁 synchronized</h5><ul>
<li><p>OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。</p>
</li>
<li><p>@synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。</p>
</li>
</ul>
<h5 id="8、信号量-dispatch-semaphore"><a href="#8、信号量-dispatch-semaphore" class="headerlink" title="8、信号量 dispatch_semaphore"></a>8、信号量 dispatch_semaphore</h5><ul>
<li>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。<strong>在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量</strong></li>
</ul>
<h5 id="9、NSConditionLock-条件锁"><a href="#9、NSConditionLock-条件锁" class="headerlink" title="9、NSConditionLock 条件锁"></a>9、NSConditionLock 条件锁</h5><ul>
<li>NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值:</li>
</ul>
<h4 id="二、OSSpinLock为什么不安全"><a href="#二、OSSpinLock为什么不安全" class="headerlink" title="二、OSSpinLock为什么不安全"></a>二、OSSpinLock为什么不安全</h4><h5 id="1、优先级反转的解释-不认可"><a href="#1、优先级反转的解释-不认可" class="headerlink" title="1、优先级反转的解释(不认可)"></a>1、优先级反转的解释(不认可)</h5><ul>
<li>自旋锁<strong>OSSpinLock</strong>的问题引起大家对<strong>优先级反转</strong>的关注，一般认为是：低优先级线程拿到锁时，高优先级线程进入忙等，消耗太多CPU时间，导致低优先级线程拿不到CPU时间，无法完成任务并释放锁，致使高优先级线程不能被执行（<strong>这个理解是不准确的</strong>）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。</span><br><span class="line">高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。</span><br><span class="line">这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</span><br><span class="line">具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，</span><br><span class="line">它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，</span><br><span class="line">从而导致任务迟迟完不成、无法释放 lock。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 摘自<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
<h5 id="2、优先级反转"><a href="#2、优先级反转" class="headerlink" title="2、优先级反转"></a>2、优先级反转</h5><ul>
<li><p><strong>优先级反转</strong>(Priority Inversion)是 由于多线程共享资源，具有最高优先权的线程被低优先级线程阻塞，反而使具有中优先级的线程先于高优先级的线程执行。（可类推到多进程的优先级反转）</p>
</li>
<li><p>产生优先级反转的条件：假设有高优先级的任务线程为<strong>High</strong>、中优先级的任务为<strong>Mid</strong>、低优先级的任务线程为<strong>Low</strong>；优先级是High &gt; Mid &gt; Low; 触发需要满足3个条件</p>
</li>
<li><p>High线程要访问一个被Low线程占有的资源，因为得不到，High线程被阻塞；</p>
</li>
<li><p>此时，Middle线程启动执行，因为Middle优先级比Low高，导致占有资源的Low线程被挂起，但是Low占用的资源并没有释放；甚至于因为Low的优先级足够低，一直被其他的任务挂起，导致占有的资源一直不能释放，High线程一直无法得到机会执行。</p>
</li>
<li><p>High任务因为一直不能获取被Low任务占用的资源，导致比它优先低的任务却可以执行。</p>
</li>
</ul>
<h5 id="3、优先级反转的解决办法"><a href="#3、优先级反转的解决办法" class="headerlink" title="3、优先级反转的解决办法"></a>3、优先级反转的解决办法</h5><p><strong>解决的思路</strong>是：<strong>提高占有资源线程的优先级</strong>，使其可以执行，并在执行完后释放资源；以让其他线程可以获取资源；<strong>常见的解决方法</strong>有2种，<strong>优先级继承</strong>(priority inheritance) 或 <strong>优先级极限</strong>(priority ceilings)。</p>
<p><strong>1）优先级继承(priority inheritance)</strong></p>
<ul>
<li><p>提升<strong>低优先级线程</strong> 的优先级，优先级等于  等待其占有的资源的，最高优先级任务的优先级；</p>
</li>
<li><p>换言之，当高优先级任务由于等待资源而被阻塞时，此时资源的拥有者的优先级将会自动被提升。</p>
</li>
</ul>
<p><strong>2）优先级天花板(priority ceilings)</strong></p>
<ul>
<li>将申请某资源的线程优先级，提升到可能访问该资源的所有任务中最高优先级任务的优先级。</li>
</ul>
<p><strong>说明</strong>： 优先级继承，只有当占有资源的低优先级的任务被阻塞时,才会提高占有资源任务的优先级；而优先级天花板，不论是否发生阻塞,都提升。</p>
<h5 id="4、OSSpinLock弃用"><a href="#4、OSSpinLock弃用" class="headerlink" title="4、OSSpinLock弃用"></a>4、OSSpinLock弃用</h5><ul>
<li>在发现OSSpinLock之前，Apple使用OSSpinLock来保证线程安全；发现问题后，将OSSpinLock 替换成了os_unfair_lock（iOS 10之后，中间有段时间用了pthread_mutex） os_unfair_lock 是iOS 10.0新推出的锁，用于解决OSSpinLock优先级反转问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">// 加锁</span><br><span class="line">os_unfair_lock_lock(unfairLock);</span><br><span class="line">// 解锁</span><br><span class="line">os_unfair_lock_unlock(unfairLock);</span><br><span class="line">// 尝试加锁</span><br><span class="line">BOOL b = os_unfair_lock_trylock(unfairLock);</span><br></pre></td></tr></table></figure>
<h4 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h4><h5 id="1、属性使用atomic修饰能保证线程安全"><a href="#1、属性使用atomic修饰能保证线程安全" class="headerlink" title="1、属性使用atomic修饰能保证线程安全"></a>1、属性使用atomic修饰能保证线程安全</h5><ul>
<li><p>不能， atomic修饰的属性，会给setter,getter方法加锁，保证该操作是原子的(nonatomic不会为setter、getter方法加锁), 但不能保证线程安全</p>
</li>
<li><p>当使用atomic时，虽然对<strong>属性的读和写是原子性的</strong>，但是仍然可能出现<strong>线程错误：</strong>当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，<strong>这就破坏了线程安全</strong>，如果有线程C在A线程读操作前<strong>release</strong>了该属性，那么还会导致程序崩溃。所以仅仅使用atomic并不会使得线程安全，我们还要为线程添加lock来确保线程的安全。</p>
</li>
</ul>
<h5 id="2、自旋锁-amp-互斥锁"><a href="#2、自旋锁-amp-互斥锁" class="headerlink" title="2、自旋锁 &amp; 互斥锁"></a>2、自旋锁 &amp; 互斥锁</h5><ul>
<li><p>线程安全中为了实现<strong>线程阻塞</strong>，一般有两种方案：一种是<strong>让线程处于休眠状态</strong>，此时不会消耗 CPU 资源；另一种方案是<strong>让线程忙等或空转</strong>，此时会消耗一定的 CPU 资源。前者属于互斥，后者属于自旋。</p>
</li>
<li><p>自旋在线程加锁的情况下，会一直尝试是否解锁，如果没有解锁，会一直循环判断，如果锁已经放开，则继续执行，不再是空转状态。OSSpinLock 属于自旋锁，Pthread 库中相关的锁，以及 NSLock、@synchronized 等都属于互斥锁。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="南华coder" />
            
              <p class="site-author-name" itemprop="name">南华coder</p>
              <p class="site-description motion-element" itemprop="description">天之道，损有余而补不足</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南华coder</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">56.3k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
