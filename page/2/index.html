<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="南华coder的空间" type="application/atom+xml" />






<meta name="description" content="天之道，损有余而补不足">
<meta property="og:type" content="website">
<meta property="og:title" content="南华coder的空间">
<meta property="og:url" content="http://buaa0300/nanhuacoder.com/page/2/index.html">
<meta property="og:site_name" content="南华coder的空间">
<meta property="og:description" content="天之道，损有余而补不足">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南华coder的空间">
<meta name="twitter:description" content="天之道，损有余而补不足">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://buaa0300/nanhuacoder.com/page/2/"/>





  <title>南华coder的空间</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">南华coder的空间</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/11/21/Recommend01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/21/Recommend01/" itemprop="url">推荐迷雾(一):再见推荐系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-21T22:55:30+08:00">
                2018-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/推荐/" itemprop="url" rel="index">
                    <span itemprop="name">推荐</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,332 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><em>花非花，雾非雾。夜半来，天明去。来如春梦不多时，去似朝云无觅处。</em></p>
<p>​    用白居易的诗作为《推荐迷雾》系列的开始，本人非推荐算法工程师，但是工作中也和算法打过些交道，也曾于13年粗读过项亮博士的《推荐系统实战》，这本12年出版的“旧”书如今再读起来，更多一番体会；虽然近些年，机器学习尤其是深度学习给传统推荐学习带来新的变化，但是这些新兴的推荐技术依旧有传统的推荐算法模型的影子。</p>
<p><img src="/nanhuacoder.com/2018/11/21/Recommend01/jianghu.jpeg" alt="江湖"></p>
<h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><ul>
<li>推荐产生的背景：信息过载，用户需求不确定</li>
<li>推荐三步骤：召回，预估和排序</li>
</ul>
<h3 id="二、推荐系统的评估指标和方法"><a href="#二、推荐系统的评估指标和方法" class="headerlink" title="二、推荐系统的评估指标和方法"></a>二、推荐系统的评估指标和方法</h3><h4 id="1、评估指标"><a href="#1、评估指标" class="headerlink" title="1、评估指标"></a>1、评估指标</h4><h5 id="1-1、评分预测的评估"><a href="#1-1、评分预测的评估" class="headerlink" title="1-1、评分预测的评估"></a>1-1、评分预测的评估</h5><ul>
<li><p>RMSE (均方根误差，加大预测不准物品评分的惩罚)</p>
</li>
<li><p>MAE（平均绝对误差）</p>
</li>
</ul>
<h5 id="1-2、TopN推荐的评估"><a href="#1-2、TopN推荐的评估" class="headerlink" title="1-2、TopN推荐的评估"></a>1-2、TopN推荐的评估</h5><ul>
<li>在这里用到了<strong>准确率</strong>、<strong>召回率</strong>和<strong>F-1 Score</strong>三个度量值</li>
<li><strong>召回率</strong>（Recall）：用户消费的内容，是由推荐提供的占比</li>
<li><strong>准确率</strong>（Precision）：推荐的内容中，用户消费的占比</li>
<li><strong>F-1 Score</strong> </li>
</ul>
<p>$$<br>F_1 Score = \frac{2 x recall * precision}{recall + precision}<br>$$</p>
<p><strong>召回率</strong>表示在原始样本的正样本中，最后被正确预测为正样本的概率；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算召回率和准确率</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrecisionRecall</span><span class="params">(test,N)</span>:</span></span><br><span class="line">	hit = <span class="number">0</span></span><br><span class="line">	n_recall = <span class="number">0</span></span><br><span class="line">	n_precision = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> user,item <span class="keyword">in</span> test.items():</span><br><span class="line">		rank = Recommend(user,N)</span><br><span class="line">		hit += len(rank &amp; items)</span><br><span class="line">		n_recall += len(items)</span><br><span class="line">		n_precision += N</span><br><span class="line">	<span class="keyword">return</span> [hit/(<span class="number">1.0</span> * n_recall),hit/(<span class="number">1.0</span>*n_precision)]</span><br></pre></td></tr></table></figure>
<ul>
<li>为了全面评估TopN推荐的准确率和召回率，一般选取不同推荐列表长度N，计算一组准确率/召回率，然后画出准确率/召回率曲线。</li>
<li>在工程实践中，TopN推荐更合适，因为对于推荐的内容来说，预测用户会不会看，比预测用户看了内容后给多少分更重要。</li>
</ul>
<h5 id="1-3、覆盖率"><a href="#1-3、覆盖率" class="headerlink" title="1-3、覆盖率"></a>1-3、覆盖率</h5><p>推荐系统对物品长尾的发掘能力，简单的定义是推荐物品占总物品集合的比例。当然还有更好的指标来定义覆盖率。</p>
<ul>
<li>信息熵：</li>
<li>基尼系数：</li>
</ul>
<h5 id="1-3、其他指标"><a href="#1-3、其他指标" class="headerlink" title="1-3、其他指标"></a>1-3、其他指标</h5><ul>
<li>多样性、新颖性、惊喜度、信任度、实时性、健壮性，商业目标等等，具体参考《推荐系统实战》中的内容</li>
</ul>
<h4 id="2、评估方法"><a href="#2、评估方法" class="headerlink" title="2、评估方法"></a>2、评估方法</h4><ul>
<li><p>离线评估：速度快，不需要用户参与；在用户的历史数据上做评估，和线上真实效果有偏差；只能评估少数指标。</p>
</li>
<li><p>用户调查：主要的形式是问卷调查，成本高</p>
</li>
<li><p>在线实验：目前最普遍的做法是ABtest，目前主采用多层重叠实验设计，这些在后面的文章重点介绍</p>
</li>
</ul>
<h3 id="三、推荐系统架构"><a href="#三、推荐系统架构" class="headerlink" title="三、推荐系统架构"></a>三、推荐系统架构</h3><ul>
<li>推荐系统是产品的核心，而推荐算法仅仅是推荐系统中的一部分；以NetFlix的推荐系统架构为例，介绍经典的推荐系统架构。</li>
<li>在NetFlix推荐系统架构中，分为三层：Offline层（离线层）、Nearline层（近线层）和  Online层（在线层）</li>
</ul>
<h4 id="1、Offline层（离线层）"><a href="#1、Offline层（离线层）" class="headerlink" title="1、Offline层（离线层）"></a>1、Offline层（离线层）</h4><ul>
<li>这一层批量、周期性地<strong>抽取数据</strong>，<strong>训练模型</strong>；训练得到的模型可以用于为用户计算推荐结果。协同过滤、矩阵分解一般在这层做，Hadoop、Spark分布式计算也在这一层。</li>
<li>Offline阶段的推荐结果或模型在Nearline层被更新，产生最终的推荐结果，呈现给用户。</li>
</ul>
<h4 id="2、Nearline层（近线层）"><a href="#2、Nearline层（近线层）" class="headerlink" title="2、Nearline层（近线层）"></a>2、Nearline层（近线层）</h4><ul>
<li>Nearline要处理处理实时数据流(流计算），执行计算任务：从事件队列中获取最新的一个或少许几个用户反馈行为，将这些用户已经反馈过的物品从离线推荐结果中剔除，然后用这几个反馈行为作为样本，以小批量梯度下降的优化方法去更新融合模型的参数。</li>
</ul>
<h4 id="3、Online层（在线层）"><a href="#3、Online层（在线层）" class="headerlink" title="3、Online层（在线层）"></a>3、Online层（在线层）</h4><ul>
<li>用户使用App/浏览Web，消费展示内容，产生行为事件数据，如页面曝光，按钮点击等，实时被收集走，一边进入分布式文件系统中做存储，给Offline使用，一边流向Nearline的<strong>消息队列</strong>，供Nearline的<strong>流计算</strong>使用。</li>
<li>用户发出请求，等待推荐结果；Online层必须实施响应用户请求，要快，要有兜底，Online层处理的一般是已经预处理后的推荐结果。</li>
</ul>
<h3 id="四、推荐系统中的冷启动和EE问题"><a href="#四、推荐系统中的冷启动和EE问题" class="headerlink" title="四、推荐系统中的冷启动和EE问题"></a>四、推荐系统中的冷启动和EE问题</h3><ul>
<li>在推荐系统中有两个经典问题：<strong>冷启动</strong>和<strong>EE</strong>(探索和利用问题)。</li>
<li>Bandit算法提供了一种有效的解决办法；其中<strong>冷启动</strong>的本质是：推荐系统没有历史数据，无法预测用户偏好；可分为用户冷启动，物品冷启动和系统冷启动。<strong>EE问题</strong>是指，是选择现在不确定的一些方案，但未来可能会有高收益的方案；还是选择现在可能最佳的方案；本质是一个选择的问题。</li>
<li>Bandit 算法来源于历史悠久的赌博学，它要解决这样的问题：一个赌徒去摇老虎机，赌场中有的老虎机一模一样，但是每个老虎机吐钱的概率不一样，他不知道每个老虎机吐钱的概率分布是什么，那么每次该选择哪个老虎机可以做到最大化收益呢？这就是<strong>多臂赌博机问题</strong>（Multi-armed bandit problem, K-armed bandit problem, MAB）</li>
</ul>
<p><img src="/nanhuacoder.com/2018/11/21/Recommend01/mab.png" alt="MAB问题"></p>
<ul>
<li><p>假设我们已经经过一些试验，得到了当前每个老虎机的吐钱的概率，如果想要获得最大的收益，我们会一直摇哪个吐钱概率最高的老虎机，这就是Exploitation。但是，当前获得的信息并不是老虎机吐钱的真实概率，可能还有更好的老虎机吐钱概率更高，因此还需要进一步探索，这就是Exploration问题。</p>
</li>
<li><p>Bandit解决MAB或者EE问题的策略是：有策略地走一步看一步，这些策略就是Bandit算法，经典的Bandit算法分别是：<strong>朴素Bandit、汤普森采样、UCB和Epsilon贪婪算法</strong>。</p>
</li>
</ul>
<h4 id="1、朴素Bandit"><a href="#1、朴素Bandit" class="headerlink" title="1、朴素Bandit"></a>1、朴素Bandit</h4><p><strong>原理</strong>：先随机试若干次，计算每个臂的平均收益，一直选均值最大那个臂。</p>
<h4 id="2、汤普森采样-Thompson-sampling-算法"><a href="#2、汤普森采样-Thompson-sampling-算法" class="headerlink" title="2、汤普森采样(Thompson sampling)算法"></a>2、汤普森采样(Thompson sampling)算法</h4><p><strong>原理</strong>：</p>
<ul>
<li>每个臂维护一个beta(a，b)分布，每次用现有的beta分布产生一个随机数，输出随机数最大的臂（较快，随机性高）</li>
</ul>
<p><strong>beta(a，b)分布特点</strong>：</p>
<ul>
<li>a+b值越大，分布曲线就越窄，分布就越集中；</li>
<li>a/(a+b)值越大，分布中心越靠近1，反之越靠近0；</li>
</ul>
<p><strong>采样过程</strong>：</p>
<ul>
<li><p>假设a是用户的点击次数，b是没有得到用户的点击次数</p>
</li>
<li><p>每次取出所有候选的参数a和b，用贝塔分布产生一个随机数</p>
</li>
<li><p>随机数排序，输出最大值对应的候选</p>
</li>
<li><p>如果用户点击，对应的候选a加1，反之b加1</p>
</li>
</ul>
<p><strong>分析</strong>：</p>
<ul>
<li>如果一个候选被选中的次数很多（a+b很大），分布变窄，对应的分布产生的随机数基本在中心位置，接近平均收益。</li>
<li>如果a+b很大，a/(a+b)也很大，那么分布产生的随机数越接近1，平均收益很好，进入利用阶段；</li>
<li>如果a+b很小，说明候选的好坏不能确定，分布很宽，可能得到一个较大的随机数，排序时候可能被优先输出，起到了探索的目的。</li>
</ul>
<h4 id="3、UCB算法"><a href="#3、UCB算法" class="headerlink" title="3、UCB算法"></a>3、UCB算法</h4><p><strong>原理</strong>：</p>
<ul>
<li>以每个候选的平均收益作为基准线进行选择</li>
<li>对于每次被选择不足的给与照顾</li>
<li>选择倾向于那些确定收益较好的候选</li>
</ul>
<p><strong>简言之</strong>，均值越大，标准差越小，被选中的概率会越来越大 (相对慢一点，确定性高)</p>
<h4 id="4、Epsilon贪婪-Epsilon-Greedy-算法"><a href="#4、Epsilon贪婪-Epsilon-Greedy-算法" class="headerlink" title="4、Epsilon贪婪(Epsilon-Greedy)算法"></a>4、Epsilon贪婪(Epsilon-Greedy)算法</h4><p><strong>原理：</strong></p>
<ul>
<li>先选一个(0,1)之间较小的值，作为Epsilon，然后每次以1-epsilon的概率选取当前收益最大的臂，以epsilon的随机概率选取一个臂。（后期不需要较大探索，epsilon需要衰减）</li>
<li>Epsilon可以控制探索和利用的程度，Epsilon越接近0，在探索上就越保守；Epsilon越接近1，在探索上就越激进。</li>
</ul>
<p><img src="/nanhuacoder.com/2018/11/21/Recommend01/bandit-performance.png" alt="Bandit算法算法模拟试验效果"></p>
<p><strong>总结</strong>：UCB算法和汤普森采样算法效果更好些。</p>
<h3 id="五、Bandit算法的工程实现"><a href="#五、Bandit算法的工程实现" class="headerlink" title="五、Bandit算法的工程实现"></a>五、Bandit算法的工程实现</h3><p>​    上面介绍的<strong>朴素Bandit、汤普森采样、UCB和Epsilon贪婪算法</strong>都是经典的Bandit算法，在工程中很少使用；实际中，我们采用的是上下文Bandit算法，比较常见的是LinUCB算法和COFIBA算法</p>
<h4 id="1、LinUCB"><a href="#1、LinUCB" class="headerlink" title="1、LinUCB"></a>1、LinUCB</h4><p><strong>概述</strong>：</p>
<ul>
<li><p>传统的 Bandit 算法并没有考虑臂的特征信息，也就是说并没有考虑上下文信息，而yahoo在2010年提出的，一种结合上下文的 Bandit算法——LinUCB (linear UCB)算法。</p>
</li>
<li><p>LinUCB 算法可以将当前用户的特征、物品特征构成所有的相关特征，然后根据每个臂维护的特征系数,计算出预估收益。由于加入了特征，所以收敛速度比 UCB 更快。</p>
</li>
<li>LinUCB的不足：同时处理的候选臂数量不能太多，不超过几百个最佳。因为每一次要计算每一个候选臂的期望收益和置信区间，一旦候选太多，计算代价将不可接受。其实这也是所有的 Bandit 算法的缺点。</li>
</ul>
<p><strong>原理：</strong></p>
<ul>
<li><p>LinUCB 假设一个物品推送给用户之后，获得的收益与相关特征呈<strong>线性关系</strong>，这里的相关特征就是指上下文信息。LinUCB 有两个版本：<strong>Disjoint</strong> 和 <strong>Hybrid</strong>，Disjoint 表示不同臂之间的不相关，也就是说参数不共享，Hybrid 表示臂之间共享一些参数。</p>
</li>
<li><p>Disjoint 模型：假设每个臂包含一个物品，我们在每一次选择时，用户与物品的的特征构成了上下文信息，表示为 x，维度为 d，每个臂维护了一个 d 维的表示特征系数的向量 θ，使用 c 表示本次选择的收益，如果用户点击了就为 1，否则为 0。我们假定：</p>
</li>
</ul>
<p>  根据p’ + ∆来选择合适的臂。p’的计算基于有监督的学习方法。我们为每个老虎机维护一个特征向量D，同时上下文特征我们写作θ，然后通过收集的反馈进行有监督学习：</p>
<ul>
<li><p>加入特征信息，用User和Item的特征预估回报及其置信区间，选择置信区间上界最大的Item推荐，观察回报后更新线性关系的参数，以此达到试验学习的目的。</p>
</li>
<li><p>岭回归的求解，岭回归适合样本数少于特征的数据集。</p>
</li>
<li><p>参考：<a href="http://www.naodongopen.com/908.html" target="_blank" rel="noopener">结合上下文信息的Bandit算法—LinUCB算法</a></p>
</li>
</ul>
<h4 id="2、COFIBA"><a href="#2、COFIBA" class="headerlink" title="2、COFIBA"></a>2、COFIBA</h4><ul>
<li>2016年提出，COFIBA算法的不同有两个：<ol>
<li>基于用户聚类挑选最佳的Item（相似用户集体决策的Bandit）。</li>
<li>基于用户的反馈情况调整User和Item的聚类（协同过滤部分）。</li>
</ol>
</li>
<li>在时刻t，用户来访问推荐系统，推荐系统需要从已有的候选池子中挑一个最佳的物品推荐给他，然后观察他的反馈，用观察到的反馈来更新挑选策略。 这里的每个物品都有一个特征向量，所以这里的Bandit算法是context相关的。 这里依然是用岭回归去拟合用户的权重向量，用于预测用户对每个物品的可能反馈（payoff），这一点和linUCB算法是一样的</li>
</ul>
<ul>
<li><p>bandit结合协同过滤。</p>
<p><a href="https://blog.csdn.net/heyc861221/article/details/80129310" target="_blank" rel="noopener">https://blog.csdn.net/heyc861221/article/details/80129310</a></p>
</li>
</ul>
<h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><ul>
<li>Exploit-Explore这一对矛盾一直客观存在，Bandit算法是公认的一种比较好的解决EE问题的方案。但解决Explore，势必就是要冒险，势必要走向未知，而这显然就是会伤害用户体验的：明知道用户肯定喜欢A，你还偏偏以某个小概率给推荐非A。</li>
<li>实际上，很少有公司会采用这些理性的办法做Explore，反而更愿意用一些盲目主观的方式。究其原因，可能是因为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、互联网产品生命周期短，而Explore又是为了提升长期利益的，所以没有动力做；</span><br><span class="line">2、用户使用互联网产品时间越来越碎片化，Explore的时间长，难以体现出Explore 的价值；</span><br><span class="line">3、同质化互联网产品多，用户选择多，稍有不慎，用户用脚投票，分分钟弃你于不顾；</span><br><span class="line">4、已经成规模的平台，红利杠杠的，其实是没有动力做Explore的。</span><br></pre></td></tr></table></figure>
<ul>
<li>所以做Explore要精心设计，必须保证质量。</li>
</ul>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li><p>bandit添加对应的源码实现</p>
</li>
<li><p>ABTest的分层实验设计</p>
</li>
<li>召回中的协同过滤和隐语义模型, 矩阵分解</li>
<li>CTR预估的进化，特征工程 + LR -&gt; GBDT + LR -&gt; FM -&gt;FFM -&gt; DeepFM/Wide&amp;Deep/…</li>
<li>排序怎么做</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/11/20/ML02-DTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/20/ML02-DTree/" itemprop="url">机器学习中的树模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-20T23:33:16+08:00">
                2018-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,345 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><ul>
<li>在数据结构中，有树这种结构；在机器学习中，有决策树；咋一看，感觉是一回事，其实不然；</li>
<li><p>数据结构的树关注的事查找，插入，删除的效率，二叉树，平衡二叉树都是为了解决这些效率而产生的；</p>
</li>
<li><p>机器学习中的决策树关注的是，如何找到最佳分解节点，<strong>ID3算法</strong>(按最大信息增益划分)，<strong>C4.5</strong>（按信息增益比划分），<strong>CART算法</strong>（按最小基尼指数划分）都是为了达到最佳分裂的效果。</p>
</li>
<li>最大信息增益会倾向于<strong>可取值较多</strong>的特征，最大信息增益比会倾向于<strong>可取值较少的特征</strong>。</li>
</ul>
<h4 id="2、决策树和集成学习"><a href="#2、决策树和集成学习" class="headerlink" title="2、决策树和集成学习"></a>2、决策树和集成学习</h4><ul>
<li>决策树模型很简单，简单到即使你不懂机器学习，也能很快了解他，可能有人会说，这么简单的模型有什么用。哈哈，数学的伟大，在于复杂的问题简单化，深度学习的强大在于利用将简单的神经网络不断加深；决策树虽然简单，但是很多个决策树在一起，就足够让很多浅层机器学习算法忘而却步。</li>
<li><p>这个将许多决策树整合一起的方式就是集成学习，在集成学习中，决策树是个体学习器，当然个体学习器可以是别的弱学习器。</p>
</li>
<li><p>而根据个体学习器生成方式的不同，目前集成学习方法大致可分为两大类，即个体学习器间存在<strong>强依赖关系</strong>、必须串行生成的序列化方法，以及个体学习器间<strong>不存在强依赖关系</strong>、可同时生成的并行化方法；前者的代表是<strong>Boosting </strong> 和 <strong>梯度提升树</strong>(GBDT)，后者的代表是和<strong>Bagging</strong>和 <strong>随机森林</strong>（Random Forest）</p>
</li>
</ul>
<h3 id="二、决策树"><a href="#二、决策树" class="headerlink" title="二、决策树"></a>二、决策树</h3><h4 id="1、决策树中需关注问题"><a href="#1、决策树中需关注问题" class="headerlink" title="1、决策树中需关注问题"></a>1、决策树中需关注问题</h4><ul>
<li><p>一棵树是如何构建的？建树过程中，树分裂节点时，如何选出最优的属性作为分裂节点。</p>
</li>
<li><p>如何用树的减枝来避免过拟合问题。</p>
</li>
<li><p>对于含有空值的数据，如何构建树。</p>
</li>
<li><p>构建树可能存在的问题，过拟合问题，如何解决</p>
</li>
</ul>
<h4 id="2、如何构建一棵树"><a href="#2、如何构建一棵树" class="headerlink" title="2、如何构建一棵树"></a>2、如何构建一棵树</h4><p>简言之：<strong>选择最优划分属性作为分裂结点，使得分支结点中所包含的样本尽可能属于同一类</strong>。树的生成算法有三种：ID3、C4.5和CART.</p>
<h5 id="1、ID3"><a href="#1、ID3" class="headerlink" title="1、ID3"></a>1、ID3</h5><p>选择<strong>最大信息增益(Information Gain)</strong>规则去寻找最优分裂节点</p>
<h5 id="1-1、基础概念"><a href="#1-1、基础概念" class="headerlink" title="1-1、基础概念"></a>1-1、基础概念</h5><ul>
<li><p>信息熵(Information entropy)：表示随机变量不确定性的度量；<strong>熵越大，随机变量的不确定性就越大</strong>；(我们希望分类后的结果熵越小越好)。</p>
</li>
<li><p>信息增益(Information gain)：表示因特征X的信息而使得类Y信息不确定性减少的程度。(当然是越大越好）；<br>$$<br>g(D,A) = H(D) - H(D|A)<br>$$</p>
</li>
</ul>
<p>在划分过程中，找到信息增益最大的特征将样本根据此特征划分不同的结点中，新的结点中继续划分。</p>
<h5 id="1-2、不足"><a href="#1-2、不足" class="headerlink" title="1-2、不足"></a>1-2、不足</h5><ul>
<li>信息增益反应的是：给点条件后，不确定性减少的程度，<strong>特征取值越多，意味着确定性越高，也就是条件熵越小，信息增益越大。</strong>这就造成信息增益对<strong>可取值较多</strong>的属性有所偏好。</li>
<li>ID3只能处理离散型变量，只能处理分类任务</li>
<li>对样本特征缺失值比较敏感</li>
</ul>
<h5 id="2、C4-5"><a href="#2、C4-5" class="headerlink" title="2、C4.5"></a>2、C4.5</h5><p>选择<strong>最大信息增益比(Information Gain Ratio)</strong>规则去寻找最优分裂节点</p>
<h5 id="2-1、基础概念"><a href="#2-1、基础概念" class="headerlink" title="2-1、基础概念"></a>2-1、基础概念</h5><ul>
<li><strong>信息增益比(Information Gain Ratio)</strong>: 特征A对训练数据集D的信息增益比为其 信息增益与训练数据集D关于特征A的值的熵之比。<br>$$<br>g_R(D,A) =\frac{g(D,A)}{H_A(D)}<br>$$</li>
</ul>
<p>在划分过程中，找到信息增益比最大的特征将样本根据此特征划分不同的结点中，新的结点中继续划分。</p>
<h5 id="2-2、不足"><a href="#2-2、不足" class="headerlink" title="2-2、不足"></a>2-2、不足</h5><ul>
<li>C4.5 对ID3做了优化，使用信息增益比在一定程度上对取值较多的特征进行了惩罚，避免ID3出现的过拟合特性，提升了决策树的泛化能力。</li>
<li>C4.5 能处理连续型变量和离散型变量，但是只能处理分类任务。</li>
</ul>
<h5 id="3、CART"><a href="#3、CART" class="headerlink" title="3、CART"></a>3、CART</h5><p>选择<strong>最小基尼指数(Gini index)</strong>规则去寻找最优分裂节点</p>
<h5 id="3-1、基础概念"><a href="#3-1、基础概念" class="headerlink" title="3-1、基础概念"></a>3-1、基础概念</h5><ul>
<li>基尼指数：表示数据的纯度<br>$$<br>Cini(D) = 1 - \sum_{k=1}^n(\frac{|C_k|}{|D|})^2<br>$$</li>
</ul>
<p>利用基尼指数最小选择最优分裂点，采用二元切割法</p>
<h5 id="3-2、特点"><a href="#3-2、特点" class="headerlink" title="3-2、特点"></a>3-2、特点</h5><ul>
<li>不仅能处理分类任务，还能处理回归任务</li>
<li>不仅能处理离散型变量，还能处理连续型变量</li>
<li>能够处理样本特征数据缺失的情况</li>
</ul>
<h4 id="3、树的剪枝"><a href="#3、树的剪枝" class="headerlink" title="3、树的剪枝"></a>3、树的剪枝</h4><h5 id="3-1、预剪枝"><a href="#3-1、预剪枝" class="headerlink" title="3-1、预剪枝"></a>3-1、预剪枝</h5><p>阈值、</p>
<h5 id="3-2、后剪枝"><a href="#3-2、后剪枝" class="headerlink" title="3-2、后剪枝"></a>3-2、后剪枝</h5><h3 id="三、梯度提升树-和-随机森林"><a href="#三、梯度提升树-和-随机森林" class="headerlink" title="三、梯度提升树 和 随机森林"></a>三、梯度提升树 和 随机森林</h3><ul>
<li><p>梯度提升树，GBDT，特征组合的一把好手</p>
</li>
<li><p>随机森林 RF</p>
</li>
<li><p>基于决策树实现的GBDT、RF（随机森林）、Xgboost 和 lightGBM都在数据竞赛和工程中都大展身手。</p>
</li>
<li><p><a href="https://github.com/e-snail/understanding_machine_learning/tree/master/3_decision_tree" target="_blank" rel="noopener">https://github.com/e-snail/understanding_machine_learning/tree/master/3_decision_tree</a></p>
</li>
<li><p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/tree.html" target="_blank" rel="noopener">决策树API</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/11/17/ML01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/17/ML01/" itemprop="url">机器学习杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-17T22:20:28+08:00">
                2018-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,861 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>高能预警</strong>：本人非算法开发，以下是我的一些浅见。</p>
<h3 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h3><p>自有机器学习以来，算法模型中就有了区分；分为监督学习，无监督学习，半监督学习和强化学习等。</p>
<h4 id="1、监督学习"><a href="#1、监督学习" class="headerlink" title="1、监督学习"></a>1、监督学习</h4><ul>
<li><p>机器学习中<strong>大部分任务</strong>都是监督学习任务；在监督学习中，分类和回归是其两大主题。分类中名声最大的是：<strong>逻辑回归</strong>(Logistic regression)、<strong>朴素贝叶斯</strong>(Naive Bayes) 和 <strong>支持向量机</strong>(Support Vector Machine，SVM) 。</p>
</li>
<li><p>在工业界曾经有<strong>一招LR打天下</strong>的”传说”，这里的LR就是逻辑回归；早些年做CTR预估时候，<strong>人工特征海洋 + LR</strong>用得非常多，很多算法工程师大部分时间埋头搞特征工程；</p>
</li>
<li><strong>朴素贝叶斯</strong>(Naive Bayes)是个开挂的存在，它将<strong>贝叶斯原理</strong>应用到机器学习中，而后机器学习中贝叶斯学派声明鹊起，与旧贵族统计学派在机器学习中鼎足而立；它强假设输入的数据的特征都是独立的，在文本分类中表现出很好的效果，可谓是入门nlp都必须了解的算法之一了。</li>
<li><strong>支持向量机</strong>(Support Vector Machine，SVM) 当之无愧是监督学习中的无冕之王，自上世纪90年代诞生之后，在机器学习界掀起“腥风血雨”，它利用核技巧，在属于两个不同类别的两组数据之间找到良好的分类边界，将线性不可分问题转为高纬空间的线性可分问题，借此达到了分类的目的。因为SVM的存在，将<strong>多层神经网络</strong>的研究打进冷宫；多层神经网络是深度学习的前身。直到2012年，因为深度学习在ImageSet竞赛中的完胜，神经网络的研究才再次复苏，直至形成今天的野火燎原之势。</li>
<li>监督学习中另一个主题是回归，最基础的的当然是<strong>线性回归</strong>(Linear regression)，模型虽然简单，但是预测个房价，股票价格这种高大上的事情也还是有着不错的表现。</li>
<li>非监督学习比较尴尬，在工业界，更多起到打辅助的左右；有聚类，降维和关联规则三大主题，聚类中用的较多反而是简单的K-means，PCA和SVD用来做数据降维，关联规则那块好像在推荐系统用的稍微多些。</li>
</ul>
<h4 id="2、决策树和集成学习"><a href="#2、决策树和集成学习" class="headerlink" title="2、决策树和集成学习"></a>2、决策树和集成学习</h4><ul>
<li>决策树是监督学习中比较特殊的模型，说他特殊，是因为它不像LR、SVM和NB直接上手，大家喜欢使用将决策树作为集成学习的基础学习器，比较著名的是<strong>随机森林</strong>(Random Forest)、<strong>梯度提升树</strong>(GBDT)，决策树的实现经历了ID3, C4.5，CART三个阶段，在随机森林、梯度提升树里面用的是CART这个分类回归树。从CART的名字也看出来，不仅仅可以做回归，也能做分类。粗暴理解就是，分类时候好多CART投票分类结果，回归时候，取CART预测值得平均数。</li>
<li>GBDT有个超级经典的实现，XgBoost。在Kaggle比赛中，XgBoost近乎霸主级别的存在；江湖有传言，图片图像等机器学习问题用Keras（深度学习库），浅层机器学习用XgBoost。</li>
</ul>
<h4 id="3、神经网络和深度学习的渊源"><a href="#3、神经网络和深度学习的渊源" class="headerlink" title="3、神经网络和深度学习的渊源"></a>3、神经网络和深度学习的渊源</h4><ul>
<li>我认为，没有神经网络，就没有深度学习；虽然业界有说法，不用神经网络就也能实现深度学习；但是神经网络真的真的很厉害，虽然很长一段时间不被看好，因为两层的神经网络连个异或都处理不了，的确有理由被看不上；但是随着反向传播算法发现，神经网络层数不断加深，在工业界发挥牛逼闪闪的光芒。</li>
<li>你可能想不到，权重，阈值，激活函数这些简简单单的东西，怎么能解决计算机视觉、语音识别这种非常难的问题，这些问题连当年风光无限的SVM都败下阵来。</li>
</ul>
<h4 id="4、特征工程"><a href="#4、特征工程" class="headerlink" title="4、特征工程"></a>4、特征工程</h4><ul>
<li><p>有句老话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。在传统机器学习领域，做好特征工程很重要；工业界有句老话，70%多的时间在做特征工程；</p>
</li>
<li><p>比较尴尬的是，市面上多是讲解机器学习算法模型的书，讲解算法和模型的奥妙是他们的主题，提供的试验数据也都是已经处理好的，并不需要特征工程处理，但是实际工程中不是这样。特征工程的处理依赖领域知识和经验依旧是主流，但是业界很多项目处于安全、隐私等考虑，不会透露底层的特征工程的处理。</p>
</li>
</ul>
<h4 id="5、特征工程-amp-深度学习"><a href="#5、特征工程-amp-深度学习" class="headerlink" title="5、特征工程 &amp; 深度学习"></a>5、特征工程 &amp; 深度学习</h4><ul>
<li>深度学习有自动获取特征的能力，可以对输入的低阶特征进行组合、变换，得到高阶特征，但是这个能力只是对于某些领域(如图像、语音)有比较好的效果。</li>
<li>在其他领域，如自然语言处理中，输入的字或词都是离散、稀疏的值，不像图片一样是连续、稠密的。输入原始数据进行组合、变换得到的高阶特征并不是那么有效。而且有的语义并不来自数据，而来自人们的先验知识，所以利用先验知识构造的特征是很有帮助的。</li>
<li>总的来说，在深度学习中，特征工程仍然适用；神经网络能对特征自动进行排列组合，所以只要输入一阶特征就行，省去了手动构造高阶特征的工作量。</li>
</ul>
<h4 id="6、模型评估"><a href="#6、模型评估" class="headerlink" title="6、模型评估"></a>6、模型评估</h4><ul>
<li>模型评估很重要，是向别人证明你的模型怎么好的依据，我也就知道过拟合、欠拟合、交差验证、ROC、分类中查全率，查准率这些概念，没有个比较整体的认识，后面抽时间了解后再来补充。</li>
</ul>
<h3 id="二、常见的监督学习算法模型"><a href="#二、常见的监督学习算法模型" class="headerlink" title="二、常见的监督学习算法模型"></a>二、常见的监督学习算法模型</h3><p>哈哈，先留坑，后面慢慢填</p>
<h4 id="1、LR（逻辑回归）"><a href="#1、LR（逻辑回归）" class="headerlink" title="1、LR（逻辑回归）"></a>1、LR（逻辑回归）</h4><ul>
<li>线性模型的基础上增加了sigmoid函数，处理二分类问题，广义的线性模型，在CTR预估中有大作用</li>
</ul>
<h4 id="2、SVM-支持向量机"><a href="#2、SVM-支持向量机" class="headerlink" title="2、SVM(支持向量机)"></a>2、SVM(支持向量机)</h4><ul>
<li><p>可以处理非线性问题，深度学习未火之前，是学术界和工业界的热点，</p>
<p>数据规模较小时，能够构建出数据间的非线性关系，</p>
<p>1、SVM的原始公式是如何由实际问题产生，算法的灵魂</p>
<p>2、SVM原始问题到对偶问题的数学推导公式</p>
</li>
</ul>
<h4 id="3、NB-朴素贝叶斯"><a href="#3、NB-朴素贝叶斯" class="headerlink" title="3、NB(朴素贝叶斯)"></a>3、NB(朴素贝叶斯)</h4><ul>
<li>基于贝叶斯定理的一组有监督学习算法，<strong>朴素</strong>：“简单”地假设每对特征之间相互独立；</li>
<li>在很多实际情况下，朴素贝叶斯工作得很好，特别是<strong>文档分类</strong>和<strong>垃圾邮件过滤</strong>。这些工作都要求 一个小的训练集来估计必需参数。</li>
</ul>
<p><a href="http://sklearn.apachecn.org/cn/0.19.0/modules/naive_bayes.html" target="_blank" rel="noopener">http://sklearn.apachecn.org/cn/0.19.0/modules/naive_bayes.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/04/15/iOS-NSURLProtocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS-NSURLProtocol/" itemprop="url">NSURLProtocol基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T15:40:11+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,688 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、URL-Loading-System"><a href="#1、URL-Loading-System" class="headerlink" title="1、URL Loading System"></a>1、URL Loading System</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-7317567c713d851f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="URL-loading-system.png"></p>
<ul>
<li><strong>URL Loading System</strong> 是一系列用来访问通过 <strong>URL 来定位的资源的类和协议</strong>。这项技术的核心在于基于 <code>NSURL</code> 这个类来访问资源，除了加载 URL 的类 <code>NSURLSession</code> 之外，我们把其他相关辅助类分为 5 类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">协议支持（protocol support）</span><br><span class="line">认证和证书（authentication and credentials）</span><br><span class="line">Cookie 存储（Cookie storage）</span><br><span class="line">请求配置（configuration management）</span><br><span class="line">缓存管理（cache management）</span><br></pre></td></tr></table></figure>
<ul>
<li>更多可以参考：<a href="https://juejin.im/post/5a69f8366fb9a01cb42c90bc" target="_blank" rel="noopener">URL Loading System 概览</a></li>
</ul>
<h5 id="2、NSURLProtocol"><a href="#2、NSURLProtocol" class="headerlink" title="2、NSURLProtocol"></a>2、NSURLProtocol</h5><ul>
<li><p>NSURLProtocol是<strong>URL Loading System</strong>的重要组成部分；NSURLProtocol能拦截所有基于URL Loading System的网络请求；NSURLProtocol是一个抽象类。使用NSURLProtocol时候，需要创建它的子类。</p>
</li>
<li><p>NSURLProtocol可以拦截的网络请求包括NSURLSession，NSURLConnection以及UIWebVIew。</p>
</li>
<li><p>基于CFNetwork的网络请求，以及WKWebView的请求是无法拦截的。</p>
</li>
<li><p>现在主流的iOS网络库，例如AFNetworking，Alamofire等网络库都是基于NSURLSession的，所以这些网络库的网络请求都可以被NSURLProtocol所拦截。</p>
</li>
<li><p>至于还有一些年代比较久远的网络库，例如ASIHTTPRequest，MKNetwokit等网路库都是基于CFNetwork的，所以这些网络库的网络请求无法被NSURLProtocol拦截。</p>
</li>
</ul>
<h4 id="二、使用-NSURLProtocol"><a href="#二、使用-NSURLProtocol" class="headerlink" title="二、使用 NSURLProtocol"></a>二、使用 NSURLProtocol</h4><p>定义NSURLProtocol的子类，然后在子类（MYURLProtocol）中处理好<code>注册—&gt;拦截—&gt;转发—&gt;回调—&gt;结束</code></p>
<h5 id="1、注册"><a href="#1、注册" class="headerlink" title="1、注册"></a>1、注册</h5><p>对于基于NSURLConnection或者使用[NSURLSession sharedSession]创建的网络请求，调用registerClass方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSURLProtocol registerClass:[NSClassFromString(@&quot;MYURLProtocol&quot;) class]];</span><br></pre></td></tr></table></figure>
<p>对于基于NSURLSession的网络请求，需要通过配置NSURLSessionConfiguration对象的protocolClasses属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">sessionConfiguration.protocolClasses = @[[NSClassFromString(@&quot;MYURLProtocol&quot;) class]];</span><br></pre></td></tr></table></figure>
<h5 id="2、拦截"><a href="#2、拦截" class="headerlink" title="2、拦截"></a>2、拦截</h5><ul>
<li>NSURLProtocol可以在这个方法中拦截到网络请求，比如过滤掉（不处理）白名单的URL请求，比如只允许<code>http/https</code>请求。</li>
<li>请求拦截<code>Code Demo</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//利用MYHTTPIdentifier避免 canInitWithRequest 和 canonicalRequestForRequest 出现死循环</span><br><span class="line">static NSString * const MYHTTPIdentifier = @&quot;MYHTTPIdentifier&quot;;</span><br><span class="line"></span><br><span class="line">//每一个请求的时候都会调用这个方法，在这个方法里面判断这个请求是否需要被处理拦截，</span><br><span class="line">//如果返回YES就代表这个request需要被处理，反之就是不需要被处理。</span><br><span class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</span><br><span class="line">	if ([NSURLProtocol propertyForKey:MYHTTPIdentifier inRequest:request] ) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *scheme = [[request.URL scheme] lowercaseString];</span><br><span class="line">    if ([whiteUrlList contains:request.URL.absoluteString];)&#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([scheme isEqual:@&quot;http&quot;] || [scheme isEqual:@&quot;https&quot;]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回规范的request的对象，我们可以对request进行处理。例如修改头部信息等。</span><br><span class="line">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableURLRequest *mutableReqeust = [request mutableCopy];</span><br><span class="line">    //修改头部信息</span><br><span class="line">    NSMutableDictionary *headers = [request.allHTTPHeaderFields mutableCopy];</span><br><span class="line">    [headers setObject:@&quot;ttf&quot; forKey:@&quot;i am ttf&quot;];</span><br><span class="line">    request.allHTTPHeaderFields = headers;</span><br><span class="line">    //</span><br><span class="line">    [NSURLProtocol setProperty:@YES</span><br><span class="line">                        forKey:MYHTTPIdentifier</span><br><span class="line">                     inRequest:mutableReqeust];</span><br><span class="line">    return [mutableReqeust copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、转发"><a href="#3、转发" class="headerlink" title="3、转发"></a>3、转发</h5><ul>
<li>在拦截到网络请求，并且对网络请求进行定制处理以后。我们需要将网络请求重新发送出去，核心方法startLoading。</li>
<li>在该方法中，我们把处理过的request重新发送出去。至于发送的形式，可以是基于NSURLSession。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)startLoading &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、回调"><a href="#4、回调" class="headerlink" title="4、回调"></a>4、回调</h5><ul>
<li>在拦截了请求后，不能影响到原来网络请求的逻辑。所以将网络请求转发出去以后，当收到网络请求的返回后，要再将返回值返回给原来发送网络请求的地方。需要用到以下五个方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self.client URLProtocol:self didFailWithError:error];</span><br><span class="line"></span><br><span class="line">[self.client URLProtocolDidFinishLoading:self];</span><br><span class="line"></span><br><span class="line">[self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];</span><br><span class="line"></span><br><span class="line">[self.client URLProtocol:self didLoadData:data];</span><br><span class="line"></span><br><span class="line">[[self client] URLProtocol:self wasRedirectedToRequest:request redirectResponse:response];</span><br></pre></td></tr></table></figure>
<ul>
<li>假设我们在转发过程中是使用NSURLSession发送的网络请求，那么在NSURLSession的回调方法中，我们做相应的处理即可。并且我们也可以对这些返回，进行定制化处理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        [self.client URLProtocol:self didFailWithError:error];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.client URLProtocolDidFinishLoading:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];</span><br><span class="line"></span><br><span class="line">    completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    [self.client URLProtocol:self didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler &#123;</span><br><span class="line">    if (response != nil)&#123;</span><br><span class="line">        [[self client] URLProtocol:self wasRedirectedToRequest:request redirectResponse:response];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5、结束"><a href="#5、结束" class="headerlink" title="5、结束"></a>5、结束</h5><ul>
<li>在一个网络请求完全结束以后，NSURLProtocol回调用到stopLoading方法，在此方法中，完成在结束网络请求的操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)stopLoading &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、NSURLProtocol的应用"><a href="#三、NSURLProtocol的应用" class="headerlink" title="三、NSURLProtocol的应用"></a>三、NSURLProtocol的应用</h4><h5 id="1、Mock网络请求"><a href="#1、Mock网络请求" class="headerlink" title="1、Mock网络请求"></a>1、Mock网络请求</h5><ul>
<li>可以参考<a href="https://link.jianshu.com/?t=https://github.com/AliSoftware/OHHTTPStubs" target="_blank" rel="noopener">OHHTTPStubs</a></li>
</ul>
<h5 id="2、网络监控和相关数据统计"><a href="#2、网络监控和相关数据统计" class="headerlink" title="2、网络监控和相关数据统计"></a>2、网络监控和相关数据统计</h5><ul>
<li>APM工具，如Bugly</li>
</ul>
<h5 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h5><ul>
<li>URL重定向</li>
<li>实现HTTPDNS</li>
</ul>
<h4 id="四、NSURLProtocol的坑"><a href="#四、NSURLProtocol的坑" class="headerlink" title="四、NSURLProtocol的坑"></a>四、NSURLProtocol的坑</h4><h5 id="1、死循环"><a href="#1、死循环" class="headerlink" title="1、死循环"></a>1、死循环</h5><p><strong>原因</strong>：偶尔会出现<strong>canInitWithRequest方法多次调用的</strong>情况，不注意处理会发生死循环的问题，需要在canInitWithRequest方法中会判断是否拦截过请求。</p>
<p><strong>解决办法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    if ([NSURLProtocol propertyForKey:protocolKey inRequest:request]) &#123;  //句1</span><br><span class="line">    	return NO;</span><br><span class="line">	&#125;</span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">    [NSURLProtocol setProperty:@(YES) forKey:protocolKey inRequest:request]; //句2</span><br><span class="line">    //...</span><br><span class="line">    return [request copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//句1和句2是为了防止死循环的，主要用于对request进行标记，如果被标记了，就不再次进行处理了，如果没有标记过就要进行处理。</span><br></pre></td></tr></table></figure>
<h5 id="2、多NSURLProtocol嵌套使用"><a href="#2、多NSURLProtocol嵌套使用" class="headerlink" title="2、多NSURLProtocol嵌套使用"></a>2、多NSURLProtocol嵌套使用</h5><ul>
<li><p>若一个项目中存在多个NSURLProtocol，那么NSURLProtocol的拦截顺序跟注册的方式和顺序有关，对于使用registerClass方法注册的情况：<strong>多个NSURLProtocol拦截顺序为注册顺序的反序，即后注册的的NSURLProtocol先拦截。</strong></p>
</li>
<li><p>对于通过配置<strong>NSURLSessionConfiguration</strong>对象的protocolClasses属性来注册的情况：<strong>protocolClasses这个数组里只有第一个NSURLProtocol会起作用</strong>，所以为了保证自定义的protocolClass有效，采用的办法是：<strong>把自己的NSURLProtocol插入到protocolClasses的第一个，进行拦截。拦截完成之后，又进行移除</strong>。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)setEnabled:(BOOL)enable forSessionConfiguration:(NSURLSessionConfiguration*)sessionConfig &#123;</span><br><span class="line">    // Runtime check to make sure the API is available on this version</span><br><span class="line">    if ([sessionConfig respondsToSelector:@selector(protocolClasses)]</span><br><span class="line">        &amp;&amp; [sessionConfig respondsToSelector:@selector(setProtocolClasses:)])&#123;</span><br><span class="line">        //</span><br><span class="line">        NSMutableArray *urlProtocolClasses = [NSMutableArray arrayWithArray:sessionConfig.protocolClasses];</span><br><span class="line">        </span><br><span class="line">        Class protoCls = OHHTTPStubsProtocol.class;</span><br><span class="line">        if (enable &amp;&amp; ![urlProtocolClasses containsObject:protoCls])&#123;</span><br><span class="line">            [urlProtocolClasses insertObject:protoCls atIndex:0];</span><br><span class="line">        &#125;else if (!enable &amp;&amp; [urlProtocolClasses containsObject:protoCls])&#123;</span><br><span class="line">            [urlProtocolClasses removeObject:protoCls];</span><br><span class="line">        &#125;</span><br><span class="line">        sessionConfig.protocolClasses = urlProtocolClasses;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">		NSLog(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、NSURLProtocol不能拦截WKWebView中请求"><a href="#3、NSURLProtocol不能拦截WKWebView中请求" class="headerlink" title="3、NSURLProtocol不能拦截WKWebView中请求"></a>3、NSURLProtocol不能拦截WKWebView中请求</h5><ul>
<li>WKWebView中的请求走得是WebKit内核，不走在App进程中，一般情况下，在App中不能通过NSURLProtocol拦截请求；</li>
<li>实践中，通过WebKit2的私有方法，让WKWebView的请求被NSURLProtocol拦截，但是有post请求body数据被清空的坑。</li>
</ul>
<h5 id="4、NSURLSession的坑"><a href="#4、NSURLSession的坑" class="headerlink" title="4、NSURLSession的坑"></a>4、NSURLSession的坑</h5><p>在NSURLProtocol中使用NSURLSession有很多莫名其妙的问题，基本上都是系统的bug，比较明显的就是：</p>
<ul>
<li>拦截到的Request中的HTTPBody为nil；</li>
<li>startLoading在某些特殊情况会出现死锁；</li>
<li>关于注册registerClass方法只适用于sharedSession创建的网络请求；</li>
</ul>
<h4 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h4><p><a href="https://www.jianshu.com/p/02781c0bbca9" target="_blank" rel="noopener">NSURLProtocol全攻略</a></p>
<p><a href="https://www.jianshu.com/p/af94f2e8d4b0" target="_blank" rel="noopener">黑魔法NSURLProtocol</a></p>
<p><a href="https://github.com/draveness/analyze/blob/master/contents/OHHTTPStubs/iOS%20%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8%20NSURLProtocol%20%E6%8B%A6%E6%88%AA%20HTTP%20%E8%AF%B7%E6%B1%82.md" target="_blank" rel="noopener">iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求</a></p>
<p>#### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/03/24/iOS-iOSLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/24/iOS-iOSLock/" itemprop="url">多线程中的锁小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T18:21:40+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,193 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  12 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、多线程中的锁"><a href="#一、多线程中的锁" class="headerlink" title="一、多线程中的锁"></a>一、多线程中的锁</h4><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><ul>
<li>在并发编程中，<strong>锁是一种同步机制</strong>，是用来限制多线程环境中对资源的访问，保障线程安全。</li>
<li>线程安全中，为了实现<strong>线程阻塞</strong>，一般有两种方案：一种是<strong>让线程处于休眠状态</strong>，此时不会消耗 CPU 资源；另一种方案是<strong>让线程忙等或空转</strong>，这样会消耗一定的 CPU 资源。前者属于互斥，后者属于自旋。</li>
<li>自旋在线程加锁的情况下，会一直尝试是否解锁，如果没有解锁，会一直循环判断，如果锁已经放开，则继续执行，不再是空转状态。OSSpinLock 属于自旋锁，pthread 库中相关的锁，以及 NSLock、@synchronized 等都属于互斥锁。</li>
<li>ibireme 在《<a href="https://link.jianshu.com/?t=https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a>》中的一张图片说明加解锁的效率（锁的效率并不值的是加解锁的速度，而是加解锁操作在执行时的复杂程度）：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-514c86e036c415bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="lock"></p>
<h5 id="2、为什么自旋锁的性能最好"><a href="#2、为什么自旋锁的性能最好" class="headerlink" title="2、为什么自旋锁的性能最好"></a>2、为什么自旋锁的性能最好</h5><ul>
<li>自旋锁是一种<strong>非阻塞锁</strong>，换句话说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该<strong>线程不会被挂起，而是在不断的消耗<code>CPU</code>的时间</strong>，不停的试图获取自旋锁</li>
<li>而互斥锁是<strong>阻塞锁</strong>，当某线程无法获取互斥量时，<strong>该线程会被直接挂起，该线程不再消耗<code>CPU</code>时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程</strong>，让其投入运行。</li>
<li>自旋锁比互斥锁的获取<strong>少了两个线程的上下文切换时间</strong>，虽然自旋锁因为空转等待浪费了CPU的时间，但是在多核环境下，对于很多轻量级的操作，等待锁的时间 小于 两次线程上下文切换的时间，自然就体现出了自旋锁的性能。</li>
</ul>
<h4 id="二、几种常见的锁"><a href="#二、几种常见的锁" class="headerlink" title="二、几种常见的锁"></a>二、几种常见的锁</h4><p><em>有了dispatch_semaphore，pthread_mutex和pthread_mutex(recursive)，synchronized感觉有够用了</em></p>
<p><strong>1、OSSpinLock(自旋锁)</strong></p>
<ul>
<li><p>OSSpinLock存在优先级反转的问题，在iOS10之后已经废弃，使用os_unfair_lock替代(中间有段时间用了pthread_mutex ), os_unfair_lock 是iOS 10.0新推出的锁，用于解决OSSpinLock优先级反转问题。</p>
</li>
<li><p>后面会介绍下OSSpinLock的往事</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//code</span><br><span class="line">OSSpinLock oslock = OS_SPINLOCK_INIT;</span><br><span class="line">OSSpinLockLock(&amp;oslock);</span><br><span class="line">OSSpinLockUnlock(&amp;oslock);</span><br></pre></td></tr></table></figure>
<h5 id="2、-dispatch-semaphore-信号量"><a href="#2、-dispatch-semaphore-信号量" class="headerlink" title="2、 dispatch_semaphore(信号量)"></a>2、 dispatch_semaphore(信号量)</h5><ul>
<li>信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。<strong>在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量</strong></li>
<li>GCD用于控制多线程并发的信号量，允许通过wait/signal的信号事件控制并发执行的最大线程数，当最大线程数降级为1的时候则可当作同步锁使用，注意该信号量并不支持递归；</li>
</ul>
<h5 id="3、pthread-mutex-互斥锁"><a href="#3、pthread-mutex-互斥锁" class="headerlink" title="3、pthread_mutex (互斥锁)"></a>3、pthread_mutex (互斥锁)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_t _lock;</span><br><span class="line">//初始化</span><br><span class="line">pthread_mutex_init(&amp;pLock, NULL);</span><br><span class="line">//加锁和释放锁</span><br><span class="line">pthread_mutex_lock(&amp;pLock);</span><br><span class="line">pthread_mutex_unlock(&amp;pLock);</span><br><span class="line">//销毁</span><br><span class="line">pthread_mutex_destroy(&amp;_lock);</span><br></pre></td></tr></table></figure>
<p><strong>说明1</strong>：加锁后，加锁后同一个时间点只能有一个线程能访问，后面的线程需要排队，并且 lock 和 unlock 是对应出现的，同一线程多次 lock 是不允许的。</p>
<p><strong>说明2</strong>：一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃(死锁)。如果需要在同一线程多次获取一个锁，就需要递归锁。</p>
<p><strong>说明3</strong>：对于互斥锁，假设在已经获得锁的情况下再次申请锁，线程会<strong>因为等待锁的释放而进入睡眠状态</strong>，因此就不可能再释放锁，从而导致死锁。</p>
<h5 id="4、NSLock"><a href="#4、NSLock" class="headerlink" title="4、NSLock"></a>4、NSLock</h5><ul>
<li>NSLock 只是在内部封装了一个 <strong>pthread_mutex</strong>，属性为 <strong>PTHREAD_MUTEX_ERRORCHECK</strong>，它会损失一定性能换来错误提示。</li>
<li>NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</li>
</ul>
<h5 id="5、NSCondition"><a href="#5、NSCondition" class="headerlink" title="5、NSCondition"></a>5、NSCondition</h5><ul>
<li>NSCondition的底层是通过条件变量(condition variable) <strong>pthread_cond_t</strong> 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。</li>
</ul>
<h5 id="6、-pthread-mutex-recursive"><a href="#6、-pthread-mutex-recursive" class="headerlink" title="6、 pthread_mutex(recursive)"></a>6、 pthread_mutex(recursive)</h5><ul>
<li>同一个线程可以多次获取同一个递归锁，不会产生死锁。</li>
<li>如果一个线程多次获取同一个非递归锁，则会产生死锁。</li>
<li>递归锁允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_sync_enter/objc_sync_exit</span><br></pre></td></tr></table></figure>
<h5 id="7、NSRecursiveLock"><a href="#7、NSRecursiveLock" class="headerlink" title="7、NSRecursiveLock"></a>7、NSRecursiveLock</h5><ul>
<li><p>递归锁也是通过 <strong>pthread_mutex_lock</strong> 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。</p>
</li>
<li><p>NSRecursiveLock 与 NSLock 的区别在于内部封装的 <strong>pthread_mutex_t</strong> <strong>对象的类型不同</strong>，前者的类型为 PTHREAD_MUTEX_RECURSIVE。</p>
</li>
</ul>
<h5 id="8、NSConditionLock-条件锁"><a href="#8、NSConditionLock-条件锁" class="headerlink" title="8、NSConditionLock(条件锁)"></a>8、NSConditionLock(条件锁)</h5><ul>
<li>NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值:</li>
</ul>
<h5 id="9、synchronized-同步锁"><a href="#9、synchronized-同步锁" class="headerlink" title="9、synchronized(同步锁)"></a>9、synchronized(同步锁)</h5><ul>
<li>OC 层面的锁，实现对block内的代码片段加锁， 可以指定任意一个Objective-C对象(id指针)作为锁“标记”，该语法将“标记”理解为token，通过牺牲性能换来语法上的简洁与可读</li>
<li>@synchronized 后面紧跟的 OC 对象，根据对象的哈希值来获取对应的互斥锁，这些互斥锁在OC的底层的互斥锁池中</li>
</ul>
<p><strong>说明</strong>：目前，像OSSpinLock、dispatch_semaphore、synchronized等都不支持可重入（可重入: 允许同一线程多次加锁），只有pthread_mutex(recursive)和NSRecursiveLock支持，其中pthread_mutex(recursive)效率最高。</p>
<h4 id="二、OSSpinLock的优先级反转问题"><a href="#二、OSSpinLock的优先级反转问题" class="headerlink" title="二、OSSpinLock的优先级反转问题"></a>二、OSSpinLock的优先级反转问题</h4><h5 id="1、什么是优先级反转"><a href="#1、什么是优先级反转" class="headerlink" title="1、什么是优先级反转"></a>1、什么是优先级反转</h5><ul>
<li><strong>优先级反转</strong>(Priority Inversion)是 由于<strong>多线程共享资源，具有最高优先权的线程被低优先级线程阻塞，反而使具有中优先级的线程先于高优先级的线程执行</strong>。（可类推到多进程的优先级反转）</li>
<li>产生优先级反转的条件：假设有高优先级的任务线程为<strong>High</strong>、中优先级的任务为<strong>Mid</strong>、低优先级的任务线程为<strong>Low</strong>；优先级是High &gt; Mid &gt; Low; 触发需要满足3个条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- High线程要访问一个被Low线程占有的资源，因为得不到，High线程被阻塞；</span><br><span class="line">- Middle线程启动执行，因为Middle优先级比Low高，导致占有资源的Low线程被挂起，但是Low占用的资源并没有释放；甚至于因为Low的优先级足够低，一直被其他的任务挂起，导致占有的资源一直不能释放，High线程一直无法得到机会执行。</span><br><span class="line">- High任务因为一直不能获取被Low任务占用的资源，导致比它优先低的任务却可以执行。</span><br></pre></td></tr></table></figure>
<h5 id="2、优先级反转的解决办法"><a href="#2、优先级反转的解决办法" class="headerlink" title="2、优先级反转的解决办法"></a>2、优先级反转的解决办法</h5><p><strong>解决的思路</strong>是：<strong>提高占有资源线程的优先级</strong>，使其可以执行，并在执行完后释放资源；以让其他线程可以获取资源；<strong>常见的解决方法</strong>有2种，<strong>优先级继承</strong>(priority inheritance) 或 <strong>优先级极限</strong>(priority ceilings)。</p>
<h6 id="1）优先级继承-priority-inheritance"><a href="#1）优先级继承-priority-inheritance" class="headerlink" title="1）优先级继承(priority inheritance)"></a>1）优先级继承(priority inheritance)</h6><ul>
<li>提升<strong>低优先级线程</strong> 的优先级，优先级等于  等待其占有的资源的，最高优先级任务的优先级；</li>
<li>换言之，当高优先级任务由于等待资源而被阻塞时，此时资源的拥有者的优先级将会自动被提升。</li>
</ul>
<h6 id="2）优先级天花板-priority-ceilings"><a href="#2）优先级天花板-priority-ceilings" class="headerlink" title="2）优先级天花板(priority ceilings)"></a>2）优先级天花板(priority ceilings)</h6><ul>
<li>将申请某资源的线程优先级，提升到可能访问该资源的所有任务中最高优先级任务的优先级。</li>
</ul>
<p><strong>说明</strong>： 优先级继承，只有当占有资源的低优先级的任务被阻塞时,才会提高占有资源任务的优先级；而优先级天花板，不论是否发生阻塞, 都提升。</p>
<h5 id="3、被命放弃的OSSpinLock"><a href="#3、被命放弃的OSSpinLock" class="headerlink" title="3、被命放弃的OSSpinLock"></a>3、被命放弃的OSSpinLock</h5><ul>
<li>由于OSSpinLock加解锁的效率高，早期被大量使用，比如Apple就使用OSSpinLock来实现属性的setter/getter的原子性，著名的YYKit中使用的也是OSSpinLock，</li>
<li>但是自从发现优先级反转问题后，OSSpinLock被放弃。YYKit中采用了dispatch_semaphore_t；Apple也在iOS 10.0新推出os_unfair_lock，用来解决OSSpinLock优先级反转问题。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">// 加锁</span><br><span class="line">os_unfair_lock_lock(unfairLock);</span><br><span class="line">// 解锁</span><br><span class="line">os_unfair_lock_unlock(unfairLock);</span><br><span class="line">// 尝试加锁</span><br><span class="line">BOOL b = os_unfair_lock_trylock(unfairLock);</span><br></pre></td></tr></table></figure>
<h4 id="三、atomic能保证修饰的属性是线程安全吗？"><a href="#三、atomic能保证修饰的属性是线程安全吗？" class="headerlink" title="三、atomic能保证修饰的属性是线程安全吗？"></a>三、atomic能保证修饰的属性是线程安全吗？</h4><h5 id="1、atomic不能保证修饰的属性是线程安全的"><a href="#1、atomic不能保证修饰的属性是线程安全的" class="headerlink" title="1、atomic不能保证修饰的属性是线程安全的"></a>1、atomic不能保证修饰的属性是线程安全的</h5><ul>
<li><p>属性被atomic修饰之后，默认生成的getter和setter方法，是原子操作的；这就意味着，在多线程环境下，<code>简单的set/get</code>的访问操作的线程安全的。</p>
</li>
<li><p>但是在真实场景下，不是简单的getter和setter操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic, assign)  int  intA;  //intA被atomic修饰</span><br><span class="line"></span><br><span class="line">//thread A</span><br><span class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">    self.intA = self.intA + 1;</span><br><span class="line">    NSLog(@&quot;Thread A: %d\n&quot;, self.intA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//thread B</span><br><span class="line">for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">    self.intA = self.intA + 1;</span><br><span class="line">    NSLog(@&quot;Thread B: %d\n&quot;, self.intA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然<strong>intA</strong>声明为atomic，但是结果也不一定会是20000。原因就是因为<code>self.intA = self.intA + 1;</code>不是原子操作，虽然intA的getter和setter是原子操作，但当我们使用intA的时候，整个语句并不是原子的，这行赋值的代码至少包含读取(load)，+1(add)，赋值(store)三步操作，当前线程store的时候可能其他线程已经执行了若干次store了，导致最后的值小于预期值。这种场景我们也可以称之为<strong>多线程不安全</strong>。</p>
</li>
<li><p>再加上，属性多了atomic修饰，相当于对属性的setter和getter操作加锁，导致属性的操作性能比nonatomic修饰差，举个简单例子，在单线程环境，<code>UIKit</code>中所有类的属性，因为不存在多线程竞争的问题，属性使用atomic锁会影响效率。</p>
</li>
<li><p>此外，即使可变数组对象被修饰成aomic，无法保证数组对象的插入、删除操作是线程安全的。</p>
</li>
</ul>
<h5 id="2、atomic的性能很差吗"><a href="#2、atomic的性能很差吗" class="headerlink" title="2、atomic的性能很差吗"></a>2、atomic的性能很差吗</h5><ul>
<li><p>atomic的实质是给属性setter/getter方法加锁，之前是自旋锁OSSpinLock,后来因为OSSpinLock优先级反转的问题，iOS 10使用新的自旋锁unfairLock，自旋锁的性能还是相当不错的。</p>
</li>
<li><p>被atomic修饰的属性，setter和getter方法中任意一个被重写，atomic关键字特性就会失效。</p>
</li>
<li><p>atomic的性能不错，也线程安全，但仅限于setter/getter。</p>
</li>
</ul>
<h4 id="四、锁的一些其他问题讨论"><a href="#四、锁的一些其他问题讨论" class="headerlink" title="四、锁的一些其他问题讨论"></a>四、锁的一些其他问题讨论</h4><h5 id="1、dispatch-barrier-async-并发队列性能为什么项目中不使用"><a href="#1、dispatch-barrier-async-并发队列性能为什么项目中不使用" class="headerlink" title="1、dispatch_barrier_async + 并发队列性能为什么项目中不使用"></a>1、dispatch_barrier_async + 并发队列性能为什么项目中不使用</h5><ul>
<li>《Effective Objective-C 2.0》一书中，推荐了<strong>dispatch_barrier_async + 并发队列</strong>来解决线程安全的问题；书中强调，性能比GCD串行队列好，但是实际项目中没咋遇到dispatch_barrier_async + 并发队列，多使用互斥锁。</li>
<li><p>读操作和写操作都需要配发到一个并发队列中，那么<strong>最终执行代码的线程 和 最初调用代码的线程很可能不是同一个</strong>，这里有一次<strong>线程切换</strong>的开销，如果这时候遇到互斥锁需要等待的话，当前线程被挂起，再等到CPU唤醒代码最终被执行的时候一来一回又是两次线程的切换，而<strong>对于很多轻量级的操作，这种线程之间切换的开销要比自旋锁的那种一直忙等待的方式慢很多。</strong></p>
</li>
<li><p>在测评中发现，dispatch_barrier_async + 并发队列性性能不好，具体可参考 <a href="https://www.jianshu.com/p/15df680d510e" target="_blank" rel="noopener">atomic性能真的很差，并发queue+barrier性能真的很好吗？</a></p>
</li>
</ul>
<h5 id="2、死锁问题"><a href="#2、死锁问题" class="headerlink" title="2、死锁问题"></a>2、死锁问题</h5><ul>
<li>主线程使用dispatch_sync</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用OSSpinLock、dispatch_semaphore、synchronized等都不支持可重入等锁，遇到重入的场景</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//死锁，YYThreadSafeArrays使用的是dispatch_semaphore做线程同步</span><br><span class="line">YYThreadSafeArray *array = [[YYThreadSafeArray alloc] initWithObjects:@&quot;678&quot;,@&quot;910&quot;, nil];</span><br><span class="line">    [array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        NSLog(@&quot;count = %@&quot;,@([array count]));</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/03/21/iOS-iOSCoreAniamtion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/iOS-iOSCoreAniamtion/" itemprop="url">Core Animation小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-21T15:36:48+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,430 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h5><ul>
<li><p>iOS主要的<strong>绘图系统</strong>有UIKit、<strong>Core Animation</strong>、Core Graphics、OpenGL ES和Core Image等。</p>
</li>
<li><p>Core Animation并非是做高端动画的库。它是一个用于管理视图排版、合成、渲染以及动画的基础 库，最终的渲染工作是交给Graphics Hardware(GPU)处理。</p>
</li>
<li><p><strong>UIKit 建立在 Core Animation 基础之上，在 Core Animation 之下是 OpenGL ES 和 Core Graphics，分别对应 GPU 和 CPU。</strong></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-e511da597e5f480b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<h5 id="2、图层概念"><a href="#2、图层概念" class="headerlink" title="2、图层概念"></a>2、图层概念</h5><ul>
<li><p>在Core Animaiton中有个重要的概念，就是<strong>图层</strong>（CALayer)，它不仅可以显示一些内容（如图片，文本或者背景色）、还可以管理子图层，甚至还可以做动画和变换；</p>
</li>
<li><p>不同于在UIKit中的视图基类UIView，CALayer并不清楚具体的<em>响应链</em>（<strong>iOS通过视图层级关系用来传送触摸事件的机制），</strong>不能够响应事件，不能处理和用户的交互，但是它依然可以使用<strong>hitTest</strong>来判断是否一个触点在图层的范围之内。</p>
</li>
<li><p>每一个UIView都有一个<strong>CALayer实例</strong>，UIView的职责是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。</p>
</li>
</ul>
<h5 id="3、图层的意义"><a href="#3、图层的意义" class="headerlink" title="3、图层的意义"></a>3、图层的意义</h5><p>UIView对 CALayer大部分属性做了高级封装，大部分场景下，使用UIView的高级API（比如自动排版，布局和事件处理）就足够了，但是在某些情况下，需要使用到CALayer</p>
<ul>
<li><p>开发同时可以在Mac OS上运行的跨平台应用</p>
</li>
<li><p>追求更好的性能，使用多种CALayer的子类，如CAShapeLayer、CAGradientLayer和CATextLayer</p>
</li>
<li><p>完成一些视觉效果，如<strong>阴影</strong>，<strong>圆角</strong>，<strong>边框</strong>、<strong>3D变换</strong>、<strong>非矩形范围</strong>、<strong>透明遮罩</strong>、<strong>多级非线性动画</strong>等。​             </p>
</li>
</ul>
<h4 id="二、Core-Animation-Pipeline"><a href="#二、Core-Animation-Pipeline" class="headerlink" title="二、Core Animation Pipeline"></a>二、Core Animation Pipeline</h4><p><img src="https://upload-images.jianshu.io/upload_images/201701-b91953f039c0ddf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<p>Core Animation的<strong>绘制和渲染</strong>是通过<strong>Core Animation Pipeline</strong>实现，它以流水线的形式进行渲染，具体分为四个步骤：</p>
<h5 id="1、Commit-Transaction"><a href="#1、Commit-Transaction" class="headerlink" title="1、Commit Transaction"></a>1、Commit Transaction</h5><p>​      具体可以细分为四个阶段</p>
<ul>
<li><p><strong>Layout</strong>: 构建视图层级，设置图层属性（如位置，背景色，边框等）</p>
</li>
<li><p><strong>Display</strong>: 图层的寄宿图片被绘制的阶段。绘制有可能涉及你的-drawRect:和-drawLayer:inContext:方法的调用路径。</p>
</li>
<li><p><strong>Prepare</strong>: 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</p>
</li>
<li><p><strong>Commit</strong>: 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</p>
</li>
</ul>
<h5 id="2、Render-Server"><a href="#2、Render-Server" class="headerlink" title="2、Render Server"></a>2、Render Server</h5><p>​    负责渲染工作，会解析上一步Commit Transaction中提交的信息并<strong>反序列化成渲染树</strong>（render tree)，随后根据layer的各种属性生成绘制指令，并在下一次VSync(垂直同步)信号到来时调用OpenGL进行渲染。</p>
<h5 id="3、GPU"><a href="#3、GPU" class="headerlink" title="3、GPU"></a>3、GPU</h5><ul>
<li>GPU会等待显示器的VSync信号发出后才进行OpenGL渲染管线，将3D几何数据转化成2D的像素图像和光栅处理，随后进行新的一帧的渲染，并将其输出到缓冲区。</li>
</ul>
<h5 id="4、Display"><a href="#4、Display" class="headerlink" title="4、Display"></a>4、Display</h5><ul>
<li>从缓冲区中取出画面，并输出到屏幕上</li>
</ul>
<p><strong>说明1</strong>：开发者真正能做的，只是在<strong>Layout</strong>(布局)<strong>和Display</strong>(显示)环节</p>
<p><strong>说明2</strong>：</p>
<ul>
<li><p>某个视图的图层属性所做的修改，都是在当前Runloop结束之前，Core Animation才将修改提交；</p>
</li>
<li><p>因为Core Animation的Commit Transaction是在主线程完成的，虽然Core Animation也支持异步渲染，但是UIKit就是把这些个事情放在主线程做。</p>
</li>
</ul>
<blockquote>
<p>VSync（vertical sync）是指垂直同步，在玩游戏的时候在设置的时候应该会看见过这个选项，这个机制能够让显卡和显示器保持在一个相同的刷新率从而避免画面撕裂。在iOS中，屏幕具有60Hz的刷新率，这意味着它每秒需要显示60张不同的图片（帧），但GPU并没有一个确定的刷新率，在某些时候GPU可能被要求更强力的数据输出来确保渲染能力，这时候他们可能比屏幕刷新率（60Hz）更快，就会导致屏幕不能完整的渲染所有GPU给他的数据，因为它不够快，屏幕的上一帧还没渲染完，下一帧就已经到来了，这就导致画面的撕裂。</p>
<p>这个时候我们就要引入VSync了，简单来说它就是让显卡保持他的输出速率不高于屏幕的刷新率，启用了VSync后，GPU不再会给你可怜的60Hz屏幕每秒发送100帧了，它会增加每一帧的发送间隔，确保显示器能够有充足的时间去处理每一帧。</p>
</blockquote>
<h4 id="三、CATransaction"><a href="#三、CATransaction" class="headerlink" title="三、CATransaction"></a>三、CATransaction</h4><h5 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h5><ul>
<li><strong>CATransaction</strong>是 Core Animation 中的<strong>事务类</strong>，在iOS中的图层中，图层的每个改变都是事务的一部分，CATransaction可以对多个layer的属性同时进行修改，负责成批地把多个图层树的修改作为 一个原子操作 更新到<strong>渲染树</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[CATransaction begin];</span><br><span class="line">[CATransaction setCompletionBlock:^&#123;</span><br><span class="line">    //complete block</span><br><span class="line">&#125;];</span><br><span class="line">// do animation</span><br><span class="line">[CATransaction commit];</span><br></pre></td></tr></table></figure>
<h5 id="2、事务的特性"><a href="#2、事务的特性" class="headerlink" title="2、事务的特性"></a>2、事务的特性</h5><ul>
<li><p><strong>事务允许嵌套</strong>。但是嵌套在内层的事务不会立即commit，会在最外层的事务结束后统一commit。</p>
</li>
<li><p>事务分显式事务和隐式事务两种，如果当前没有显式创建过CATransaction，则系统会<strong>创建一个隐式的CATransaction，</strong>CATransaction会在下一个RunLoop自动提交。</p>
</li>
<li><p>CATransaction会在背后独立完成图层树属性计算的工作。系统提供API来显式的使用事务类，并且手动提交给渲染服务进程，这种做法被称作推进过渡。推进过渡会生成一个默认时长为0.25s时长的动画效果来完成属性值的修改。</p>
</li>
<li><p>CATransaction可以设置完成块，允许在动画结束之后执行一个完成动作，类似UIView动画的block。</p>
</li>
</ul>
<h5 id="3、CATransaction的使用"><a href="#3、CATransaction的使用" class="headerlink" title="3、CATransaction的使用"></a>3、CATransaction的使用</h5><ul>
<li><strong>禁止隐式动画</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1、禁止隐式动画</span><br><span class="line">[CATransaction beign];</span><br><span class="line">[CATransaction setDisableActions:Yes];</span><br><span class="line">[self.tableview reloadData];</span><br><span class="line">[CATransaction commit];</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>设置动画参数</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//2、设置动画参数</span><br><span class="line">[CATransaction begin];</span><br><span class="line">[CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithControlPoints:.15 :.12 :0 :1]];</span><br><span class="line">[UIView animateWithDuration:.42 delay:0 options:7 animations:^&#123;</span><br><span class="line">     //opearator</span><br><span class="line"> &#125; completion:nil];</span><br><span class="line"> [CATransaction commit];</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>处理动画结束后操作</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//3、处理动画结束后操作</span><br><span class="line">[CATransaction begin];</span><br><span class="line">[tableView beginUpdates];</span><br><span class="line">[CATransaction setCompletionBlock:^&#123;</span><br><span class="line">    //动画执行结束后更新操作,注意放在动画开始之前</span><br><span class="line">&#125;];  </span><br><span class="line">[self.tableView insertRowsAtIndexPaths:insertIndexPaths withRowAnimation:UITableViewRowAnimationFade];</span><br><span class="line">[tableView endUpdates];</span><br><span class="line">[CATransaction commit];</span><br><span class="line">//说明：beginUpdates和endUpdates可以在改变一些行（row）的高度时自带动画，并且不需要Reload row（不用调用cellForRow，仅仅需要调用heightForRow，这样效率最高）。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：setCompletionBlock设置在动画之前，才会在动画执行后执行completionBlock。</p>
<h4 id="四、模型图层和呈现图层"><a href="#四、模型图层和呈现图层" class="headerlink" title="四、模型图层和呈现图层"></a>四、模型图层和呈现图层</h4><p>Core Animation作为一个复合引擎，将不同的视图层组合在屏幕中，并且存储在图层树中，向我们展示了所有屏幕上的一切。整个过程其实经历了模型树–&gt;呈现树–&gt;渲染树，才显示到了屏幕上。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-3dee035ee05bc931.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<h5 id="1、模型图层-和-模型树"><a href="#1、模型图层-和-模型树" class="headerlink" title="1、模型图层 和 模型树"></a>1、模型图层 和 模型树</h5><ul>
<li><p>当设置CALayer的属性，实际上是在定义当前事务结束之后<strong>图层如何显示的**</strong>模型，<strong>在一个图层上调用调用-</strong>modelLayer<strong>会返回self; （在呈现图层(presentationLayer)上调用–</strong>modelLayer<strong>将会返回它正在呈现所依赖的</strong>CALayer**）</p>
</li>
<li><p>当你改变一个图层的属性，属性值是立刻更新的，但是<strong>屏幕上没有马上发生改变</strong>，因为设置的属性是代表图层动画结束<strong>(默动画时间0.25s</strong>)后将要达到的外观。(换种方式表达)</p>
</li>
<li><p>在当前RunLoop结束后，会将<strong>模型树</strong>相关内容（层次结构、图层属性和动画）序列化，通过IPC传递给专门负责屏幕渲染的渲染进程(Render Server)。渲染进程(Render Server)拿到数据并反序列化出树状结构–<strong>呈现树</strong>。呈现树中的呈现图层实际上是模型图层的复制，但是它的属性值<strong>代表了在任何指定时刻当前外观效果</strong>。</p>
</li>
</ul>
<h5 id="2、呈现图层-和-呈现树"><a href="#2、呈现图层-和-呈现树" class="headerlink" title="2、呈现图层 和 呈现树"></a>2、呈现图层 和 呈现树</h5><ul>
<li><p>每个图层属性的<strong>显示值</strong>都被存储在一个叫做<strong>呈现图层</strong>的独立图层当中，他可以通过-presentationLayer方法来访问。这个<strong>呈现图层实际上是模型图层的复制</strong>，<strong>但是它的属性值代表了在任何指定时刻当前外观效果</strong>。换句话说，你可以<strong>通过呈现图层的值来获取当前屏幕上真正显示出来的值。</strong></p>
</li>
<li><p>呈现树通过<strong>图层树</strong>中<strong>所有图层的呈现图层</strong>所形成。<strong>注意</strong>呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用-presentationLayer将会返回nil。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//打印某layer本身、layer.modelLayer、self.colorLayer.presentationLayer.modelLayer，指的都是同一个CALayer对象</span><br><span class="line">self.colorLayer = &lt;CALayer: 0x600003035540&gt;</span><br><span class="line">self.colorLayer.modelLayer = &lt;CALayer: 0x600003035540&gt;</span><br><span class="line">self.colorLayer.presentationLayer.modelLayer = &lt;CALayer: 0x600003035540&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-679b066a9523a748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<h5 id="3、呈现图层的应用"><a href="#3、呈现图层的应用" class="headerlink" title="3、呈现图层的应用"></a>3、呈现图层的应用</h5><p>大多数情况下，你不需要直接访问呈现图层，可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下会变得很有用，一个是同步动画，一个是处理用户交互。</p>
<ul>
<li><p>如果你在实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候<strong>准确地知道在某一时刻图层显示在什么位置就需要用到 呈现图层；</strong></p>
</li>
<li><p>让动画的图层响应用户输入，使用<em>呈现</em>图层的-hitTest:来判断指定图层是否被触摸，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    //get the touch point</span><br><span class="line">    CGPoint point = [[touches anyObject] locationInView:self.view];</span><br><span class="line">    //check if we&apos;ve tapped the moving layer</span><br><span class="line">    if ([self.colorLayer.presentationLayer hitTest:point]) &#123;</span><br><span class="line">        //randomize the layer background color</span><br><span class="line">        CGFloat red = arc4random() / (CGFloat)INT_MAX;</span><br><span class="line">        CGFloat green = arc4random() / (CGFloat)INT_MAX;</span><br><span class="line">        CGFloat blue = arc4random() / (CGFloat)INT_MAX;</span><br><span class="line">        self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //otherwise (slowly) move the layer to new position</span><br><span class="line">        [CATransaction begin];</span><br><span class="line">        [CATransaction setAnimationDuration:3.0];</span><br><span class="line">        self.colorLayer.position = point;</span><br><span class="line">        [CATransaction commit];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：如果-hitTest:直接作用于<em>colorLayer</em>而不是呈现图层，在图层移动时候不能修改颜色。</p>
<h4 id="五、隐式动画"><a href="#五、隐式动画" class="headerlink" title="五、隐式动画"></a>五、隐式动画</h4><h5 id="1、什么是隐式动画"><a href="#1、什么是隐式动画" class="headerlink" title="1、什么是隐式动画"></a>1、什么是隐式动画</h5><ul>
<li><strong>修改CALayer的部分属性，如</strong>bounds、backgroundColor、position，默认会自动产生一些动画效果(如 缩放、背景色渐变和平移)。</li>
</ul>
<h5 id="2、隐式动画的实现"><a href="#2、隐式动画的实现" class="headerlink" title="2、隐式动画的实现"></a>2、隐式动画的实现</h5><p>当CALayer的(可做动画的)属性被改变时候，CALayer通过调用actionForKey:方法来查找对应的action对象(实现了CAAction协议的对象)，查找顺序如下：</p>
<ul>
<li><p>如果设置了CALayer的代理，可以通过执行代理方法actionForLayer:forKey:返回一个action对象。该方法可以返回CAAnimation对象、nil、[NSNull null]。其中nil表示结束actionForLayer:forKey:方法的执行，继续搜索下一个阶段，[NSNull null]表示结束搜索，即结束actionForLayer:forKey:，也结束其他阶段，将不会有隐式动画。</p>
</li>
<li><p>查找CALayer的actions属性，看key是否有对应的值。</p>
</li>
<li><p>查找CALayer style属性</p>
</li>
<li><p>调用CALayer的defaultActionForKey方法</p>
</li>
<li><p>如果搜索到了最后阶段，layer会执行一个默认的action对象，一般是CABasicAnimation。</p>
</li>
</ul>
<p><strong>说明</strong>：经过一轮完整的搜索后，-<strong>actionForKey</strong>:要么返回空(nil，这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@protocol CAAction</span><br><span class="line">- (void)runActionForKey:(NSString *)event object:(id)anObject</span><br><span class="line">    arguments:(nullable NSDictionary *)dict;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="3、UIKit如何禁止掉隐式动画"><a href="#3、UIKit如何禁止掉隐式动画" class="headerlink" title="3、UIKit如何禁止掉隐式动画"></a>3、UIKit如何禁止掉隐式动画</h5><ul>
<li><p>在Core Animation库中，对CALayer的所有属性（可动画的属性）都做了动画，但是在UIKit中的UIView把它关联的图层的这个特性关闭了</p>
</li>
<li><p>每个UIView对它关联的图层都扮演了一个委托，并且提供了-<strong>actionForLayer:forKey</strong>的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回[NSNull null]，但是在动画block范围之内，它就返回了一个非空值。</p>
</li>
<li><p>还可以通过CATransacition的setDisableActions:方法关闭隐式动画。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[CATransaction begin];</span><br><span class="line">[CATransaction setDisableActions:YES];</span><br><span class="line"> //...</span><br><span class="line">[CATransaction commit];</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：设置setDisableActionsYES后，CALayer的actionForKey:方法将不会被调用，隐式动画也不会生成。</p>
<h5 id="4、actionForKey-和actionForLayer-的区别"><a href="#4、actionForKey-和actionForLayer-的区别" class="headerlink" title="4、actionForKey:和actionForLayer:的区别"></a>4、actionForKey:和actionForLayer:的区别</h5><ul>
<li><p>两个方法都返回action对象，但是actionForLayer:需要设置代理，由代理实现；</p>
</li>
<li><p>如果在<strong>actionForKey :</strong>里返回<code>nil</code>或<code>[NSNull null]</code>，那么搜索会停止，而如果在<strong>actionForLayer:</strong>里返回<code>nil</code>会停止<code>actionForLayer:</code>去搜索下一阶段，返回<code>[NSNull null]</code>才会停止搜索。</p>
</li>
</ul>
<h4 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h4><h5 id="1、UIKit不是线程安全的"><a href="#1、UIKit不是线程安全的" class="headerlink" title="1、UIKit不是线程安全的"></a>1、UIKit不是线程安全的</h5><ul>
<li>UIKit中，很多类中大部分的属性都被修饰为<strong>nonatomic</strong>，这意味着它们不能在多线程的环境下工作，而对于UIKit这样一个庞大的框架，将其所有属性都设计为线程安全是不现实的，这可不仅仅是简单的将nonatomic改成atomic或者是加锁解锁的操作，还涉及到很多的方面：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) 假设能够异步设置view的属性，那我们究竟是希望这些改动能够同时生效，还是按照各自runloop的进度去改变这个view的属性呢？</span><br><span class="line"></span><br><span class="line">2) 假设UITableView在其他线程去移除了一个cell，而在另一个线程却对这个cell所在的index进行一些操作，这时候可能就会引发crash。</span><br><span class="line"></span><br><span class="line">3) 如果在后台线程移除了一个view，这个时候runloop周期还没有完结，用户在主线程点击了这个“将要”消失的view，那么究竟该不该响应事件？在哪条线程进行响应？</span><br></pre></td></tr></table></figure>
<p> <strong>总结</strong>：</p>
<ul>
<li><p>将UIKit设置为线程安全并不能带来太多便利，也不会提升太多的性能表现，甚至会因为加锁解锁而耗费大量的时间。</p>
</li>
<li><p>事实上并发编程也没有因为UIKit是线程不安全而变得困难，我们所需要做的只是要确保UI操作在主线程进行就可以了。</p>
</li>
</ul>
<h5 id="2、UIKit为什么选择主线程"><a href="#2、UIKit为什么选择主线程" class="headerlink" title="2、UIKit为什么选择主线程"></a>2、UIKit为什么选择主线程</h5><ul>
<li><p>UIApplication在<strong>主线程</strong>所初始化的Runloop我们称为<strong>Main Runloop</strong>，它负责处理app存活期间的大部分事件，如<strong>用户交互</strong>等，它一直处于不断处理事件和休眠的循环之中，以确保能尽快的将用户事件传递给GPU进行渲染，使用户行为能够得到响应，画面之所以能够得到不断刷新也是因为Main Runloop在驱动着。</p>
</li>
<li><p>而每一个<strong>view的变化的修改并不是立刻变化，相反的会在当前RunLoop的结束的时候统一进行重绘</strong>，这样设计的目的是为了能够在一个Runloop里面处理好所有需要变化的view，包括resize、hide、reposition等等，所有view的改变都能在同一时间生效，这样能够更高效的处理绘制，这个机制被称为<strong>绘图循环（View Drawing Cycle</strong>)。</p>
</li>
<li><p><strong>如果我们的UIKit并不是在主线程，所以Main Runloop中的事件需要跨线程进行传输，这样会导致显示与用户事件并不同步；</strong></p>
</li>
<li><p>这是因为点击等事件是由系统传递给UIApplication中，并在Main Runloop中进行处理与响应，但是由于UI在后台线程中进行处理，所以他跟事件响应并不同步。即使在UI所在的后台线程也自己维护了一个Runloop，在Runloop结束时候进行渲染。</p>
</li>
<li><p>UI操作涉及到渲染访问各种View对象的属性，如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度。另一方面因为整个程序的起点UIApplication是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以view只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上 同时 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。</p>
</li>
</ul>
<h5 id="3、AsyncDisplayKit"><a href="#3、AsyncDisplayKit" class="headerlink" title="3、AsyncDisplayKit"></a>3、AsyncDisplayKit</h5><ul>
<li>AsyncDisplayKit（现命名为Texture，建立在UIKit之上的iOS框架简述如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Texture的基本单位就是node。 **ASDisplayNode**是一个抽象UIView，j就想UIView是一个抽象CALayer。不同于只能在主线程上使用的视图，nodes是线程安全的：您可以在后台线程上并行实例化和配置它们的整个层次结构。</span><br><span class="line"></span><br><span class="line">为了保持其用户界面的流畅和响应，您的应用程序应该以每秒60帧的速度呈现 - iOS上的黄金标准。这意味着主线程有一秒钟的时间推动每个帧。这是执行所有布局和绘图代码的16毫秒！并且由于系统开销，您的代码通常在导致帧丢失之前运行不到10毫秒。</span><br><span class="line"></span><br><span class="line">Texture使您可以从主线程移除图像解码，文本大小和渲染以及其他昂贵的UI操作到其它线程，以保持主线程可用于响应用户交互。</span><br></pre></td></tr></table></figure>
<p><strong>更多参考：</strong></p>
<p><a href="https://www.jianshu.com/p/cd4b445a6a35" target="_blank" rel="noopener">Texture——保持最复杂的用户界面的流畅和响应</a></p>
<p><a href="http://www.cocoachina.com/ios/20180209/22243.html" target="_blank" rel="noopener">iOS 开发一定要尝试的 Texture(ASDK)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/03/20/iOS-SystemBasic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/iOS-SystemBasic/" itemprop="url">OSX/iOS 的系统架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T12:00:13+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS知识小集/" itemprop="url" rel="index">
                    <span itemprop="name">iOS知识小集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  710 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、系统架构"><a href="#一、系统架构" class="headerlink" title="一、系统架构"></a>一、系统架构</h3><p>苹果官方将整个系统大致划分为下述4个层次</p>
<h4 id="1、-应用层"><a href="#1、-应用层" class="headerlink" title="1、 应用层"></a>1、 应用层</h4><p>包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringBoard：iOS的桌面</span><br><span class="line">Spotlight：搜索界面</span><br><span class="line">Aqua：Mac OS X的桌面 ？？</span><br></pre></td></tr></table></figure>
<h4 id="2、应用框架层"><a href="#2、应用框架层" class="headerlink" title="2、应用框架层"></a>2、应用框架层</h4><p>即开发人员接触到的 Cocoa 等框架</p>
<h4 id="3、核心框架层"><a href="#3、核心框架层" class="headerlink" title="3、核心框架层"></a>3、核心框架层</h4><p>各种核心框架、OpenGL 等内容</p>
<h4 id="4、Darwin"><a href="#4、Darwin" class="headerlink" title="4、Darwin"></a>4、Darwin</h4><p>操作系统的核心，包括系统内核、驱动、Shell 等内容，源码可以访问<a href="http://opensource.apple.com" target="_blank" rel="noopener">opensource.apple.com</a> </p>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-8d4708bdfac3da31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<h3 id="二、Darwin-核心的架构"><a href="#二、Darwin-核心的架构" class="headerlink" title="二、Darwin 核心的架构"></a>二、Darwin 核心的架构</h3><p><img src="https://upload-images.jianshu.io/upload_images/201701-f69c10b12fcdc42f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<ul>
<li><p>XNU是Darwin操作系统的一部分，是操作系统的内核，主要有<strong>Mach</strong>、<strong>BSD</strong>、<strong>IOKit**</strong>,** </p>
</li>
<li><p>XNU内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如<strong>处理器调度</strong>、<strong>IPC</strong> (进程间通信)等非常少量的基础服务。 </p>
</li>
<li><p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能</p>
</li>
<li><p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
</li>
<li><p><strong>Mach</strong> 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。</p>
</li>
<li><p>在 Mach 中，所有的东西都是通过自己的对象实现的，<strong>进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</strong></p>
</li>
</ul>
<h3 id="三、Mach-消息"><a href="#三、Mach-消息" class="headerlink" title="三、Mach 消息"></a>三、Mach 消息</h3><h4 id="1、消息的定义"><a href="#1、消息的定义" class="headerlink" title="1、消息的定义"></a>1、消息的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  mach_msg_header_t header;</span><br><span class="line">  mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line">  </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  mach_msg_bits_t msgh_bits;</span><br><span class="line">  mach_msg_size_t msgh_size;</span><br><span class="line">  mach_port_t msgh_remote_port;</span><br><span class="line">  mach_port_t msgh_local_port;</span><br><span class="line">  mach_port_name_t msgh_voucher_port;</span><br><span class="line">  mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure>
<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port， 发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">    mach_msg_header_t *msg,</span><br><span class="line">    mach_msg_option_t option,</span><br><span class="line">    mach_msg_size_t send_size,</span><br><span class="line">    mach_msg_size_t rcv_size,</span><br><span class="line">    mach_port_name_t rcv_name,</span><br><span class="line">    mach_msg_timeout_t timeout,</span><br><span class="line">    mach_port_name_t notify);</span><br></pre></td></tr></table></figure>
<h4 id="2、消息发送和接收"><a href="#2、消息发送和接收" class="headerlink" title="2、消息发送和接收"></a>2、消息发送和接收</h4><p>为了实现消息的<strong>发送</strong>和<strong>接收</strong>，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数<strong>mach_msg_trap</strong>()，trap这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/201701-09914a1f3cdd0484.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<ul>
<li>RunLoop 的核心就是一个 mach_msg()，RunLoop 调用这个函数去接收消息，<strong>如果没有别人发送 port 消息过来，内核会将线程置于等待状态</strong>。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/02/28/iOS-iOSJavaScriptCore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/iOS-iOSJavaScriptCore/" itemprop="url">JavaScriptCore小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T00:07:41+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,587 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、JavaScriptCore核心类和协议"><a href="#一、JavaScriptCore核心类和协议" class="headerlink" title="一、JavaScriptCore核心类和协议"></a>一、JavaScriptCore核心类和协议</h4><ul>
<li><p>JavaScriptCore给iOS开发的第一反应是<strong>实现原生应用和Web应用之间通信</strong></p>
</li>
<li><p>实际上，JavaScriptCore是iOS 7推出的<strong>JavaScript引擎</strong>，是为了实现OC和JS通信，使用场景不局限于在原生应用和Web应用间使用(<em>虽然这是大部分场景</em>)。</p>
</li>
</ul>
<h5 id="1、-JSContext"><a href="#1、-JSContext" class="headerlink" title="1、 JSContext"></a>1、 JSContext</h5><ul>
<li><strong>JavaScript运行的上下文环境</strong>，使用JSContext对象来执行JavaScript代码，所有的JSValue对象都由JSContext对象管理。</li>
</ul>
<h5 id="2、JSValue"><a href="#2、JSValue" class="headerlink" title="2、JSValue"></a>2、JSValue</h5><ul>
<li><p><strong>代表一个JavaScript实体</strong>，不仅可以表示JavaScript原始类型数据如boolean、Number、String等，还可以表示对象和函数。OC和JS对象之间的转换如下表：</p>
<p> |Objective-C type  |   JavaScript type|</p>
<pre><code>|--|--|
|nil | undefined|
|NSNull       |        null|
|NSString      |       string|
|NSNumber      |   number, boolean|
|NSDictionary    |   Object object|
|NSArray       |    Array object|
|NSDate       |     Date object|
|NSBlock   |   Function object |
|id     |   Wrapper object |
|Class | Constructor object|
</code></pre></li>
</ul>
<h5 id="3、-JSManagedValue"><a href="#3、-JSManagedValue" class="headerlink" title="3、 JSManagedValue"></a>3、 JSManagedValue</h5><ul>
<li>本质是<strong>弱引用的JSValue对象</strong>，可以处理内存管理中的一些特殊情形，它能帮助引用技术和垃圾回收这两种内存管理机制之间进行正确的转换。如代替JSValue对象被OC对象持有避免发生循环引用(<em>本文后面会讲解</em>)。</li>
</ul>
<h5 id="4、JSVirtualMachine"><a href="#4、JSVirtualMachine" class="headerlink" title="4、JSVirtualMachine"></a>4、JSVirtualMachine</h5><ul>
<li><strong>JavaScript运行的虚拟机</strong>，拥有自己的堆结构和垃圾回收机制。大部分情况下不需要和它直接交互，除非要处理一些特殊的多线程或者内存管理问题。</li>
</ul>
<h5 id="5、JSExport"><a href="#5、JSExport" class="headerlink" title="5、JSExport"></a>5、JSExport</h5><ul>
<li><p><strong>将OC对象直接转成JS对象的协议</strong>，可以将OC类的属性或方法转换为JS的属性或方法。使用时，继承JSExport定义自己的协议，然后在自己的协议中定义暴露给JavaScript的方法；</p>
</li>
<li><p><strong>方法由Objective-C中的类实现</strong>；JavaScriptCore将实现类的对象注入JSContext运行环境中，使用注入的名称调用JS方法就会自动调用这个对象对应的OC方法。</p>
</li>
</ul>
<h4 id="二、Objective-C调用JavaScript代码"><a href="#二、Objective-C调用JavaScript代码" class="headerlink" title="二、Objective-C调用JavaScript代码"></a>二、Objective-C调用JavaScript代码</h4><h5 id="1、Objective-C直接执行JavaScript代码"><a href="#1、Objective-C直接执行JavaScript代码" class="headerlink" title="1、Objective-C直接执行JavaScript代码"></a>1、Objective-C直接执行JavaScript代码</h5><p><strong>1）JSContext</strong>为JavaScript提供运行的上下文环境，执行JavaScript代码前必须先创建JSContext对象，创建JSContext对象之后，才可以调用JSContext的evaluateScript:方法可以执行JavaScript代码了，如创建变量，做计算，定义方法等。</p>
<p><strong>2）JSContext</strong>的创建都是基于<strong>JSVirtualMachine</strong>(<em>JSVirtualMachine为JavaScript的运行提供了底层资源</em>)，默认使用init进行初始化，在其内部会自动创建一个新的JSVirtualMachine对象，然后根据JSVirtualMachine对象初始化JSContext对象。</p>
<p><strong>3）JSContext的evaluateScript:方法的返回值类型是JSValue</strong>， JSValue 封装了每一个可能的 JavaScript 值，如字符串和数字、数组、对象、方法、甚至错误和特殊的 JavaScript 值诸如 null 和 undefined等。对JSValue调用toString、toBool、toDouble、toArray等等方法把它转换成合适的Objective-C值或对象。</p>
<p><strong>4） 示例代码如下</strong>。XCode控制台输出12，是调用add(5,7)代码执行后的结果值。</p>
<pre><code>- (void)ocCallJsCode{

    JSContext *context = [[JSContext alloc]init];
    [context evaluateScript:@&quot;var a = 5,b = 7&quot;];
    [context evaluateScript:@&quot;function add(a,b){return a+b}&quot;];
    JSValue *addValue = [context evaluateScript:@&quot;add(5,7)&quot;];
    NSLog(@&quot;addValue = %d&quot;,addValue.toInt32);    
}
</code></pre><h5 id="2、Objective-C执行JavaScript代码文件"><a href="#2、Objective-C执行JavaScript代码文件" class="headerlink" title="2、Objective-C执行JavaScript代码文件"></a>2、Objective-C执行JavaScript代码文件</h5><p>首先初始化了一个JSContext对象，然后执行JavaScript文件中的代码，最后从JSContext对象中取出JS函数，使用callWithArguments:调用JS函数，参数是一个数组，如果没有参数则传入空数组@[]</p>
<p><strong>1）在项目中新建一个occalljs.js的文件，定义了加减乘除四个JS函数，代码如下：</strong></p>
<pre><code>function add(a,b){
    return a + b
}

function sub(a,b){
    return a - b
}

function mul(a,b){
    return a * b
}

function div(a,b){
    return a / b
}
</code></pre><p><strong>2） OC代码中执行JS代码文件</strong></p>
<pre><code>- (void)ocCallJsCodeInFile{

    JSContext *context = [[JSContext alloc]init];
    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;calculate&quot; ofType:@&quot;js&quot;];
    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];
    [context evaluateScript:jsContent];

    JSValue *addValue = [context[@&quot;add&quot;] callWithArguments:@[@5,@7]];
    NSLog(@&quot;5 + 7 = %d&quot;,addValue.toInt32);

    JSValue *subValue = [context[@&quot;sub&quot;] callWithArguments:@[@5,@7]];
    NSLog(@&quot;5 - 7 = %d&quot;,subValue.toInt32);

    JSValue *mulValue = [context[@&quot;mul&quot;] callWithArguments:@[@5,@7]];
    NSLog(@&quot;5 * 7 = %d&quot;,mulValue.toInt32);

    JSValue *divValue = [context[@&quot;div&quot;] callWithArguments:@[@5,@7.0]];
    NSLog(@&quot;5 / 7 = %.2lf&quot;,divValue.toDouble);
}
</code></pre><p><strong>总结：</strong>通过JSContext和JSValue的配合使用，实现了Objective-C执行JavaScript代码。</p>
<h4 id="三、JavaScript调用Objective-C代码"><a href="#三、JavaScript调用Objective-C代码" class="headerlink" title="三、JavaScript调用Objective-C代码"></a>三、JavaScript调用Objective-C代码</h4><p>可以使用两种方式实现JavaScript调用Objective-C代码</p>
<h5 id="方式一：在OC中定义block，使用block代替JS的函数实现"><a href="#方式一：在OC中定义block，使用block代替JS的函数实现" class="headerlink" title="方式一：在OC中定义block，使用block代替JS的函数实现"></a>方式一：在OC中定义<strong>block</strong>，使用block代替JS的函数实现</h5><p>代码如下：</p>
<p><strong>1、新建一个jscalloc1.js的文件，定义了两个方法，代码如下：</strong></p>
<pre><code>function sayHello() {
    print(&quot;你好&quot;);
}

function showAlert() {
    alert(&quot;Alert!!!&quot;);
}
</code></pre><p><strong>2、oc中实现block代替js方法，代码如下：</strong></p>
<pre><code>- (void)jsCalloc1{

    JSContext *context = [[JSContext alloc]init];
    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;jscalloc&quot; ofType:@&quot;js&quot;];
    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];
    [context evaluateScript:jsContent];

    //block替换js中的print方法
    context[@&quot;print&quot;] = ^(NSString *printStr){

        NSLog(@&quot;printStr = %@&quot;,printStr);
    };

    __weak typeof(self) weakSelf = self;
    //block替换js中的alert方法
    context[@&quot;alert&quot;] = ^(NSString *alertStr){
        __strong typeof(weakSelf) strongSelf = weakSelf;
        UIAlertController *vc = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:alertStr preferredStyle:UIAlertControllerStyleAlert];
        [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDestructive handler:nil]];
        [strongSelf presentViewController:vc animated:YES completion:nil];
    };

    //执行
    [context[@&quot;sayHello&quot;] callWithArguments:nil];
    [context[@&quot;showAlert&quot;] callWithArguments:nil];
}
</code></pre><p><strong>说明1</strong>：在代码中，我们将两个Block分别以”print”和“alert”为名传递给JavaScript上下文。在JS中调用print函数或者alert函数，其实就是执行在oc中定义的Block；也就实现了<strong>JavaScript调用Objective-C代码</strong>。</p>
<p><strong>说明2</strong>：JavaScript中的字符串可以无缝的桥接为NSString。</p>
<p><strong>说明3</strong>: 当JavaScript运行时出现异常，会回调JSContext的exceptionHandler中设置的Block，我们通过Block的方式将异常信息打印处理</p>
<pre><code>context.exceptionHandler = ^(JSContext *context, JSValue *exception) {
       NSLog(@&quot;JS Error: %@&quot;, exception);
};
</code></pre><h5 id="方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中"><a href="#方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中" class="headerlink" title="方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中"></a>方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中</h5><p>代码如下：</p>
<p><strong>1、新建一个jscalloc2.js的文件，定义了两个方法，代码如下：</strong></p>
<pre><code>function sayHello() {
    qsobj.print(&quot;你好&quot;);
}

function showAlert() {
    qsobj.alert(&quot;Alert!!!&quot;);
}
</code></pre><p><strong>2、OC中实现QSExportObject类，将QSExportObject对象qsobj注入到JS执行的上下文环境中，JS中执行qsobj.print和qsobj.alert函数，就是执行OC对象qsobj的方法</strong>，代码如下：</p>
<pre><code> //QSExportObject.h
@protocol QSExport &lt;JSExport&gt;

- (void)print:(NSString *)text;
- (void)alert:(NSString *)text;

//JSExportAs(print,- (void)print:(NSString *)text);
//JSExportAs(alert,- (void)alert:(NSString *)text);
@end

@interface QSExportObject : NSObject&lt;QSExport&gt;
@property (nonatomic,weak)UIViewController *vc;
@end

//QSExportObject.m
@implementation QSExportObject

- (void)print:(NSString *)text{
    NSLog(@&quot;print text = %@&quot;,text);
}

- (void)alert:(NSString *)text{

    UIAlertController *vc = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:text preferredStyle:UIAlertControllerStyleAlert];
    [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDestructive handler:nil]];
    [self.vc presentViewController:vc animated:YES completion:nil];
}
@end

//在ViewController中调用
 - (void)jsCallOc2{

    JSContext *context = [[JSContext alloc]init];
    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;jscalloc2&quot; ofType:@&quot;js&quot;];
    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];
    [context evaluateScript:jsContent];
    //注入qsObj
    QSExportObject *qsObj = [QSExportObject new];
    qsObj.vc = self;
    context[@&quot;qsobj&quot;] = qsObj;

     //执行
    [context[@&quot;sayHello&quot;] callWithArguments:nil];
    [context[@&quot;showAlert&quot;] callWithArguments:nil];
}
</code></pre><p><strong>说明1</strong>：在QSExport中定义暴露给JS的接口，也可以使用宏<strong>JSExportAs</strong>，它将JS函数和OC方法绑定在一起；对于OC中多参数的方法，一般使用<strong>JSExportAs</strong>。</p>
<h4 id="四、循环引问题"><a href="#四、循环引问题" class="headerlink" title="四、循环引问题"></a>四、循环引问题</h4><p><strong>说明</strong>：Objective-C的内存管理机制是<strong>引用计数</strong>，JavaScript的内存管理机制是<strong>垃圾回收</strong>。在大部分情况下，JavaScriptCore能做到在这两种内存管理机制之间无缝无错转换，但是有些情况下会发生循环引用。</p>
<h5 id="1、block直接使用self-context-会发生循环引用"><a href="#1、block直接使用self-context-会发生循环引用" class="headerlink" title="1、block直接使用self.context 会发生循环引用"></a>1、block直接使用self.context 会发生循环引用</h5><p>打破这类循环引用的办法有两种。</p>
<p><strong>1）方法1：weakSelf和strongSelf</strong></p>
<pre><code>[self.context evaluateScript:@&quot;function printAppVersion() { print(getAppVersion())}&quot;];
self.context[@&quot;print&quot;] = ^(NSString *printStr){
    NSLog(@&quot;printStr = %@&quot;,printStr);
};

__weak typeof(self) weakSelf = self;
self.context[@&quot;getAppVersion&quot;] = ^{
    __strong typeof(weakSelf) strongSelf = weakSelf;
    NSString* versionString = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];
    versionString = [@&quot;App Version &quot; stringByAppendingString:versionString];
    JSContext *context = strongSelf.context;
    JSValue *version = [JSValue valueWithObject:versionString inContext:context];
    return version;
};

//执行
[self.context[@&quot;printAppVersion&quot;] callWithArguments:nil];
</code></pre><p><strong>2）方法2：block内使用[JSContext currentContext]代替self.context</strong></p>
<pre><code>[self.context evaluateScript:@&quot;function printAppVersion() { print(getAppVersion())}&quot;];
self.context[@&quot;print&quot;] = ^(NSString *printStr){
    NSLog(@&quot;printStr = %@&quot;,printStr);
};

self.context[@&quot;getAppVersion&quot;] = ^{
    NSString* versionString = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];
    versionString = [@&quot;App Version &quot; stringByAppendingString:versionString];
    JSContext *context = [JSContext currentContext];
    JSValue *version = [JSValue valueWithObject:versionString inContext:context];
    return version;
};

//执行
[self.context[@&quot;printAppVersion&quot;] callWithArguments:nil];
</code></pre><h5 id="2、block中使用外部定义的JSValue对象不会发生循环引用"><a href="#2、block中使用外部定义的JSValue对象不会发生循环引用" class="headerlink" title="2、block中使用外部定义的JSValue对象不会发生循环引用"></a>2、block中使用外部定义的JSValue对象不会发生循环引用</h5><pre><code>[self.context evaluateScript:@&quot;function log() { }&quot;];
JSValue *value = [JSValue valueWithObject:@&quot;test content&quot; inContext:self.context];

self.context[@&quot;log&quot;] = ^(){
    NSLog(@&quot;%@&quot;,value);
};

[self.context[@&quot;log&quot;] callWithArguments:nil];
</code></pre><p><strong>原因：</strong>在block里面直接使用外部定义的JSValue对象不会发生循环引用。以上诉代码为例，JSContext强引用了一个log函数，log函数中又强引用了JSValue对象，JSValue对象强引用JSContext对象和保存的值，JSContext对象引用它管理的所有JSValue对象，这样JSContext和JSValue看上去是循环引用的，然而并不会，<strong>垃圾回收机制会打破这个循环引用</strong>。</p>
<h5 id="3、OC对象保存JSValue容易引起循环引用"><a href="#3、OC对象保存JSValue容易引起循环引用" class="headerlink" title="3、OC对象保存JSValue容易引起循环引用"></a>3、OC对象保存JSValue容易引起循环引用</h5><p>假设下面这样的场景，定义QSAlertView类，该类中持有successHandler，failureHandler这两个JSValue对象，使用block方式注入JS方法时候</p>
<pre><code>self.context[@&quot;presentNativeAlert&quot;] = ^(NSString *title,
                                        NSString *message,
                                        JSValue *successHandler,
                                        JSValue *failureHandler) {
    JSContext *context = [JSContext currentContext];
    QSAlertView *alertView = [[QSAlertView alloc] initWithTitle:title
                                                        message:message
                                                        successHandler:successHandler
                                                 failureHandler:failureHandler
                                                        context:context];
    [alertView show];
};
</code></pre><p><strong>说明</strong>：因为JavaScript环境中都是“强引用”（相对Objective-C的概念来说）的，这时JSContext强引用了一个presentNativeAlert函数，这个函数中又强引用了QSAlertView，等于说JSContext强引用了QSAlertView，而QSAlertView为了持有两个回调强引用了successHandler和failureHandler这两个JSValue，而JSValue又是强引用JSContext的，循环引用便出现了。</p>
<p><strong>打破该类循环引用的方式是：JSMagagedValue对象代替JSValue对象被OC对象持有</strong></p>
<h4 id="五、JSMagagedValue类使用"><a href="#五、JSMagagedValue类使用" class="headerlink" title="五、JSMagagedValue类使用"></a>五、JSMagagedValue类使用</h4><p><strong>JSMagagedValue类</strong>：弱引用对象，需要调用JSVirtualMachine的addManagedReference:withOwner:把它添加到JSVirtualMachine对象中，确保使用过程中JSValue不会被释放 </p>
<pre><code>//QSAlertView.h
@interface QSAlertView : UIAlertView
- (instancetype)initWithTitle:(NSString *)title
                      message:(NSString *)message
               successHandler:(JSValue *)successHandler
               failureHandler:(JSValue *)failureHandler
                      context:(JSContext *)context;
@end

//QSAlertView.m
@interface QSAlertView() &lt;UIAlertViewDelegate&gt;

@property (nonatomic,strong) JSContext *context;
@property (nonatomic,strong) JSManagedValue *successHandler;
@property (nonatomic,strong) JSManagedValue *failureHandler;

@end

@implementation QSAlertView

- (instancetype)initWithTitle:(NSString *)title
                      message:(NSString *)message
               successHandler:(JSValue *)successHandler
               failureHandler:(JSValue *)failureHandler
                      context:(JSContext *)context{

    self = [super initWithTitle:title message:message delegate:self cancelButtonTitle:@&quot;NO&quot; otherButtonTitles:@&quot;YES&quot;, nil];
    if (self) {
        _context = context;
        _successHandler = [JSManagedValue managedValueWithValue:successHandler];
        _failureHandler = [JSManagedValue managedValueWithValue:failureHandler];

        //添加JSManagedValue对象到JSVirtualMachine对象中，防止使用过程被释放
        [_context.virtualMachine addManagedReference:_successHandler withOwner:self];
        [_context.virtualMachine addManagedReference:_failureHandler withOwner:self];
    }
    return self;
}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{

    NSString *btnTitle = [alertView buttonTitleAtIndex:buttonIndex];
    if ([btnTitle isEqualToString:@&quot;YES&quot;]) {

        JSValue *function = [self.successHandler value];
        [function callWithArguments:@[]];

    }else{
        JSValue *function = [self.failureHandler value];
        [function callWithArguments:@[]];
    }
    //移除JSManagedValue对象
    [self.context.virtualMachine removeManagedReference:_successHandler withOwner:self];
    [self.context.virtualMachine removeManagedReference:_failureHandler withOwner:self];
}
@end
</code></pre><p><strong>说明1</strong>：外部传入的JSValue对象在类内部使用JSManagedValue(弱引用对象)来保存<br><strong>说明2</strong>：JSManagedValue对象因为是弱引用对象，需要调用JSVirtualMachine的addManagedReference:withOwner:把它添加到JSVirtualMachine对象中，确保使用过程中JSValue不会被释放<br><strong>说明3</strong>：当用户点击QSAlertView上的按钮时，根据用户点击哪一个按钮，来执行对应的处理函数，这时QSAlertView也随即被销毁。 这时需要手动调用removeManagedReference:withOwner:来移除JSManagedValue对象。</p>
<pre><code>//OC执行JS代码
[self.context evaluateScript:@&quot;function success() {print(&apos;success&apos;) }&quot;];
[self.context evaluateScript:@&quot;function failure() {print(&apos;failure&apos;) }&quot;];
self.context[@&quot;print&quot;] = ^(NSString *printStr){
    NSLog(@&quot;printStr = %@&quot;,printStr);
};
self.context[@&quot;presentNativeAlert&quot;] = ^(NSString *title,
                                        NSString *message,
                                        JSValue *successHandler,
                                        JSValue *failureHandler) {
    JSContext *context = [JSContext currentContext];
    QSAlertView *alertView = [[QSAlertView alloc] initWithTitle:title
                                                        message:message
                                                        successHandler:successHandler
                                                 failureHandler:failureHandler
                                                        context:context];
    [alertView show];
};

[self.context evaluateScript:@&quot;presentNativeAlert(&apos;提示&apos;,&apos;这是一条警告&apos;,success,failure)&quot;];
</code></pre><p><strong>说明1</strong>：在JS中定义了success和failure函数，为JS中的print函数和presentNativeAlert函数注入OC实现。<br><strong>说明2</strong>：点击弹出框的YES，调用JS的success函数，点击弹出框的NO，调用JS的failure函数。</p>
<p><strong>效果图如下：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/201701-b063e377adf7528c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JS函数弹出OC警告框的效果图.png"></p>
<h4 id="六、UIWebView中获取JSContext"><a href="#六、UIWebView中获取JSContext" class="headerlink" title="六、UIWebView中获取JSContext"></a>六、UIWebView中获取JSContext</h4><p>JavaScriptCore实现JS和OC交互是依赖<strong>JSContext对象</strong>，而在UIWebView使用中，不应该手动去创建JSContext对象，因为手动创建JSContext对象和UIWebView对应的JSContext对象并不是同一个JS上下文环境。我们应该去获取UIWebView对应的JSContext对象，虽然Apple并未提供直接的方式，但是我们可以通过KVC +  Runtime这两种方式去获取</p>
<h5 id="1、KVC"><a href="#1、KVC" class="headerlink" title="1、KVC"></a>1、KVC</h5><pre><code>JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];
</code></pre><p>使用简单，但是坑比较多，项目不推荐</p>
<p><strong>原因一</strong>：方法暴力，有不被APP Store的审核通过的风险<br><strong>原因二</strong>：通过KVC获取JSContext对象的时机不好控制，</p>
<ul>
<li><p>在UIWebView的<strong>shouldStartLoadWithRequest</strong>或者<strong>webViewDidStartLoad</strong>阶段中获取context，由于此时页面中的JS代码并没有完全加载完，所以JS中定义的函数在OC端无法被执行。还会出现在加载一级页面时JS可以正常调用OC的方法，而跳转到二级页面中无法执行OC的方法。</p>
</li>
<li><p>在UIWebView的<strong>webViewDidFinishLoad</strong>阶段获取context,并暴露OC方法，由于加载JS的时机在<strong>webVIewDidFinishLoad</strong>阶段之前，因此会发生JS无法调用OC方法的情况发生。</p>
</li>
</ul>
<h5 id="2、Runtime-（项目中使用）"><a href="#2、Runtime-（项目中使用）" class="headerlink" title="2、Runtime （项目中使用）"></a>2、Runtime （项目中使用）</h5><p>UIWebViewTS_JavaScriptContet项目：通过 runtime 机制，巧妙地获取 JavaScriptContext 创建之后，生成回调。</p>
<p>在项目中，实现TSWebViewDelegate中的didCreateJavaScriptContext方法，可以获取UIWebView对应的JSContext对象</p>
<pre><code>- (void)webView:(UIWebView *)webView didCreateJavaScriptContext:(JSContext*) ctx{
      //ctx就是UIWebView对应的JSContext对象
}
</code></pre><h4 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h4><h5 id="1、JS调用OC"><a href="#1、JS调用OC" class="headerlink" title="1、JS调用OC"></a>1、JS调用OC</h5><ul>
<li>通过 JSCore 中的 block</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在 JS 执⾏行行环境中添加⼀一个 _OC_catch 的 block，那么在 JS 代码中就可以直接调⽤用 _OC_catch 这 个函数，当在 JS 中调⽤用 _OC_catch 这个函数后，我们刚才注册的 block 就会被执行。也就是通过 JS 成功的调⽤了 OC 代码。</span><br><span class="line">context[@&quot;_OC_catch&quot;] = ^(JSValue *msg, JSValue *stack) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 JSCore 中的 JSExport</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSExport 可以导出 Objective-C 的属性、实例方法、类方法和初始化⽅方法到 JS 环境，这样就可 以通过 JS 代码直接调⽤用 Objective-C 。通过 JSExport 不仅可以导出⾃自定义类的方法、属性，也可以导出已有类的⽅方法、属性。在导出过程中，类的方法名会被转换成 JS 类型命名，第二个参数的第一个字⺟会被大写，比如- (void)addX:(int)x andY:(int)y;被转为addXAndY(x, y)。除此，JSExport还可以导出已有类的⽅方法、属性。</span><br></pre></td></tr></table></figure>
<ul>
<li>通过拦截 URL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过拦截 URL，这种方式是 Web 端通过某种方式发送 URLScheme 请求，之后 Native 拦截到请求并根据URL SCHEME(包括所带的参数)进行相关操作。类似于通过 SCHEME 唤起APP。这种方式的缺点是 **url 长度有隐患**，并且**创建请求需要一定的耗时**，比注入 API 的方式调用同样的功能。耗时会比较长。所以还是更推荐使用注入 API 的方式。</span><br></pre></td></tr></table></figure>
<h5 id="2、OC-调-JS"><a href="#2、OC-调-JS" class="headerlink" title="2、OC 调 JS"></a>2、OC 调 JS</h5><ul>
<li>UIWebview/WKWebview</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过 UIWebView 来获取 JSContext ，这样直接通过获取到 context 来执⾏行行 JS 代码。</span><br><span class="line">//通过 UIWebView 获取 context</span><br><span class="line">JSContext *context = [_webView</span><br><span class="line">valueForKeyPath:@&quot;documentView.webView.mainFrame.JSContext&quot;]; // 要执行的 JS 代码，定义一个 add 函数并执⾏行行NSString *addjs = @&quot;function add(a, b) &#123;return a + b;&#125;;add(1,3)&quot;;// sumValue 为执⾏行行后的结果</span><br><span class="line">JSValue *sumValue = [self.context evaluateScript:addjs];</span><br><span class="line">//WKWebView 没有提供获取 JSContext 的方法，但是它提供了执行 JS 的方法 evaluateJS: ，通过下面方法来执行 JS 代码。</span><br></pre></td></tr></table></figure>
<ul>
<li>JSCore </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 要执行的 JS 代码，定义一个 add 函数并执⾏行行</span><br><span class="line">NSString *addjs = @&quot;function add(a, b) &#123;return a + b;&#125;;add(1,3)&quot;;// sumValue 为执⾏行行后的结果</span><br><span class="line">JSValue *sumValue = [self.context evaluateScript:addjs]</span><br></pre></td></tr></table></figure>
<p>3、其他</p>
<ul>
<li><p>之前的笔记整理，主要介绍JavaScriptCore的使用，为后续JavaScriptCore深入使用做准备。</p>
</li>
<li><p>本文参考了<a href="http://liuduo.me/2015/10/24/JavaScriptCore%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">JavaScriptCore初探</a> 和 <a href="https://segmentfault.com/a/1190000004285316" target="_blank" rel="noopener">iOS引入JavaScriptCore引擎框架</a></p>
</li>
<li><p><a href="https://github.com/buaa0300/QSKitDemo/tree/master/QSUseJSCoreDemo" target="_blank" rel="noopener">QSUseJSCoreDemo</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/02/24/iOS-IGListKit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/iOS-IGListKit/" itemprop="url">IGListKit</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T21:43:57+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS第三方库/" itemprop="url" rel="index">
                    <span itemprop="name">iOS第三方库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,010 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><h5 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h5><ul>
<li><p><strong>IGListKit</strong>是由 Instagram 开发的应用在自身 App 上的一个 <strong>UI 组件库</strong>。它基于UICollectionView的框架，使用<strong>数据驱动</strong>，旨在创造一个更快更灵活的列表控件。</p>
</li>
<li><p><strong>IGListKit的核心点是：</strong>从Model 变化中计算出 IndexPath 变化，也就是 <strong>Diff</strong> 算法，这样才好 batch updates。</p>
</li>
</ul>
<h5 id="2、结构"><a href="#2、结构" class="headerlink" title="2、结构"></a>2、结构</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-994e7e1fc737bcb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<p><strong>说明</strong>：基于 数据驱动 的 UICollectionView 框架 IGListKit。整个框架通过 <strong>Adapter</strong> 将过去直接暴露的 CollectionView Datasource 和 Delegate 实现进行包装，并通过它关联 Model 和 IGListSectionController。这使得上层用户只需要继承并实现所需要的 IGListSectionController 接口即可，很好地进行了代码解耦。</p>
<h4 id="二、基础使用"><a href="#二、基础使用" class="headerlink" title="二、基础使用"></a>二、基础使用</h4><h5 id="1、IGListAdapter的初始化"><a href="#1、IGListAdapter的初始化" class="headerlink" title="1、IGListAdapter的初始化"></a>1、IGListAdapter的初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.collectionView = [[UICollectionView alloc]initWithFrame:CGRectZero collectionViewLayout:[[UICollectionViewFlowLayout alloc]init]];</span><br><span class="line">self.collectionView.backgroundColor = [UIColor whiteColor];</span><br><span class="line">IGListAdapterUpdater*updater = [[IGListAdapterUpdater alloc]init];</span><br><span class="line">self.**adapter** = [[IGListAdapter alloc]initWithUpdater:updater viewController:self workingRangeSize:0];</span><br><span class="line">self.adapter.collectionView = self.collectionView;</span><br><span class="line">self.adapter.dataSource = self;</span><br><span class="line">[self.view addSubview:self.collectionView];</span><br></pre></td></tr></table></figure>
<h5 id="2、实现IGListAdapter的协议"><a href="#2、实现IGListAdapter的协议" class="headerlink" title="2、实现IGListAdapter的协议"></a>2、实现IGListAdapter的协议</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIView *)**emptyViewForListAdapter**:(nonnull IGListAdapter *)listAdapter &#123;</span><br><span class="line"> //没有数据时候的View</span><br><span class="line">    UILabel *label=[UILabel new];</span><br><span class="line">    label.text=@&quot;没有数据&quot;;</span><br><span class="line">    label.textAlignment=NSTextAlignmentCenter;</span><br><span class="line">    return label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull IGListSectionController *)listAdapter:(nonnull IGListAdapter *)**listAdapter** **sectionControllerForObject**:(nonnull id)object &#123;</span><br><span class="line">    DemoSectionController *sectionController=[[DemoSectionController alloc]init];</span><br><span class="line">    return section;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull NSArray&lt;id&lt;IGListDiffable&gt;&gt; *)**objectsForListAdapter**:(nonnull IGListAdapter *)listAdapter &#123;</span><br><span class="line">    //数据源</span><br><span class="line">    return  self.dataArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、IGListSectionController的方法"><a href="#3、IGListSectionController的方法" class="headerlink" title="3、IGListSectionController的方法"></a>3、IGListSectionController的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)**numberOfItems**&#123;</span><br><span class="line">   //每个section返回多少行根据数据来写</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGSize)**sizeForItemAtIndex**:(NSInteger)index&#123;</span><br><span class="line">    return  CGSizeMake(self.collectionContext.containerSize.width, 64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UICollectionViewCell *)**cellForItemAtIndex**:(NSInteger)index&#123;    </span><br><span class="line">    DemoCollectionViewCell*cell=[self.collectionContext dequeueReusableCellOfClass:[DemoCollectionViewCell class] forSectionController:self atIndex:index];</span><br><span class="line">    [cell setModel:_object row:index];</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)**didSelectItemAtIndex**:(NSInteger)index &#123;</span><br><span class="line">    NSLog(@&quot;点击Section%ld  row%ld&quot;,(long)self.section,(long)index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)**didUpdateToObject**:(id)object&#123;</span><br><span class="line">    //数据传输到这里</span><br><span class="line">    _object =(DemoModel *)object;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、自定义model实现IGListDiffable协议"><a href="#4、自定义model实现IGListDiffable协议" class="headerlink" title="4、自定义model实现IGListDiffable协议"></a>4、自定义model实现IGListDiffable协议</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">- (nonnull id&lt;NSObject&gt;)diffIdentifier &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqualToDiffableObject:(nullable id&lt;IGListDiffable&gt;)object &#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else if (self == nil || object == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、Diffing算法"><a href="#三、Diffing算法" class="headerlink" title="三、Diffing算法"></a>三、Diffing算法</h4><h5 id="1、算法流程描述"><a href="#1、算法流程描述" class="headerlink" title="1、算法流程描述"></a>1、算法流程描述</h5><p>计算collectionView前后数据变化增删改移关系的算法，算法主要过程是：</p>
<p>输入：前后变化的数据数组，新的数据数组为newArray，旧的数据数组为oldArray，newArray和oldArray中的model都实现了IGListDiffable协议</p>
<p>1、首先创建一个hash表(unordered_map) <strong>table</strong></p>
<p>2、先遍历newArray，每个model对应生成<strong>IGListEntry</strong>对象，并根据model的</p>
<p><strong>diffIdentifier</strong>返回值作为key存入table，使得 newCount++，同时计入 newResultsArray</p>
<p>3、再遍历oldArray，根据每个model的<strong>diffIdentifier</strong>返回值作为key，从table中找到对应的<strong>IGListEntry</strong>对象，没有就生成并存入table，使得oldCount++，同时将当前序号入栈 oldIndexes.push(i)，并记录<strong>oldResultsArray</strong></p>
<p>4、遍历 <strong>newResultsArray</strong>，检查 entry 对应的 oldIndexes 信息，如果堆栈中有<strong>旧队列序号值</strong>，则表示当前 entry 至少对应新旧队列中的两个对象，即发生所谓的 <strong>entry match</strong>，进行记录，方便后续反向查询。再通过检查 新队列当前对象 和 entry 对应旧对象 是否相同确认 update 状态。</p>
<ul>
<li><p>再次遍历新旧 entry list，检查每个 entry 的 entry match 状态</p>
</li>
<li><p>没有 entry match 的对象，在新队列中的被标记为 insert<strong>，</strong>而在旧队列中的则被标示为 delete</p>
</li>
<li>有 entry match 的对象**通过比较新旧队列序号和 update 状态分表表示为 update，move和 not modified</li>
</ul>
<h5 id="2、算法示例"><a href="#2、算法示例" class="headerlink" title="2、算法示例"></a>2、算法示例</h5><p><strong>1）</strong>以旧数组 [1,2,3] 和新数组 [1,3,5] 为例 （数字比较直接忽略 update 状态）</p>
<ul>
<li><p>- 遍历新数组，得到 <strong>[entry1,entry3,entry5]</strong> 列表，记为 newResultsArray</p>
</li>
<li><p>- 遍历旧数组，得到 <strong>[entry1,entry2,entry3]</strong> 列表，记为 oldResultsArray</p>
</li>
</ul>
<p><strong>2)</strong>  遍历<strong>newResultsArray</strong>，由于 entry1 oldIndexs = [0]，entry3 oldIndexes = [2] 所以他们是 entry match，做记录 （reverse lookup）</p>
<p><strong>3)</strong> 遍历 <strong>oldResultsArray</strong></p>
<ul>
<li><p>entry1 有 entry match，跳过</p>
</li>
<li><p>entry2 没有 entry match，记为 delete</p>
</li>
<li><p>entry3 有 entry match，跳过</p>
</li>
</ul>
<p><strong>4)</strong> 遍历 <strong>newResultsArray</strong></p>
<ul>
<li><p>entry1 有 entry match，同时相对位置不变，记为 not modified (其实就是跳过)</p>
</li>
<li><p>entry3 有 entry match，但是相对位置变化，记为 <strong>move</strong></p>
</li>
<li><p>entry5 没有 entry match，记为 <strong>insert</strong></p>
</li>
</ul>
<p><strong>5)</strong> 输出一个包含 insert，move，delete 和 update 列表信息的最终结果</p>
<p><strong>参考</strong> <a href="https://xiangwangfeng.com/2017/03/16/IGListKit-diff-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">IGListKit diff 实现简析</a>、<a href="https://instagram.github.io/IGListKit/index.html" target="_blank" rel="noopener">IGListKit Reference</a> 、<a href="http://blog.danthought.com/programming/2018/06/22/iglistkit/" target="_blank" rel="noopener">IGListKit</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/02/06/iOS-iOSRuntime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/iOS-iOSRuntime/" itemprop="url">iOS Runtime 小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T22:53:28+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,843 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Objective-C利用Runtime库(底层的 C 语言 API)赋予了语言的动态特性。</p>
<h4 id="一、Runtime基石：Objective-C对象模型"><a href="#一、Runtime基石：Objective-C对象模型" class="headerlink" title="一、Runtime基石：Objective-C对象模型"></a>一、Runtime基石：Objective-C对象模型</h4><h5 id="1、对象"><a href="#1、对象" class="headerlink" title="1、对象"></a>1、对象</h5><ul>
<li><p>每一个对象都是<strong>类的实例</strong>, 类中保存<strong>对象的方法列表</strong>；当一个对象方法被调用时，类会首先查找它本身是否有该方法的实现，如果没有，则会向它的父类查找该方法，直到NSObject(根类)；</p>
</li>
<li><p>类是<strong>元类 (metaclass) 的实例</strong>；元类保存<strong>类方法列表</strong>；当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则会向它的父类查找该方法，直到NSObject(根类)；</p>
</li>
</ul>
<h5 id="2、isa指针"><a href="#2、isa指针" class="headerlink" title="2、isa指针"></a>2、isa指针</h5><ul>
<li><p>对象的<strong>isa指针</strong>指向所属的类，类的<strong>isa指针</strong>指向所属的元类；所有的元类的 <strong>isa指针</strong>都会指向一个根元类 (root metaclass)。根元类的 <strong>isa指针</strong>指向自己，行成了一个闭环。</p>
</li>
<li><p>在64 位 CPU 下，isa 的内部结构有变化。具体查看用<a href="http://ios.jobbole.com/89485/" target="_blank" rel="noopener"> isa 承载对象的类信息</a></p>
</li>
<li><p>对象、isa指针、类、元类、根元类的关系如下图：</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/201701-fa143a7c6b17b43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="OC类图.png"></p>
<h5 id="3、对象布局"><a href="#3、对象布局" class="headerlink" title="3、对象布局"></a>3、对象布局</h5><ul>
<li>实例变量（包括父类）都保存在对象本身的存储空间内；实例方法保存在<strong>类</strong>中，类方法保存在<strong>元类</strong>中；父类的实例方法保存在各级 super class 中，父类的类方法保存在各级 super meta class;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//对象组成 --start--</span><br><span class="line">   	isa pointer</span><br><span class="line">   	rootClass&apos;s vars</span><br><span class="line">   	penultimate superClass&apos;s vars</span><br><span class="line">   	...</span><br><span class="line">   	superClass&apos;s vars</span><br><span class="line">   	Class&apos;s vars</span><br><span class="line">   	//对象组成 --end--</span><br><span class="line"></span><br><span class="line">   	typedef struct objc_class *Class;</span><br><span class="line">    	//类的结构</span><br><span class="line">    	struct objc_class&#123;</span><br><span class="line">     	struct objc_class* isa;                              //指向元类</span><br><span class="line">     	struct objc_class* super_class;                //指向父类</span><br><span class="line">     	const char* name;</span><br><span class="line">     	long version;</span><br><span class="line">     	long info;</span><br><span class="line">     	long instance_size;</span><br><span class="line">     	struct objc_ivar_list* ivars;                         //实例变量列表</span><br><span class="line">     	struct objc_method_list** methodLists;      //方法列表</span><br><span class="line">     	struct objc_cache* cache;</span><br><span class="line">     	struct objc_protocol_list* protocols;           //协议列表</span><br><span class="line">   	&#125;;</span><br><span class="line"></span><br><span class="line">   	//实例变量的结构</span><br><span class="line">   	struct objc_ivar &#123;</span><br><span class="line">       	char *ivar_name  OBJC2_UNAVAILABLE;</span><br><span class="line">       	char *ivar_type  OBJC2_UNAVAILABLE;</span><br><span class="line">       	int ivar_offset  OBJC2_UNAVAILABLE;</span><br><span class="line">    # ifdef __LP64__</span><br><span class="line">	   int space        OBJC2_UNAVAILABLE;</span><br><span class="line">    # endif</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明1</strong>：对象中保存指向类的<code>isa</code>指针 以及 各级的 实例变量(<code>ivar</code>)，这个内存结构在编译时就确定下来了，不能在编译时给对象增加实例变量。</p>
<p><strong>说明2</strong>：类的内存布局有<code>isa</code>指针、<code>super_class</code>指针、实例变量列表、方法列表和协议列表，其中实例变量(var)包含了变量的名称、类型、偏移等。</p>
<h5 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h5><ul>
<li><strong>Runtime</strong> 就是<strong>动态库</strong>(运行时库)的一部分。比如 C 语言中 glibc 动态链接库通常会被很多操作依赖，包括字符串处理(strlen、strcpy)、信号处理、socket、线程、IO、动态内存分配等等。由于每个程序都依赖于运行时库，这些库一般都是动态链接的。这样一来，运行时库可以存储在操作系统中，很多程序共享一个动态库，这样就可以节省内存占用空间和应用程序大小。</li>
<li>链接一般分为静态链接和动态链接；一般说的预编译、编译、汇编、链接，其中的链接是指静态链接。所谓的动态链接是指: 链接过程被推迟到运行时再进行。</li>
</ul>
<h4 id="二、Runtime核心：消息发送和转发"><a href="#二、Runtime核心：消息发送和转发" class="headerlink" title="二、Runtime核心：消息发送和转发"></a>二、Runtime核心：消息发送和转发</h4><p><strong>Runtime</strong>赋予了OC了诸多动态特性，使其可以在运行时可以做一些事情；主要表现为：<strong>动态类型</strong>（在运行时才检查对象类型）和 <strong>动态绑定</strong>（接到消息后，由运行环境决定执行哪部分代码）</p>
<h5 id="1、消息发送（Message）"><a href="#1、消息发送（Message）" class="headerlink" title="1、消息发送（Message）"></a>1、消息发送（Message）</h5><ul>
<li><p>Objective-C 中的方法调用，实质上是在底层用objc_msgSend()实现<strong>消息发送</strong>，其核心在于：<strong>根据SEL(选择器)开始找到IMP</strong>；其中SEL是实例方法的指针，可以看做方法名字符串；IMP是函数指针，指向方法实现的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//调用方法  </span><br><span class="line">[obj doSomething];</span><br><span class="line">//在编译时候转换</span><br><span class="line">objc_msgSend(obj,@selector(doSomething))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>objc_msgSend</strong>的定义如下：</p>
<pre><code>// self是接收者，接收该消息的类的实例
// _cmd是选择器，要处理的消息的selector
// ... 是需传入的参数，参数个数不定
objc_msgSend(id self, SEL _cmd, ...) 
</code></pre></li>
<li><p><strong>objc_msgSend的发送流程</strong>：先在Class中的<strong>缓存</strong>查找imp（没缓存则初始化缓存），如果没找到，在类的方法列表中查找，如果还没有，则向Class的父类的方法列表中查找，如果还没有找到，继续向上查找，直至根类，如果还没有找到对应的IMP，就走消息转发(_objc_msgForward)了。</p>
</li>
<li><p>给nil发送消息不会有什么作用，但是返回值有些区别，具体如下：</p>
<pre><code>a) 如果方法返回值是 对象，返回nil
b) 如果方法返回值是 指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量
c) 如果方法返回值是 结构体，发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。
d) 如果方法返回值不是 上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。
</code></pre></li>
</ul>
<h5 id="2、消息转发（Message-Forwarding）"><a href="#2、消息转发（Message-Forwarding）" class="headerlink" title="2、消息转发（Message Forwarding）"></a>2、消息转发（Message Forwarding）</h5><p>消息转发解决的是：查找IMP(方法实现)失败后的处理；经历<strong>动态方法解析</strong>、 <strong>备用接收者</strong>和 <strong>完整的消息转发</strong>三个过程，其流程如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/201701-35938988b21e8a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发流程.png"></p>
<ul>
<li><p><strong>动态方法解析</strong>：接收到未知消息时，Runtime向当前类发送+resolveInstanceMethod:或+resolveClassMethod:消息，在这里可以<strong>添加缺失的方法</strong>，返回YES，重新发送消息，否则继续下一步；</p>
</li>
<li><p><strong>备用接收者</strong>：<strong>动态方法解析</strong>中没能处理，Runtime会向forwardingTargetForSelector:发消息，如果该方法返回了一个非nil或非self对象，恰好该对象实现了这个方法，那么该对象就成了消息的接收者，消息就被分发到该对象。</p>
</li>
<li><p><strong>完整消息转发</strong>：前两个都没能处理好，Runtime发送methodSignatureForSelector:消息，获取selector对应方法的签名；如果有方法签名返回，则根据方法签名创建描述消息的NSInvocation，向当前对象发送forwardInvocation:消息；如果没有方法签名返回，返回nil，向当前对象发送doesNotRecognizeSelector:消息，应用Crash退出。</p>
</li>
</ul>
<h5 id="3、避免消息转发的办法"><a href="#3、避免消息转发的办法" class="headerlink" title="3、避免消息转发的办法"></a>3、避免消息转发的办法</h5><p><strong>在消息转发三个过程中，未知消息的处理过程越往后，代价越大</strong>；一般我们可以这么做 尽可能避免消息转发，可以这么做：</p>
<ul>
<li><p><strong>调用delegate 方法前检查方法是否实现</strong>(respondsToSelector:), 只有实现了(respondsToSelector:返回YES) ，才去真正调用delegate 方法。</p>
<pre><code>if([self.delegate respondsToSelector: @selector(sayHello)]) {
   [self.delegate sayHello];
}
</code></pre></li>
<li><p><strong>直接调用方法，少用performSelector:</strong>；因为在直接调用方法时，编译自动校验，如果方法不存在，编译器会直接报错；而使用performSelector:的话一定是在运行时候才能发现，如果此方法不存在就会崩溃。</p>
<pre><code>//直接使用方法调用,少使用performSelector
[dog sayHello];
// [dog performSelector:@selector(sayHello) withObject:nil];
</code></pre></li>
<li><p><strong>使用performSelector:，最好先判断方法是否实现(respondsToSelector:)</strong>，只有实现了(respondsToSelector:返回YES) ，才去调用performSelector：方法。</p>
<pre><code>//respondsToSelector:和performSelector:组合使用
      if ([dog respondsToSelector:@selector(sayHello)])         {
      [dog performSelector:@selector(sayHello)];
   }
</code></pre></li>
<li><p><strong>强制类型转换，先判断对象是否属于强制转换后的类</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if([data isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line">   //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4、super本质"><a href="#4、super本质" class="headerlink" title="4、super本质"></a>4、super本质</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Cat</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[self class]);      //Cat</span><br><span class="line">        NSLog(@&quot;%@&quot;,[self superclass]); //Animal</span><br><span class="line">        NSLog(@&quot;%@&quot;,[super class]);     //Cat</span><br><span class="line">        NSLog(@&quot;%@&quot;,[super superclass]);//Animal</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;@end</span><br></pre></td></tr></table></figure>
<ul>
<li>super 调用底层会转换为<strong>objc_msgSendSuper</strong>函数的调用，objc_msgSendSuper 函数接收 2 个参数 <strong>objc_super</strong> 结构体和 <strong>SEL</strong> ，objc_super结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">    __unsafe_unretained _Nonnull id receiver; // 消息接收者</span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class; // 消息接收者的父类</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>[super class] 在调用过程中，底层转化为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper(&#123;self, [Animal class]&#125;, @selector(class));</span><br></pre></td></tr></table></figure>
</li>
<li><p>同 objc_msgSend 函数相比，多了第二个参数，但<strong>消息接收仍然是 self</strong> ，所以打印结果为 Cat。</p>
</li>
<li><p>objc_msgSendSuper 方法中的第二个参数主要作用是告诉从哪里开始搜索方法实现，一般传入的是父类。这也是实际开发中 [super superClassMethod] 直接调用父类方法的原因。</p>
</li>
</ul>
<h4 id="三、Runtime特性和应用"><a href="#三、Runtime特性和应用" class="headerlink" title="三、Runtime特性和应用"></a>三、Runtime特性和应用</h4><h5 id="1、分类（Category）"><a href="#1、分类（Category）" class="headerlink" title="1、分类（Category）"></a>1、分类（Category）</h5><ul>
<li><p><strong>原理</strong>：对象的<strong>方法</strong>定义都保存在类的可变区域中，修改methodLists指针指向的指针的值，就可以实现动态地为某一个类增加<strong>成员方法</strong>。(<em>但是对象布局在编译时候就固定了，结构体的大小并不能动态变化，在运行时不能增加实例变量</em>)。</p>
</li>
<li><p>通过关联<code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code>方法可以变相地给对象增加实例变量，并不会真正改变了对象的内存结构。</p>
</li>
<li><p>通过Category新增的方法，会插入到方法列表的前部；如果有和原来方法重名，在运行时，顺序查找时，一旦找到对应名字的方法，就不再查找，导致<strong>原来方法</strong>得不到机会，<em>这是Category新增的方法和原方法重名，原有方法失效的原因</em>。</p>
</li>
<li><p><strong>作用</strong>：给现有的类添加方法；将一个类的实现拆分成多个独立的源文件；声明私有的方法。</p>
</li>
</ul>
<h5 id="2、关联对象（Associated-Objects）"><a href="#2、关联对象（Associated-Objects）" class="headerlink" title="2、关联对象（Associated Objects）"></a>2、关联对象（Associated Objects）</h5><ul>
<li><p><strong>原理</strong>：Category不能给一个已有类添加实例变量，但是可以通过<strong>关联对象</strong>添加属性；但是关联对象不会改变对象的内存布局，新增的属性是添加到和对象地址关联的哈希表中；</p>
</li>
<li><p>Associated Objects 相关的三个方法</p>
<pre><code>objc_setAssociatedObject    //添加关联对象
objc_getAssociatedObject    //获取关联对象
objc_removeAssociatedObjects  // 删除所有关联对象
</code></pre></li>
<li><p><strong>作用</strong>：为现有的类添加私有变量以帮助实现细节；为现有的类添加公有属性；为 KVO 创建一个关联的观察者</p>
<p>具体参考：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">Objective-C Associated Objects 的实现原理</a></p>
</li>
</ul>
<h5 id="3、方法混写-Method-Swizzling"><a href="#3、方法混写-Method-Swizzling" class="headerlink" title="3、方法混写(Method Swizzling)"></a>3、方法混写(Method Swizzling)</h5><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，<strong>查找消息的唯一依据是selector的名字</strong>。利用Objective-C的动态特性，<strong>可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</strong> </p>
<p>每个类都有一个方法列表，存放着<strong>selector的名字</strong>和<strong>方法实现</strong>的映射关系。IMP有点类似函数指针，指向具体的Method实现。</p>
<ul>
<li><strong>原理</strong>：在运行时交换方法实现（IMP）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用 method_exchangeImplementations 来交换2个方法中的IMP，</span><br><span class="line">利用 class_replaceMethod 来修改类，</span><br><span class="line">利用 method_setImplementation 来直接设置某个方法的IMP，</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：可以利用它hook原有的方法，插入自己的业务需求</li>
</ul>
<p>详细参考我写的<a href="https://www.jianshu.com/p/5f2e38a40aa4" target="_blank" rel="noopener">Method Swizzling小记</a></p>
<h5 id="4、键值观察（KVO）"><a href="#4、键值观察（KVO）" class="headerlink" title="4、键值观察（KVO）"></a>4、键值观察（KVO）</h5><p>  观察者模式在Objective-C的应用之一，借助Runtime特性，实现自动键值观察；使用了isa swizzling机制。具体描述如下：</p>
<ul>
<li>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个<strong>子类</strong>，在这个子类中<strong>重写</strong>基类中被观察属性的 setter 方法，实现真正的通知机制；</li>
<li>派生类还重写了 class 方法以“欺骗”外部调用者，系统将对象的 isa 指针指向这个<strong>新诞生的子类</strong>，实质上这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。</li>
<li>此外，派生类还重写了 dealloc 方法来释放资源。</li>
</ul>
<p><strong>说明</strong>：KVC（键值编码）是不通过存取方法，而通过属性名称字符串间接访问属性的机制，没有用到isa swizzling机制。</p>
<h5 id="5、NSProxy"><a href="#5、NSProxy" class="headerlink" title="5、NSProxy"></a>5、NSProxy</h5><ul>
<li><p>OC是单继承的，但是可以利用NSProxy实现一下<strong>“伪多继承”</strong>，具体参考<a href="">NSProxy——少见却神奇的类</a></p>
</li>
<li><p>项目中，主要是利用NSProxy做<strong>消息转发的代理类</strong>，如弱引用代理类，可以打破循环引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//代码摘自 FLAnimatedImage</span><br><span class="line">@interface FLWeakProxy : NSProxy</span><br><span class="line">- (instancetype)weakProxyForObject:(id)targetObject;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface FLWeakProxy ()</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@end</span><br><span class="line">	</span><br><span class="line">@implementation FLWeakProxy</span><br><span class="line">	</span><br><span class="line"># pragma mark Life Cycle</span><br><span class="line"></span><br><span class="line">//类没有定义默认的init方法.</span><br><span class="line">- (instancetype)weakProxyForObject:(id)targetObject&#123;</span><br><span class="line">	FLWeakProxy *weakProxy = [FLWeakProxy alloc];</span><br><span class="line">   	weakProxy.target = targetObject;</span><br><span class="line">   	return weakProxy;</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"># pragma mark Forwarding Messages</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)selector&#123;</span><br><span class="line">  // Keep it lightweight: access the ivar directly</span><br><span class="line">  	return _target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</span><br><span class="line"> 	 void *nullPointer = NULL;</span><br><span class="line">  	 [invocation setReturnValue:&amp;nullPointer];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector&#123;</span><br><span class="line"> 	 return [NSObject instanceMethodSignatureForSelector:@selector(init)];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: NSProxy非常适合做消息转发的代理类，能自动转发<nsobject>中定义的接口和NSObject的Category中定义的方法，如果使用NSObject来做，不能自动转发NSObject的Category中定义、respondsToSelector:、isKindOfClass:这两个方法。·</nsobject></p>
</li>
</ul>
<h5 id="6、load和initialize"><a href="#6、load和initialize" class="headerlink" title="6、load和initialize"></a>6、load和initialize</h5><ul>
<li>在Objective-C中，runtime会自动调用每个类的两个方法。+load会在<strong>类初始加载时</strong>调用，+initialize会在<strong>第一次调用类的类方法或实例方法之前</strong>被调用。</li>
<li>这两个方法是可选的，且只有在实现了它们时才会被调用。 </li>
<li><strong>共同点：两个方法都只会被调用一次。</strong></li>
</ul>
<h4 id="四、KVO补充"><a href="#四、KVO补充" class="headerlink" title="四、KVO补充"></a>四、KVO补充</h4><h5 id="1、KVO的使用"><a href="#1、KVO的使用" class="headerlink" title="1、KVO的使用"></a>1、KVO的使用</h5><ul>
<li><code>KVO</code>如果使用不当很容易崩溃，如：<code>Observer</code>被重复<code>remove</code>，或者没有及时移除（KVO crash notifying deallocated observer），<code>keyPath</code>传错都会导致崩溃。</li>
<li>在调用<code>KVO</code>时需要传入一个<code>keyPath</code>，由于<code>keyPath</code>是字符串的形式，所以其对应的属性发生改变后，字符串没有改变容易导致<code>Crash</code>。我们可以利用系统的反射机制将<code>keyPath</code>反射出来，这样编译器可以在<code>@selector()</code>中进行合法性检查。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSStringFromSelector(@selector(isFinished))</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>KVO</code>是一种事件绑定机制的实现，在<code>keyPath</code>对应的值发生改变后会回调对应的方法。这种数据绑定机制，在对象关系很复杂的情况下，很容易导致不好排查的<code>bug</code>。例如<code>keyPath</code>对应的属性被调用的关系很复杂，就不太建议对这个属性进行<code>KVO</code>，可以想一下<code>RAC</code>的信号脑补一下。</p>
</li>
<li><p>如果项目中要使用KVO，建议使用Facebook的<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a>，</p>
</li>
</ul>
<h5 id="2、KVOController"><a href="#2、KVOController" class="headerlink" title="2、KVOController"></a>2、KVOController</h5><ul>
<li><p><strong>本质</strong>：对系统<code>KVO</code>的封装，具有原生<code>KVO</code>所有的功能，而且规避了原生<code>KVO</code>的很多问题，兼容<code>block</code>和<code>action</code>两种回调方式。</p>
</li>
<li><p><strong>特点</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不需要手动移除观察者；框架自动帮我们移除观察者</span><br><span class="line">使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；**block或者selector的方式，方便使用</span><br><span class="line">每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；**一个keyPath对应一个SEL或者block，不需要统一的observeValueForKeyPath方法里写if判断</span><br></pre></td></tr></table></figure>
<h5 id="3、-参考"><a href="#3、-参考" class="headerlink" title="3、 参考"></a>3、 参考</h5><p><a href="https://segmentfault.com/a/1190000013813643" target="_blank" rel="noopener">KVO原理分析及使用进阶</a></p>
<h4 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h4><h5 id="1、Swift的动态性"><a href="#1、Swift的动态性" class="headerlink" title="1、Swift的动态性"></a>1、Swift的动态性</h5><ul>
<li>纯 Swift 类没有动态性，但在方法、属性前添加 dynamic 修饰可以获得动态性。  </li>
<li>继承自 NSObject 的 Swift 类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加 dynamic 修饰才可以获得动态性。  </li>
<li>若方法的参数、属性类型为 Swift 特有、无法映射到 Objective-C 的类型 (如 Character、Tuple)，则此方法、属性无法添加 dynamic 修饰（会编译错误）  </li>
<li>Swift 类在 Objective-C 中会有模块前缀</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="南华coder" />
            
              <p class="site-author-name" itemprop="name">南华coder</p>
              <p class="site-description motion-element" itemprop="description">天之道，损有余而补不足</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南华coder</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">65.1k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
