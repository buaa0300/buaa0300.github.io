<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="南华coder的空间" type="application/atom+xml" />






<meta name="description" content="于无声处听惊雷,于无色处见繁花">
<meta property="og:type" content="website">
<meta property="og:title" content="南华coder的空间">
<meta property="og:url" content="http://buaa0300/nanhuacoder.com/page/3/index.html">
<meta property="og:site_name" content="南华coder的空间">
<meta property="og:description" content="于无声处听惊雷,于无色处见繁花">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南华coder的空间">
<meta name="twitter:description" content="于无声处听惊雷,于无色处见繁花">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://buaa0300/nanhuacoder.com/page/3/"/>





  <title>南华coder的空间</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">南华coder的空间</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/02/28/iOS-iOSJavaScriptCore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/iOS-iOSJavaScriptCore/" itemprop="url">JavaScriptCore小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T00:07:41+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,587 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、JavaScriptCore核心类和协议"><a href="#一、JavaScriptCore核心类和协议" class="headerlink" title="一、JavaScriptCore核心类和协议"></a>一、JavaScriptCore核心类和协议</h4><ul>
<li><p>JavaScriptCore给iOS开发的第一反应是<strong>实现原生应用和Web应用之间通信</strong></p>
</li>
<li><p>实际上，JavaScriptCore是iOS 7推出的<strong>JavaScript引擎</strong>，是为了实现OC和JS通信，使用场景不局限于在原生应用和Web应用间使用(<em>虽然这是大部分场景</em>)。</p>
</li>
</ul>
<h5 id="1、-JSContext"><a href="#1、-JSContext" class="headerlink" title="1、 JSContext"></a>1、 JSContext</h5><ul>
<li><strong>JavaScript运行的上下文环境</strong>，使用JSContext对象来执行JavaScript代码，所有的JSValue对象都由JSContext对象管理。</li>
</ul>
<h5 id="2、JSValue"><a href="#2、JSValue" class="headerlink" title="2、JSValue"></a>2、JSValue</h5><ul>
<li><p><strong>代表一个JavaScript实体</strong>，不仅可以表示JavaScript原始类型数据如boolean、Number、String等，还可以表示对象和函数。OC和JS对象之间的转换如下表：</p>
<p> |Objective-C type  |   JavaScript type|</p>
<pre><code>|--|--|
|nil | undefined|
|NSNull       |        null|
|NSString      |       string|
|NSNumber      |   number, boolean|
|NSDictionary    |   Object object|
|NSArray       |    Array object|
|NSDate       |     Date object|
|NSBlock   |   Function object |
|id     |   Wrapper object |
|Class | Constructor object|
</code></pre></li>
</ul>
<h5 id="3、-JSManagedValue"><a href="#3、-JSManagedValue" class="headerlink" title="3、 JSManagedValue"></a>3、 JSManagedValue</h5><ul>
<li>本质是<strong>弱引用的JSValue对象</strong>，可以处理内存管理中的一些特殊情形，它能帮助引用技术和垃圾回收这两种内存管理机制之间进行正确的转换。如代替JSValue对象被OC对象持有避免发生循环引用(<em>本文后面会讲解</em>)。</li>
</ul>
<h5 id="4、JSVirtualMachine"><a href="#4、JSVirtualMachine" class="headerlink" title="4、JSVirtualMachine"></a>4、JSVirtualMachine</h5><ul>
<li><strong>JavaScript运行的虚拟机</strong>，拥有自己的堆结构和垃圾回收机制。大部分情况下不需要和它直接交互，除非要处理一些特殊的多线程或者内存管理问题。</li>
</ul>
<h5 id="5、JSExport"><a href="#5、JSExport" class="headerlink" title="5、JSExport"></a>5、JSExport</h5><ul>
<li><p><strong>将OC对象直接转成JS对象的协议</strong>，可以将OC类的属性或方法转换为JS的属性或方法。使用时，继承JSExport定义自己的协议，然后在自己的协议中定义暴露给JavaScript的方法；</p>
</li>
<li><p><strong>方法由Objective-C中的类实现</strong>；JavaScriptCore将实现类的对象注入JSContext运行环境中，使用注入的名称调用JS方法就会自动调用这个对象对应的OC方法。</p>
</li>
</ul>
<h4 id="二、Objective-C调用JavaScript代码"><a href="#二、Objective-C调用JavaScript代码" class="headerlink" title="二、Objective-C调用JavaScript代码"></a>二、Objective-C调用JavaScript代码</h4><h5 id="1、Objective-C直接执行JavaScript代码"><a href="#1、Objective-C直接执行JavaScript代码" class="headerlink" title="1、Objective-C直接执行JavaScript代码"></a>1、Objective-C直接执行JavaScript代码</h5><p><strong>1）JSContext</strong>为JavaScript提供运行的上下文环境，执行JavaScript代码前必须先创建JSContext对象，创建JSContext对象之后，才可以调用JSContext的evaluateScript:方法可以执行JavaScript代码了，如创建变量，做计算，定义方法等。</p>
<p><strong>2）JSContext</strong>的创建都是基于<strong>JSVirtualMachine</strong>(<em>JSVirtualMachine为JavaScript的运行提供了底层资源</em>)，默认使用init进行初始化，在其内部会自动创建一个新的JSVirtualMachine对象，然后根据JSVirtualMachine对象初始化JSContext对象。</p>
<p><strong>3）JSContext的evaluateScript:方法的返回值类型是JSValue</strong>， JSValue 封装了每一个可能的 JavaScript 值，如字符串和数字、数组、对象、方法、甚至错误和特殊的 JavaScript 值诸如 null 和 undefined等。对JSValue调用toString、toBool、toDouble、toArray等等方法把它转换成合适的Objective-C值或对象。</p>
<p><strong>4） 示例代码如下</strong>。XCode控制台输出12，是调用add(5,7)代码执行后的结果值。</p>
<pre><code>- (void)ocCallJsCode{

    JSContext *context = [[JSContext alloc]init];
    [context evaluateScript:@&quot;var a = 5,b = 7&quot;];
    [context evaluateScript:@&quot;function add(a,b){return a+b}&quot;];
    JSValue *addValue = [context evaluateScript:@&quot;add(5,7)&quot;];
    NSLog(@&quot;addValue = %d&quot;,addValue.toInt32);    
}
</code></pre><h5 id="2、Objective-C执行JavaScript代码文件"><a href="#2、Objective-C执行JavaScript代码文件" class="headerlink" title="2、Objective-C执行JavaScript代码文件"></a>2、Objective-C执行JavaScript代码文件</h5><p>首先初始化了一个JSContext对象，然后执行JavaScript文件中的代码，最后从JSContext对象中取出JS函数，使用callWithArguments:调用JS函数，参数是一个数组，如果没有参数则传入空数组@[]</p>
<p><strong>1）在项目中新建一个occalljs.js的文件，定义了加减乘除四个JS函数，代码如下：</strong></p>
<pre><code>function add(a,b){
    return a + b
}

function sub(a,b){
    return a - b
}

function mul(a,b){
    return a * b
}

function div(a,b){
    return a / b
}
</code></pre><p><strong>2） OC代码中执行JS代码文件</strong></p>
<pre><code>- (void)ocCallJsCodeInFile{

    JSContext *context = [[JSContext alloc]init];
    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;calculate&quot; ofType:@&quot;js&quot;];
    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];
    [context evaluateScript:jsContent];

    JSValue *addValue = [context[@&quot;add&quot;] callWithArguments:@[@5,@7]];
    NSLog(@&quot;5 + 7 = %d&quot;,addValue.toInt32);

    JSValue *subValue = [context[@&quot;sub&quot;] callWithArguments:@[@5,@7]];
    NSLog(@&quot;5 - 7 = %d&quot;,subValue.toInt32);

    JSValue *mulValue = [context[@&quot;mul&quot;] callWithArguments:@[@5,@7]];
    NSLog(@&quot;5 * 7 = %d&quot;,mulValue.toInt32);

    JSValue *divValue = [context[@&quot;div&quot;] callWithArguments:@[@5,@7.0]];
    NSLog(@&quot;5 / 7 = %.2lf&quot;,divValue.toDouble);
}
</code></pre><p><strong>总结：</strong>通过JSContext和JSValue的配合使用，实现了Objective-C执行JavaScript代码。</p>
<h4 id="三、JavaScript调用Objective-C代码"><a href="#三、JavaScript调用Objective-C代码" class="headerlink" title="三、JavaScript调用Objective-C代码"></a>三、JavaScript调用Objective-C代码</h4><p>可以使用两种方式实现JavaScript调用Objective-C代码</p>
<h5 id="方式一：在OC中定义block，使用block代替JS的函数实现"><a href="#方式一：在OC中定义block，使用block代替JS的函数实现" class="headerlink" title="方式一：在OC中定义block，使用block代替JS的函数实现"></a>方式一：在OC中定义<strong>block</strong>，使用block代替JS的函数实现</h5><p>代码如下：</p>
<p><strong>1、新建一个jscalloc1.js的文件，定义了两个方法，代码如下：</strong></p>
<pre><code>function sayHello() {
    print(&quot;你好&quot;);
}

function showAlert() {
    alert(&quot;Alert!!!&quot;);
}
</code></pre><p><strong>2、oc中实现block代替js方法，代码如下：</strong></p>
<pre><code>- (void)jsCalloc1{

    JSContext *context = [[JSContext alloc]init];
    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;jscalloc&quot; ofType:@&quot;js&quot;];
    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];
    [context evaluateScript:jsContent];

    //block替换js中的print方法
    context[@&quot;print&quot;] = ^(NSString *printStr){

        NSLog(@&quot;printStr = %@&quot;,printStr);
    };

    __weak typeof(self) weakSelf = self;
    //block替换js中的alert方法
    context[@&quot;alert&quot;] = ^(NSString *alertStr){
        __strong typeof(weakSelf) strongSelf = weakSelf;
        UIAlertController *vc = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:alertStr preferredStyle:UIAlertControllerStyleAlert];
        [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDestructive handler:nil]];
        [strongSelf presentViewController:vc animated:YES completion:nil];
    };

    //执行
    [context[@&quot;sayHello&quot;] callWithArguments:nil];
    [context[@&quot;showAlert&quot;] callWithArguments:nil];
}
</code></pre><p><strong>说明1</strong>：在代码中，我们将两个Block分别以”print”和“alert”为名传递给JavaScript上下文。在JS中调用print函数或者alert函数，其实就是执行在oc中定义的Block；也就实现了<strong>JavaScript调用Objective-C代码</strong>。</p>
<p><strong>说明2</strong>：JavaScript中的字符串可以无缝的桥接为NSString。</p>
<p><strong>说明3</strong>: 当JavaScript运行时出现异常，会回调JSContext的exceptionHandler中设置的Block，我们通过Block的方式将异常信息打印处理</p>
<pre><code>context.exceptionHandler = ^(JSContext *context, JSValue *exception) {
       NSLog(@&quot;JS Error: %@&quot;, exception);
};
</code></pre><h5 id="方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中"><a href="#方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中" class="headerlink" title="方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中"></a>方式二：继承JSExport协议，定义暴露给JS的方法，将实现协议的类的对象注入到context中</h5><p>代码如下：</p>
<p><strong>1、新建一个jscalloc2.js的文件，定义了两个方法，代码如下：</strong></p>
<pre><code>function sayHello() {
    qsobj.print(&quot;你好&quot;);
}

function showAlert() {
    qsobj.alert(&quot;Alert!!!&quot;);
}
</code></pre><p><strong>2、OC中实现QSExportObject类，将QSExportObject对象qsobj注入到JS执行的上下文环境中，JS中执行qsobj.print和qsobj.alert函数，就是执行OC对象qsobj的方法</strong>，代码如下：</p>
<pre><code> //QSExportObject.h
@protocol QSExport &lt;JSExport&gt;

- (void)print:(NSString *)text;
- (void)alert:(NSString *)text;

//JSExportAs(print,- (void)print:(NSString *)text);
//JSExportAs(alert,- (void)alert:(NSString *)text);
@end

@interface QSExportObject : NSObject&lt;QSExport&gt;
@property (nonatomic,weak)UIViewController *vc;
@end

//QSExportObject.m
@implementation QSExportObject

- (void)print:(NSString *)text{
    NSLog(@&quot;print text = %@&quot;,text);
}

- (void)alert:(NSString *)text{

    UIAlertController *vc = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:text preferredStyle:UIAlertControllerStyleAlert];
    [vc addAction:[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDestructive handler:nil]];
    [self.vc presentViewController:vc animated:YES completion:nil];
}
@end

//在ViewController中调用
 - (void)jsCallOc2{

    JSContext *context = [[JSContext alloc]init];
    NSString *jsFilePath = [[NSBundle mainBundle]pathForResource:@&quot;jscalloc2&quot; ofType:@&quot;js&quot;];
    NSString *jsContent = [NSString stringWithContentsOfFile:jsFilePath encoding:NSUTF8StringEncoding error:nil];
    [context evaluateScript:jsContent];
    //注入qsObj
    QSExportObject *qsObj = [QSExportObject new];
    qsObj.vc = self;
    context[@&quot;qsobj&quot;] = qsObj;

     //执行
    [context[@&quot;sayHello&quot;] callWithArguments:nil];
    [context[@&quot;showAlert&quot;] callWithArguments:nil];
}
</code></pre><p><strong>说明1</strong>：在QSExport中定义暴露给JS的接口，也可以使用宏<strong>JSExportAs</strong>，它将JS函数和OC方法绑定在一起；对于OC中多参数的方法，一般使用<strong>JSExportAs</strong>。</p>
<h4 id="四、循环引问题"><a href="#四、循环引问题" class="headerlink" title="四、循环引问题"></a>四、循环引问题</h4><p><strong>说明</strong>：Objective-C的内存管理机制是<strong>引用计数</strong>，JavaScript的内存管理机制是<strong>垃圾回收</strong>。在大部分情况下，JavaScriptCore能做到在这两种内存管理机制之间无缝无错转换，但是有些情况下会发生循环引用。</p>
<h5 id="1、block直接使用self-context-会发生循环引用"><a href="#1、block直接使用self-context-会发生循环引用" class="headerlink" title="1、block直接使用self.context 会发生循环引用"></a>1、block直接使用self.context 会发生循环引用</h5><p>打破这类循环引用的办法有两种。</p>
<p><strong>1）方法1：weakSelf和strongSelf</strong></p>
<pre><code>[self.context evaluateScript:@&quot;function printAppVersion() { print(getAppVersion())}&quot;];
self.context[@&quot;print&quot;] = ^(NSString *printStr){
    NSLog(@&quot;printStr = %@&quot;,printStr);
};

__weak typeof(self) weakSelf = self;
self.context[@&quot;getAppVersion&quot;] = ^{
    __strong typeof(weakSelf) strongSelf = weakSelf;
    NSString* versionString = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];
    versionString = [@&quot;App Version &quot; stringByAppendingString:versionString];
    JSContext *context = strongSelf.context;
    JSValue *version = [JSValue valueWithObject:versionString inContext:context];
    return version;
};

//执行
[self.context[@&quot;printAppVersion&quot;] callWithArguments:nil];
</code></pre><p><strong>2）方法2：block内使用[JSContext currentContext]代替self.context</strong></p>
<pre><code>[self.context evaluateScript:@&quot;function printAppVersion() { print(getAppVersion())}&quot;];
self.context[@&quot;print&quot;] = ^(NSString *printStr){
    NSLog(@&quot;printStr = %@&quot;,printStr);
};

self.context[@&quot;getAppVersion&quot;] = ^{
    NSString* versionString = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;];
    versionString = [@&quot;App Version &quot; stringByAppendingString:versionString];
    JSContext *context = [JSContext currentContext];
    JSValue *version = [JSValue valueWithObject:versionString inContext:context];
    return version;
};

//执行
[self.context[@&quot;printAppVersion&quot;] callWithArguments:nil];
</code></pre><h5 id="2、block中使用外部定义的JSValue对象不会发生循环引用"><a href="#2、block中使用外部定义的JSValue对象不会发生循环引用" class="headerlink" title="2、block中使用外部定义的JSValue对象不会发生循环引用"></a>2、block中使用外部定义的JSValue对象不会发生循环引用</h5><pre><code>[self.context evaluateScript:@&quot;function log() { }&quot;];
JSValue *value = [JSValue valueWithObject:@&quot;test content&quot; inContext:self.context];

self.context[@&quot;log&quot;] = ^(){
    NSLog(@&quot;%@&quot;,value);
};

[self.context[@&quot;log&quot;] callWithArguments:nil];
</code></pre><p><strong>原因：</strong>在block里面直接使用外部定义的JSValue对象不会发生循环引用。以上诉代码为例，JSContext强引用了一个log函数，log函数中又强引用了JSValue对象，JSValue对象强引用JSContext对象和保存的值，JSContext对象引用它管理的所有JSValue对象，这样JSContext和JSValue看上去是循环引用的，然而并不会，<strong>垃圾回收机制会打破这个循环引用</strong>。</p>
<h5 id="3、OC对象保存JSValue容易引起循环引用"><a href="#3、OC对象保存JSValue容易引起循环引用" class="headerlink" title="3、OC对象保存JSValue容易引起循环引用"></a>3、OC对象保存JSValue容易引起循环引用</h5><p>假设下面这样的场景，定义QSAlertView类，该类中持有successHandler，failureHandler这两个JSValue对象，使用block方式注入JS方法时候</p>
<pre><code>self.context[@&quot;presentNativeAlert&quot;] = ^(NSString *title,
                                        NSString *message,
                                        JSValue *successHandler,
                                        JSValue *failureHandler) {
    JSContext *context = [JSContext currentContext];
    QSAlertView *alertView = [[QSAlertView alloc] initWithTitle:title
                                                        message:message
                                                        successHandler:successHandler
                                                 failureHandler:failureHandler
                                                        context:context];
    [alertView show];
};
</code></pre><p><strong>说明</strong>：因为JavaScript环境中都是“强引用”（相对Objective-C的概念来说）的，这时JSContext强引用了一个presentNativeAlert函数，这个函数中又强引用了QSAlertView，等于说JSContext强引用了QSAlertView，而QSAlertView为了持有两个回调强引用了successHandler和failureHandler这两个JSValue，而JSValue又是强引用JSContext的，循环引用便出现了。</p>
<p><strong>打破该类循环引用的方式是：JSMagagedValue对象代替JSValue对象被OC对象持有</strong></p>
<h4 id="五、JSMagagedValue类使用"><a href="#五、JSMagagedValue类使用" class="headerlink" title="五、JSMagagedValue类使用"></a>五、JSMagagedValue类使用</h4><p><strong>JSMagagedValue类</strong>：弱引用对象，需要调用JSVirtualMachine的addManagedReference:withOwner:把它添加到JSVirtualMachine对象中，确保使用过程中JSValue不会被释放 </p>
<pre><code>//QSAlertView.h
@interface QSAlertView : UIAlertView
- (instancetype)initWithTitle:(NSString *)title
                      message:(NSString *)message
               successHandler:(JSValue *)successHandler
               failureHandler:(JSValue *)failureHandler
                      context:(JSContext *)context;
@end

//QSAlertView.m
@interface QSAlertView() &lt;UIAlertViewDelegate&gt;

@property (nonatomic,strong) JSContext *context;
@property (nonatomic,strong) JSManagedValue *successHandler;
@property (nonatomic,strong) JSManagedValue *failureHandler;

@end

@implementation QSAlertView

- (instancetype)initWithTitle:(NSString *)title
                      message:(NSString *)message
               successHandler:(JSValue *)successHandler
               failureHandler:(JSValue *)failureHandler
                      context:(JSContext *)context{

    self = [super initWithTitle:title message:message delegate:self cancelButtonTitle:@&quot;NO&quot; otherButtonTitles:@&quot;YES&quot;, nil];
    if (self) {
        _context = context;
        _successHandler = [JSManagedValue managedValueWithValue:successHandler];
        _failureHandler = [JSManagedValue managedValueWithValue:failureHandler];

        //添加JSManagedValue对象到JSVirtualMachine对象中，防止使用过程被释放
        [_context.virtualMachine addManagedReference:_successHandler withOwner:self];
        [_context.virtualMachine addManagedReference:_failureHandler withOwner:self];
    }
    return self;
}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{

    NSString *btnTitle = [alertView buttonTitleAtIndex:buttonIndex];
    if ([btnTitle isEqualToString:@&quot;YES&quot;]) {

        JSValue *function = [self.successHandler value];
        [function callWithArguments:@[]];

    }else{
        JSValue *function = [self.failureHandler value];
        [function callWithArguments:@[]];
    }
    //移除JSManagedValue对象
    [self.context.virtualMachine removeManagedReference:_successHandler withOwner:self];
    [self.context.virtualMachine removeManagedReference:_failureHandler withOwner:self];
}
@end
</code></pre><p><strong>说明1</strong>：外部传入的JSValue对象在类内部使用JSManagedValue(弱引用对象)来保存<br><strong>说明2</strong>：JSManagedValue对象因为是弱引用对象，需要调用JSVirtualMachine的addManagedReference:withOwner:把它添加到JSVirtualMachine对象中，确保使用过程中JSValue不会被释放<br><strong>说明3</strong>：当用户点击QSAlertView上的按钮时，根据用户点击哪一个按钮，来执行对应的处理函数，这时QSAlertView也随即被销毁。 这时需要手动调用removeManagedReference:withOwner:来移除JSManagedValue对象。</p>
<pre><code>//OC执行JS代码
[self.context evaluateScript:@&quot;function success() {print(&apos;success&apos;) }&quot;];
[self.context evaluateScript:@&quot;function failure() {print(&apos;failure&apos;) }&quot;];
self.context[@&quot;print&quot;] = ^(NSString *printStr){
    NSLog(@&quot;printStr = %@&quot;,printStr);
};
self.context[@&quot;presentNativeAlert&quot;] = ^(NSString *title,
                                        NSString *message,
                                        JSValue *successHandler,
                                        JSValue *failureHandler) {
    JSContext *context = [JSContext currentContext];
    QSAlertView *alertView = [[QSAlertView alloc] initWithTitle:title
                                                        message:message
                                                        successHandler:successHandler
                                                 failureHandler:failureHandler
                                                        context:context];
    [alertView show];
};

[self.context evaluateScript:@&quot;presentNativeAlert(&apos;提示&apos;,&apos;这是一条警告&apos;,success,failure)&quot;];
</code></pre><p><strong>说明1</strong>：在JS中定义了success和failure函数，为JS中的print函数和presentNativeAlert函数注入OC实现。<br><strong>说明2</strong>：点击弹出框的YES，调用JS的success函数，点击弹出框的NO，调用JS的failure函数。</p>
<p><strong>效果图如下：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/201701-b063e377adf7528c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JS函数弹出OC警告框的效果图.png"></p>
<h4 id="六、UIWebView中获取JSContext"><a href="#六、UIWebView中获取JSContext" class="headerlink" title="六、UIWebView中获取JSContext"></a>六、UIWebView中获取JSContext</h4><p>JavaScriptCore实现JS和OC交互是依赖<strong>JSContext对象</strong>，而在UIWebView使用中，不应该手动去创建JSContext对象，因为手动创建JSContext对象和UIWebView对应的JSContext对象并不是同一个JS上下文环境。我们应该去获取UIWebView对应的JSContext对象，虽然Apple并未提供直接的方式，但是我们可以通过KVC +  Runtime这两种方式去获取</p>
<h5 id="1、KVC"><a href="#1、KVC" class="headerlink" title="1、KVC"></a>1、KVC</h5><pre><code>JSContext *context = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];
</code></pre><p>使用简单，但是坑比较多，项目不推荐</p>
<p><strong>原因一</strong>：方法暴力，有不被APP Store的审核通过的风险<br><strong>原因二</strong>：通过KVC获取JSContext对象的时机不好控制，</p>
<ul>
<li><p>在UIWebView的<strong>shouldStartLoadWithRequest</strong>或者<strong>webViewDidStartLoad</strong>阶段中获取context，由于此时页面中的JS代码并没有完全加载完，所以JS中定义的函数在OC端无法被执行。还会出现在加载一级页面时JS可以正常调用OC的方法，而跳转到二级页面中无法执行OC的方法。</p>
</li>
<li><p>在UIWebView的<strong>webViewDidFinishLoad</strong>阶段获取context,并暴露OC方法，由于加载JS的时机在<strong>webVIewDidFinishLoad</strong>阶段之前，因此会发生JS无法调用OC方法的情况发生。</p>
</li>
</ul>
<h5 id="2、Runtime-（项目中使用）"><a href="#2、Runtime-（项目中使用）" class="headerlink" title="2、Runtime （项目中使用）"></a>2、Runtime （项目中使用）</h5><p>UIWebViewTS_JavaScriptContet项目：通过 runtime 机制，巧妙地获取 JavaScriptContext 创建之后，生成回调。</p>
<p>在项目中，实现TSWebViewDelegate中的didCreateJavaScriptContext方法，可以获取UIWebView对应的JSContext对象</p>
<pre><code>- (void)webView:(UIWebView *)webView didCreateJavaScriptContext:(JSContext*) ctx{
      //ctx就是UIWebView对应的JSContext对象
}
</code></pre><h4 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h4><h5 id="1、JS调用OC"><a href="#1、JS调用OC" class="headerlink" title="1、JS调用OC"></a>1、JS调用OC</h5><ul>
<li>通过 JSCore 中的 block</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在 JS 执⾏行行环境中添加⼀一个 _OC_catch 的 block，那么在 JS 代码中就可以直接调⽤用 _OC_catch 这 个函数，当在 JS 中调⽤用 _OC_catch 这个函数后，我们刚才注册的 block 就会被执行。也就是通过 JS 成功的调⽤了 OC 代码。</span><br><span class="line">context[@&quot;_OC_catch&quot;] = ^(JSValue *msg, JSValue *stack) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 JSCore 中的 JSExport</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSExport 可以导出 Objective-C 的属性、实例方法、类方法和初始化⽅方法到 JS 环境，这样就可 以通过 JS 代码直接调⽤用 Objective-C 。通过 JSExport 不仅可以导出⾃自定义类的方法、属性，也可以导出已有类的⽅方法、属性。在导出过程中，类的方法名会被转换成 JS 类型命名，第二个参数的第一个字⺟会被大写，比如- (void)addX:(int)x andY:(int)y;被转为addXAndY(x, y)。除此，JSExport还可以导出已有类的⽅方法、属性。</span><br></pre></td></tr></table></figure>
<ul>
<li>通过拦截 URL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过拦截 URL，这种方式是 Web 端通过某种方式发送 URLScheme 请求，之后 Native 拦截到请求并根据URL SCHEME(包括所带的参数)进行相关操作。类似于通过 SCHEME 唤起APP。这种方式的缺点是 **url 长度有隐患**，并且**创建请求需要一定的耗时**，比注入 API 的方式调用同样的功能。耗时会比较长。所以还是更推荐使用注入 API 的方式。</span><br></pre></td></tr></table></figure>
<h5 id="2、OC-调-JS"><a href="#2、OC-调-JS" class="headerlink" title="2、OC 调 JS"></a>2、OC 调 JS</h5><ul>
<li>UIWebview/WKWebview</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过 UIWebView 来获取 JSContext ，这样直接通过获取到 context 来执⾏行行 JS 代码。</span><br><span class="line">//通过 UIWebView 获取 context</span><br><span class="line">JSContext *context = [_webView</span><br><span class="line">valueForKeyPath:@&quot;documentView.webView.mainFrame.JSContext&quot;]; // 要执行的 JS 代码，定义一个 add 函数并执⾏行行NSString *addjs = @&quot;function add(a, b) &#123;return a + b;&#125;;add(1,3)&quot;;// sumValue 为执⾏行行后的结果</span><br><span class="line">JSValue *sumValue = [self.context evaluateScript:addjs];</span><br><span class="line">//WKWebView 没有提供获取 JSContext 的方法，但是它提供了执行 JS 的方法 evaluateJS: ，通过下面方法来执行 JS 代码。</span><br></pre></td></tr></table></figure>
<ul>
<li>JSCore </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 要执行的 JS 代码，定义一个 add 函数并执⾏行行</span><br><span class="line">NSString *addjs = @&quot;function add(a, b) &#123;return a + b;&#125;;add(1,3)&quot;;// sumValue 为执⾏行行后的结果</span><br><span class="line">JSValue *sumValue = [self.context evaluateScript:addjs]</span><br></pre></td></tr></table></figure>
<p>3、其他</p>
<ul>
<li><p>之前的笔记整理，主要介绍JavaScriptCore的使用，为后续JavaScriptCore深入使用做准备。</p>
</li>
<li><p>本文参考了<a href="http://liuduo.me/2015/10/24/JavaScriptCore%E5%88%9D%E6%8E%A2/" target="_blank" rel="noopener">JavaScriptCore初探</a> 和 <a href="https://segmentfault.com/a/1190000004285316" target="_blank" rel="noopener">iOS引入JavaScriptCore引擎框架</a></p>
</li>
<li><p><a href="https://github.com/buaa0300/QSKitDemo/tree/master/QSUseJSCoreDemo" target="_blank" rel="noopener">QSUseJSCoreDemo</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/02/24/iOS-IGListKit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/24/iOS-IGListKit/" itemprop="url">IGListKit</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-24T21:43:57+08:00">
                2018-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS第三方库/" itemprop="url" rel="index">
                    <span itemprop="name">iOS第三方库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,010 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><h5 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h5><ul>
<li><p><strong>IGListKit</strong>是由 Instagram 开发的应用在自身 App 上的一个 <strong>UI 组件库</strong>。它基于UICollectionView的框架，使用<strong>数据驱动</strong>，旨在创造一个更快更灵活的列表控件。</p>
</li>
<li><p><strong>IGListKit的核心点是：</strong>从Model 变化中计算出 IndexPath 变化，也就是 <strong>Diff</strong> 算法，这样才好 batch updates。</p>
</li>
</ul>
<h5 id="2、结构"><a href="#2、结构" class="headerlink" title="2、结构"></a>2、结构</h5><p><img src="https://upload-images.jianshu.io/upload_images/201701-994e7e1fc737bcb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="img">               </p>
<p><strong>说明</strong>：基于 数据驱动 的 UICollectionView 框架 IGListKit。整个框架通过 <strong>Adapter</strong> 将过去直接暴露的 CollectionView Datasource 和 Delegate 实现进行包装，并通过它关联 Model 和 IGListSectionController。这使得上层用户只需要继承并实现所需要的 IGListSectionController 接口即可，很好地进行了代码解耦。</p>
<h4 id="二、基础使用"><a href="#二、基础使用" class="headerlink" title="二、基础使用"></a>二、基础使用</h4><h5 id="1、IGListAdapter的初始化"><a href="#1、IGListAdapter的初始化" class="headerlink" title="1、IGListAdapter的初始化"></a>1、IGListAdapter的初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.collectionView = [[UICollectionView alloc]initWithFrame:CGRectZero collectionViewLayout:[[UICollectionViewFlowLayout alloc]init]];</span><br><span class="line">self.collectionView.backgroundColor = [UIColor whiteColor];</span><br><span class="line">IGListAdapterUpdater*updater = [[IGListAdapterUpdater alloc]init];</span><br><span class="line">self.**adapter** = [[IGListAdapter alloc]initWithUpdater:updater viewController:self workingRangeSize:0];</span><br><span class="line">self.adapter.collectionView = self.collectionView;</span><br><span class="line">self.adapter.dataSource = self;</span><br><span class="line">[self.view addSubview:self.collectionView];</span><br></pre></td></tr></table></figure>
<h5 id="2、实现IGListAdapter的协议"><a href="#2、实现IGListAdapter的协议" class="headerlink" title="2、实现IGListAdapter的协议"></a>2、实现IGListAdapter的协议</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIView *)**emptyViewForListAdapter**:(nonnull IGListAdapter *)listAdapter &#123;</span><br><span class="line"> //没有数据时候的View</span><br><span class="line">    UILabel *label=[UILabel new];</span><br><span class="line">    label.text=@&quot;没有数据&quot;;</span><br><span class="line">    label.textAlignment=NSTextAlignmentCenter;</span><br><span class="line">    return label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull IGListSectionController *)listAdapter:(nonnull IGListAdapter *)**listAdapter** **sectionControllerForObject**:(nonnull id)object &#123;</span><br><span class="line">    DemoSectionController *sectionController=[[DemoSectionController alloc]init];</span><br><span class="line">    return section;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull NSArray&lt;id&lt;IGListDiffable&gt;&gt; *)**objectsForListAdapter**:(nonnull IGListAdapter *)listAdapter &#123;</span><br><span class="line">    //数据源</span><br><span class="line">    return  self.dataArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、IGListSectionController的方法"><a href="#3、IGListSectionController的方法" class="headerlink" title="3、IGListSectionController的方法"></a>3、IGListSectionController的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)**numberOfItems**&#123;</span><br><span class="line">   //每个section返回多少行根据数据来写</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGSize)**sizeForItemAtIndex**:(NSInteger)index&#123;</span><br><span class="line">    return  CGSizeMake(self.collectionContext.containerSize.width, 64);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UICollectionViewCell *)**cellForItemAtIndex**:(NSInteger)index&#123;    </span><br><span class="line">    DemoCollectionViewCell*cell=[self.collectionContext dequeueReusableCellOfClass:[DemoCollectionViewCell class] forSectionController:self atIndex:index];</span><br><span class="line">    [cell setModel:_object row:index];</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)**didSelectItemAtIndex**:(NSInteger)index &#123;</span><br><span class="line">    NSLog(@&quot;点击Section%ld  row%ld&quot;,(long)self.section,(long)index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)**didUpdateToObject**:(id)object&#123;</span><br><span class="line">    //数据传输到这里</span><br><span class="line">    _object =(DemoModel *)object;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、自定义model实现IGListDiffable协议"><a href="#4、自定义model实现IGListDiffable协议" class="headerlink" title="4、自定义model实现IGListDiffable协议"></a>4、自定义model实现IGListDiffable协议</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">- (nonnull id&lt;NSObject&gt;)diffIdentifier &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqualToDiffableObject:(nullable id&lt;IGListDiffable&gt;)object &#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else if (self == nil || object == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三、Diffing算法"><a href="#三、Diffing算法" class="headerlink" title="三、Diffing算法"></a>三、Diffing算法</h4><h5 id="1、算法流程描述"><a href="#1、算法流程描述" class="headerlink" title="1、算法流程描述"></a>1、算法流程描述</h5><p>计算collectionView前后数据变化增删改移关系的算法，算法主要过程是：</p>
<p>输入：前后变化的数据数组，新的数据数组为newArray，旧的数据数组为oldArray，newArray和oldArray中的model都实现了IGListDiffable协议</p>
<p>1、首先创建一个hash表(unordered_map) <strong>table</strong></p>
<p>2、先遍历newArray，每个model对应生成<strong>IGListEntry</strong>对象，并根据model的</p>
<p><strong>diffIdentifier</strong>返回值作为key存入table，使得 newCount++，同时计入 newResultsArray</p>
<p>3、再遍历oldArray，根据每个model的<strong>diffIdentifier</strong>返回值作为key，从table中找到对应的<strong>IGListEntry</strong>对象，没有就生成并存入table，使得oldCount++，同时将当前序号入栈 oldIndexes.push(i)，并记录<strong>oldResultsArray</strong></p>
<p>4、遍历 <strong>newResultsArray</strong>，检查 entry 对应的 oldIndexes 信息，如果堆栈中有<strong>旧队列序号值</strong>，则表示当前 entry 至少对应新旧队列中的两个对象，即发生所谓的 <strong>entry match</strong>，进行记录，方便后续反向查询。再通过检查 新队列当前对象 和 entry 对应旧对象 是否相同确认 update 状态。</p>
<ul>
<li><p>再次遍历新旧 entry list，检查每个 entry 的 entry match 状态</p>
</li>
<li><p>没有 entry match 的对象，在新队列中的被标记为 insert<strong>，</strong>而在旧队列中的则被标示为 delete</p>
</li>
<li>有 entry match 的对象**通过比较新旧队列序号和 update 状态分表表示为 update，move和 not modified</li>
</ul>
<h5 id="2、算法示例"><a href="#2、算法示例" class="headerlink" title="2、算法示例"></a>2、算法示例</h5><p><strong>1）</strong>以旧数组 [1,2,3] 和新数组 [1,3,5] 为例 （数字比较直接忽略 update 状态）</p>
<ul>
<li><p>- 遍历新数组，得到 <strong>[entry1,entry3,entry5]</strong> 列表，记为 newResultsArray</p>
</li>
<li><p>- 遍历旧数组，得到 <strong>[entry1,entry2,entry3]</strong> 列表，记为 oldResultsArray</p>
</li>
</ul>
<p><strong>2)</strong>  遍历<strong>newResultsArray</strong>，由于 entry1 oldIndexs = [0]，entry3 oldIndexes = [2] 所以他们是 entry match，做记录 （reverse lookup）</p>
<p><strong>3)</strong> 遍历 <strong>oldResultsArray</strong></p>
<ul>
<li><p>entry1 有 entry match，跳过</p>
</li>
<li><p>entry2 没有 entry match，记为 delete</p>
</li>
<li><p>entry3 有 entry match，跳过</p>
</li>
</ul>
<p><strong>4)</strong> 遍历 <strong>newResultsArray</strong></p>
<ul>
<li><p>entry1 有 entry match，同时相对位置不变，记为 not modified (其实就是跳过)</p>
</li>
<li><p>entry3 有 entry match，但是相对位置变化，记为 <strong>move</strong></p>
</li>
<li><p>entry5 没有 entry match，记为 <strong>insert</strong></p>
</li>
</ul>
<p><strong>5)</strong> 输出一个包含 insert，move，delete 和 update 列表信息的最终结果</p>
<p><strong>参考</strong> <a href="https://xiangwangfeng.com/2017/03/16/IGListKit-diff-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">IGListKit diff 实现简析</a>、<a href="https://instagram.github.io/IGListKit/index.html" target="_blank" rel="noopener">IGListKit Reference</a> 、<a href="http://blog.danthought.com/programming/2018/06/22/iglistkit/" target="_blank" rel="noopener">IGListKit</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/02/06/iOS-iOSRuntime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/iOS-iOSRuntime/" itemprop="url">iOS Runtime 小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T22:53:28+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,843 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Objective-C利用Runtime库(底层的 C 语言 API)赋予了语言的动态特性。</p>
<h4 id="一、Runtime基石：Objective-C对象模型"><a href="#一、Runtime基石：Objective-C对象模型" class="headerlink" title="一、Runtime基石：Objective-C对象模型"></a>一、Runtime基石：Objective-C对象模型</h4><h5 id="1、对象"><a href="#1、对象" class="headerlink" title="1、对象"></a>1、对象</h5><ul>
<li><p>每一个对象都是<strong>类的实例</strong>, 类中保存<strong>对象的方法列表</strong>；当一个对象方法被调用时，类会首先查找它本身是否有该方法的实现，如果没有，则会向它的父类查找该方法，直到NSObject(根类)；</p>
</li>
<li><p>类是<strong>元类 (metaclass) 的实例</strong>；元类保存<strong>类方法列表</strong>；当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则会向它的父类查找该方法，直到NSObject(根类)；</p>
</li>
</ul>
<h5 id="2、isa指针"><a href="#2、isa指针" class="headerlink" title="2、isa指针"></a>2、isa指针</h5><ul>
<li><p>对象的<strong>isa指针</strong>指向所属的类，类的<strong>isa指针</strong>指向所属的元类；所有的元类的 <strong>isa指针</strong>都会指向一个根元类 (root metaclass)。根元类的 <strong>isa指针</strong>指向自己，行成了一个闭环。</p>
</li>
<li><p>在64 位 CPU 下，isa 的内部结构有变化。具体查看用<a href="http://ios.jobbole.com/89485/" target="_blank" rel="noopener"> isa 承载对象的类信息</a></p>
</li>
<li><p>对象、isa指针、类、元类、根元类的关系如下图：</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/201701-fa143a7c6b17b43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="OC类图.png"></p>
<h5 id="3、对象布局"><a href="#3、对象布局" class="headerlink" title="3、对象布局"></a>3、对象布局</h5><ul>
<li>实例变量（包括父类）都保存在对象本身的存储空间内；实例方法保存在<strong>类</strong>中，类方法保存在<strong>元类</strong>中；父类的实例方法保存在各级 super class 中，父类的类方法保存在各级 super meta class;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//对象组成 --start--</span><br><span class="line">   	isa pointer</span><br><span class="line">   	rootClass&apos;s vars</span><br><span class="line">   	penultimate superClass&apos;s vars</span><br><span class="line">   	...</span><br><span class="line">   	superClass&apos;s vars</span><br><span class="line">   	Class&apos;s vars</span><br><span class="line">   	//对象组成 --end--</span><br><span class="line"></span><br><span class="line">   	typedef struct objc_class *Class;</span><br><span class="line">    	//类的结构</span><br><span class="line">    	struct objc_class&#123;</span><br><span class="line">     	struct objc_class* isa;                              //指向元类</span><br><span class="line">     	struct objc_class* super_class;                //指向父类</span><br><span class="line">     	const char* name;</span><br><span class="line">     	long version;</span><br><span class="line">     	long info;</span><br><span class="line">     	long instance_size;</span><br><span class="line">     	struct objc_ivar_list* ivars;                         //实例变量列表</span><br><span class="line">     	struct objc_method_list** methodLists;      //方法列表</span><br><span class="line">     	struct objc_cache* cache;</span><br><span class="line">     	struct objc_protocol_list* protocols;           //协议列表</span><br><span class="line">   	&#125;;</span><br><span class="line"></span><br><span class="line">   	//实例变量的结构</span><br><span class="line">   	struct objc_ivar &#123;</span><br><span class="line">       	char *ivar_name  OBJC2_UNAVAILABLE;</span><br><span class="line">       	char *ivar_type  OBJC2_UNAVAILABLE;</span><br><span class="line">       	int ivar_offset  OBJC2_UNAVAILABLE;</span><br><span class="line">    # ifdef __LP64__</span><br><span class="line">	   int space        OBJC2_UNAVAILABLE;</span><br><span class="line">    # endif</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明1</strong>：对象中保存指向类的<code>isa</code>指针 以及 各级的 实例变量(<code>ivar</code>)，这个内存结构在编译时就确定下来了，不能在编译时给对象增加实例变量。</p>
<p><strong>说明2</strong>：类的内存布局有<code>isa</code>指针、<code>super_class</code>指针、实例变量列表、方法列表和协议列表，其中实例变量(var)包含了变量的名称、类型、偏移等。</p>
<h5 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h5><ul>
<li><strong>Runtime</strong> 就是<strong>动态库</strong>(运行时库)的一部分。比如 C 语言中 glibc 动态链接库通常会被很多操作依赖，包括字符串处理(strlen、strcpy)、信号处理、socket、线程、IO、动态内存分配等等。由于每个程序都依赖于运行时库，这些库一般都是动态链接的。这样一来，运行时库可以存储在操作系统中，很多程序共享一个动态库，这样就可以节省内存占用空间和应用程序大小。</li>
<li>链接一般分为静态链接和动态链接；一般说的预编译、编译、汇编、链接，其中的链接是指静态链接。所谓的动态链接是指: 链接过程被推迟到运行时再进行。</li>
</ul>
<h4 id="二、Runtime核心：消息发送和转发"><a href="#二、Runtime核心：消息发送和转发" class="headerlink" title="二、Runtime核心：消息发送和转发"></a>二、Runtime核心：消息发送和转发</h4><p><strong>Runtime</strong>赋予了OC了诸多动态特性，使其可以在运行时可以做一些事情；主要表现为：<strong>动态类型</strong>（在运行时才检查对象类型）和 <strong>动态绑定</strong>（接到消息后，由运行环境决定执行哪部分代码）</p>
<h5 id="1、消息发送（Message）"><a href="#1、消息发送（Message）" class="headerlink" title="1、消息发送（Message）"></a>1、消息发送（Message）</h5><ul>
<li><p>Objective-C 中的方法调用，实质上是在底层用objc_msgSend()实现<strong>消息发送</strong>，其核心在于：<strong>根据SEL(选择器)开始找到IMP</strong>；其中SEL是实例方法的指针，可以看做方法名字符串；IMP是函数指针，指向方法实现的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//调用方法  </span><br><span class="line">[obj doSomething];</span><br><span class="line">//在编译时候转换</span><br><span class="line">objc_msgSend(obj,@selector(doSomething))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>objc_msgSend</strong>的定义如下：</p>
<pre><code>// self是接收者，接收该消息的类的实例
// _cmd是选择器，要处理的消息的selector
// ... 是需传入的参数，参数个数不定
objc_msgSend(id self, SEL _cmd, ...) 
</code></pre></li>
<li><p><strong>objc_msgSend的发送流程</strong>：先在Class中的<strong>缓存</strong>查找imp（没缓存则初始化缓存），如果没找到，在类的方法列表中查找，如果还没有，则向Class的父类的方法列表中查找，如果还没有找到，继续向上查找，直至根类，如果还没有找到对应的IMP，就走消息转发(_objc_msgForward)了。</p>
</li>
<li><p>给nil发送消息不会有什么作用，但是返回值有些区别，具体如下：</p>
<pre><code>a) 如果方法返回值是 对象，返回nil
b) 如果方法返回值是 指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量
c) 如果方法返回值是 结构体，发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。
d) 如果方法返回值不是 上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。
</code></pre></li>
</ul>
<h5 id="2、消息转发（Message-Forwarding）"><a href="#2、消息转发（Message-Forwarding）" class="headerlink" title="2、消息转发（Message Forwarding）"></a>2、消息转发（Message Forwarding）</h5><p>消息转发解决的是：查找IMP(方法实现)失败后的处理；经历<strong>动态方法解析</strong>、 <strong>备用接收者</strong>和 <strong>完整的消息转发</strong>三个过程，其流程如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/201701-35938988b21e8a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发流程.png"></p>
<ul>
<li><p><strong>动态方法解析</strong>：接收到未知消息时，Runtime向当前类发送+resolveInstanceMethod:或+resolveClassMethod:消息，在这里可以<strong>添加缺失的方法</strong>，返回YES，重新发送消息，否则继续下一步；</p>
</li>
<li><p><strong>备用接收者</strong>：<strong>动态方法解析</strong>中没能处理，Runtime会向forwardingTargetForSelector:发消息，如果该方法返回了一个非nil或非self对象，恰好该对象实现了这个方法，那么该对象就成了消息的接收者，消息就被分发到该对象。</p>
</li>
<li><p><strong>完整消息转发</strong>：前两个都没能处理好，Runtime发送methodSignatureForSelector:消息，获取selector对应方法的签名；如果有方法签名返回，则根据方法签名创建描述消息的NSInvocation，向当前对象发送forwardInvocation:消息；如果没有方法签名返回，返回nil，向当前对象发送doesNotRecognizeSelector:消息，应用Crash退出。</p>
</li>
</ul>
<h5 id="3、避免消息转发的办法"><a href="#3、避免消息转发的办法" class="headerlink" title="3、避免消息转发的办法"></a>3、避免消息转发的办法</h5><p><strong>在消息转发三个过程中，未知消息的处理过程越往后，代价越大</strong>；一般我们可以这么做 尽可能避免消息转发，可以这么做：</p>
<ul>
<li><p><strong>调用delegate 方法前检查方法是否实现</strong>(respondsToSelector:), 只有实现了(respondsToSelector:返回YES) ，才去真正调用delegate 方法。</p>
<pre><code>if([self.delegate respondsToSelector: @selector(sayHello)]) {
   [self.delegate sayHello];
}
</code></pre></li>
<li><p><strong>直接调用方法，少用performSelector:</strong>；因为在直接调用方法时，编译自动校验，如果方法不存在，编译器会直接报错；而使用performSelector:的话一定是在运行时候才能发现，如果此方法不存在就会崩溃。</p>
<pre><code>//直接使用方法调用,少使用performSelector
[dog sayHello];
// [dog performSelector:@selector(sayHello) withObject:nil];
</code></pre></li>
<li><p><strong>使用performSelector:，最好先判断方法是否实现(respondsToSelector:)</strong>，只有实现了(respondsToSelector:返回YES) ，才去调用performSelector：方法。</p>
<pre><code>//respondsToSelector:和performSelector:组合使用
      if ([dog respondsToSelector:@selector(sayHello)])         {
      [dog performSelector:@selector(sayHello)];
   }
</code></pre></li>
<li><p><strong>强制类型转换，先判断对象是否属于强制转换后的类</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if([data isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line">   //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4、super本质"><a href="#4、super本质" class="headerlink" title="4、super本质"></a>4、super本质</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Cat</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[self class]);      //Cat</span><br><span class="line">        NSLog(@&quot;%@&quot;,[self superclass]); //Animal</span><br><span class="line">        NSLog(@&quot;%@&quot;,[super class]);     //Cat</span><br><span class="line">        NSLog(@&quot;%@&quot;,[super superclass]);//Animal</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;@end</span><br></pre></td></tr></table></figure>
<ul>
<li>super 调用底层会转换为<strong>objc_msgSendSuper</strong>函数的调用，objc_msgSendSuper 函数接收 2 个参数 <strong>objc_super</strong> 结构体和 <strong>SEL</strong> ，objc_super结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">    __unsafe_unretained _Nonnull id receiver; // 消息接收者</span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class; // 消息接收者的父类</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>[super class] 在调用过程中，底层转化为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSendSuper(&#123;self, [Animal class]&#125;, @selector(class));</span><br></pre></td></tr></table></figure>
</li>
<li><p>同 objc_msgSend 函数相比，多了第二个参数，但<strong>消息接收仍然是 self</strong> ，所以打印结果为 Cat。</p>
</li>
<li><p>objc_msgSendSuper 方法中的第二个参数主要作用是告诉从哪里开始搜索方法实现，一般传入的是父类。这也是实际开发中 [super superClassMethod] 直接调用父类方法的原因。</p>
</li>
</ul>
<h4 id="三、Runtime特性和应用"><a href="#三、Runtime特性和应用" class="headerlink" title="三、Runtime特性和应用"></a>三、Runtime特性和应用</h4><h5 id="1、分类（Category）"><a href="#1、分类（Category）" class="headerlink" title="1、分类（Category）"></a>1、分类（Category）</h5><ul>
<li><p><strong>原理</strong>：对象的<strong>方法</strong>定义都保存在类的可变区域中，修改methodLists指针指向的指针的值，就可以实现动态地为某一个类增加<strong>成员方法</strong>。(<em>但是对象布局在编译时候就固定了，结构体的大小并不能动态变化，在运行时不能增加实例变量</em>)。</p>
</li>
<li><p>通过关联<code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code>方法可以变相地给对象增加实例变量，并不会真正改变了对象的内存结构。</p>
</li>
<li><p>通过Category新增的方法，会插入到方法列表的前部；如果有和原来方法重名，在运行时，顺序查找时，一旦找到对应名字的方法，就不再查找，导致<strong>原来方法</strong>得不到机会，<em>这是Category新增的方法和原方法重名，原有方法失效的原因</em>。</p>
</li>
<li><p><strong>作用</strong>：给现有的类添加方法；将一个类的实现拆分成多个独立的源文件；声明私有的方法。</p>
</li>
</ul>
<h5 id="2、关联对象（Associated-Objects）"><a href="#2、关联对象（Associated-Objects）" class="headerlink" title="2、关联对象（Associated Objects）"></a>2、关联对象（Associated Objects）</h5><ul>
<li><p><strong>原理</strong>：Category不能给一个已有类添加实例变量，但是可以通过<strong>关联对象</strong>添加属性；但是关联对象不会改变对象的内存布局，新增的属性是添加到和对象地址关联的哈希表中；</p>
</li>
<li><p>Associated Objects 相关的三个方法</p>
<pre><code>objc_setAssociatedObject    //添加关联对象
objc_getAssociatedObject    //获取关联对象
objc_removeAssociatedObjects  // 删除所有关联对象
</code></pre></li>
<li><p><strong>作用</strong>：为现有的类添加私有变量以帮助实现细节；为现有的类添加公有属性；为 KVO 创建一个关联的观察者</p>
<p>具体参考：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">Objective-C Associated Objects 的实现原理</a></p>
</li>
</ul>
<h5 id="3、方法混写-Method-Swizzling"><a href="#3、方法混写-Method-Swizzling" class="headerlink" title="3、方法混写(Method Swizzling)"></a>3、方法混写(Method Swizzling)</h5><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，<strong>查找消息的唯一依据是selector的名字</strong>。利用Objective-C的动态特性，<strong>可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</strong> </p>
<p>每个类都有一个方法列表，存放着<strong>selector的名字</strong>和<strong>方法实现</strong>的映射关系。IMP有点类似函数指针，指向具体的Method实现。</p>
<ul>
<li><strong>原理</strong>：在运行时交换方法实现（IMP）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用 method_exchangeImplementations 来交换2个方法中的IMP，</span><br><span class="line">利用 class_replaceMethod 来修改类，</span><br><span class="line">利用 method_setImplementation 来直接设置某个方法的IMP，</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：可以利用它hook原有的方法，插入自己的业务需求</li>
</ul>
<p>详细参考我写的<a href="https://www.jianshu.com/p/5f2e38a40aa4" target="_blank" rel="noopener">Method Swizzling小记</a></p>
<h5 id="4、键值观察（KVO）"><a href="#4、键值观察（KVO）" class="headerlink" title="4、键值观察（KVO）"></a>4、键值观察（KVO）</h5><p>  观察者模式在Objective-C的应用之一，借助Runtime特性，实现自动键值观察；使用了isa swizzling机制。具体描述如下：</p>
<ul>
<li>当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个<strong>子类</strong>，在这个子类中<strong>重写</strong>基类中被观察属性的 setter 方法，实现真正的通知机制；</li>
<li>派生类还重写了 class 方法以“欺骗”外部调用者，系统将对象的 isa 指针指向这个<strong>新诞生的子类</strong>，实质上这个对象就成为该派生类的对象了，因而在该对象上对 setter 的调用就会调用重写的 setter，从而激活键值通知机制。</li>
<li>此外，派生类还重写了 dealloc 方法来释放资源。</li>
</ul>
<p><strong>说明</strong>：KVC（键值编码）是不通过存取方法，而通过属性名称字符串间接访问属性的机制，没有用到isa swizzling机制。</p>
<h5 id="5、NSProxy"><a href="#5、NSProxy" class="headerlink" title="5、NSProxy"></a>5、NSProxy</h5><ul>
<li><p>OC是单继承的，但是可以利用NSProxy实现一下<strong>“伪多继承”</strong>，具体参考<a href="">NSProxy——少见却神奇的类</a></p>
</li>
<li><p>项目中，主要是利用NSProxy做<strong>消息转发的代理类</strong>，如弱引用代理类，可以打破循环引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//代码摘自 FLAnimatedImage</span><br><span class="line">@interface FLWeakProxy : NSProxy</span><br><span class="line">- (instancetype)weakProxyForObject:(id)targetObject;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface FLWeakProxy ()</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@end</span><br><span class="line">	</span><br><span class="line">@implementation FLWeakProxy</span><br><span class="line">	</span><br><span class="line"># pragma mark Life Cycle</span><br><span class="line"></span><br><span class="line">//类没有定义默认的init方法.</span><br><span class="line">- (instancetype)weakProxyForObject:(id)targetObject&#123;</span><br><span class="line">	FLWeakProxy *weakProxy = [FLWeakProxy alloc];</span><br><span class="line">   	weakProxy.target = targetObject;</span><br><span class="line">   	return weakProxy;</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"># pragma mark Forwarding Messages</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)selector&#123;</span><br><span class="line">  // Keep it lightweight: access the ivar directly</span><br><span class="line">  	return _target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</span><br><span class="line"> 	 void *nullPointer = NULL;</span><br><span class="line">  	 [invocation setReturnValue:&amp;nullPointer];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector&#123;</span><br><span class="line"> 	 return [NSObject instanceMethodSignatureForSelector:@selector(init)];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: NSProxy非常适合做消息转发的代理类，能自动转发<nsobject>中定义的接口和NSObject的Category中定义的方法，如果使用NSObject来做，不能自动转发NSObject的Category中定义、respondsToSelector:、isKindOfClass:这两个方法。·</nsobject></p>
</li>
</ul>
<h5 id="6、load和initialize"><a href="#6、load和initialize" class="headerlink" title="6、load和initialize"></a>6、load和initialize</h5><ul>
<li>在Objective-C中，runtime会自动调用每个类的两个方法。+load会在<strong>类初始加载时</strong>调用，+initialize会在<strong>第一次调用类的类方法或实例方法之前</strong>被调用。</li>
<li>这两个方法是可选的，且只有在实现了它们时才会被调用。 </li>
<li><strong>共同点：两个方法都只会被调用一次。</strong></li>
</ul>
<h4 id="四、KVO补充"><a href="#四、KVO补充" class="headerlink" title="四、KVO补充"></a>四、KVO补充</h4><h5 id="1、KVO的使用"><a href="#1、KVO的使用" class="headerlink" title="1、KVO的使用"></a>1、KVO的使用</h5><ul>
<li><code>KVO</code>如果使用不当很容易崩溃，如：<code>Observer</code>被重复<code>remove</code>，或者没有及时移除（KVO crash notifying deallocated observer），<code>keyPath</code>传错都会导致崩溃。</li>
<li>在调用<code>KVO</code>时需要传入一个<code>keyPath</code>，由于<code>keyPath</code>是字符串的形式，所以其对应的属性发生改变后，字符串没有改变容易导致<code>Crash</code>。我们可以利用系统的反射机制将<code>keyPath</code>反射出来，这样编译器可以在<code>@selector()</code>中进行合法性检查。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSStringFromSelector(@selector(isFinished))</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>KVO</code>是一种事件绑定机制的实现，在<code>keyPath</code>对应的值发生改变后会回调对应的方法。这种数据绑定机制，在对象关系很复杂的情况下，很容易导致不好排查的<code>bug</code>。例如<code>keyPath</code>对应的属性被调用的关系很复杂，就不太建议对这个属性进行<code>KVO</code>，可以想一下<code>RAC</code>的信号脑补一下。</p>
</li>
<li><p>如果项目中要使用KVO，建议使用Facebook的<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a>，</p>
</li>
</ul>
<h5 id="2、KVOController"><a href="#2、KVOController" class="headerlink" title="2、KVOController"></a>2、KVOController</h5><ul>
<li><p><strong>本质</strong>：对系统<code>KVO</code>的封装，具有原生<code>KVO</code>所有的功能，而且规避了原生<code>KVO</code>的很多问题，兼容<code>block</code>和<code>action</code>两种回调方式。</p>
</li>
<li><p><strong>特点</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不需要手动移除观察者；框架自动帮我们移除观察者</span><br><span class="line">使用 block 来替代方法能够减少使用的复杂度，提升使用 KVO 的体验；**block或者selector的方式，方便使用</span><br><span class="line">每一个 keyPath 会对应一个属性，不需要在 block 中使用 if 判断 keyPath；**一个keyPath对应一个SEL或者block，不需要统一的observeValueForKeyPath方法里写if判断</span><br></pre></td></tr></table></figure>
<h5 id="3、-参考"><a href="#3、-参考" class="headerlink" title="3、 参考"></a>3、 参考</h5><p><a href="https://segmentfault.com/a/1190000013813643" target="_blank" rel="noopener">KVO原理分析及使用进阶</a></p>
<h4 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h4><h5 id="1、Swift的动态性"><a href="#1、Swift的动态性" class="headerlink" title="1、Swift的动态性"></a>1、Swift的动态性</h5><ul>
<li>纯 Swift 类没有动态性，但在方法、属性前添加 dynamic 修饰可以获得动态性。  </li>
<li>继承自 NSObject 的 Swift 类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加 dynamic 修饰才可以获得动态性。  </li>
<li>若方法的参数、属性类型为 Swift 特有、无法映射到 Objective-C 的类型 (如 Character、Tuple)，则此方法、属性无法添加 dynamic 修饰（会编译错误）  </li>
<li>Swift 类在 Objective-C 中会有模块前缀</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/02/04/iOS-iOSRunloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/04/iOS-iOSRunloop/" itemprop="url">iOS RunLoop小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-04T23:07:27+08:00">
                2018-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,756 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><ul>
<li><strong>RunLoop</strong>：运行循环；当没有事件/消息时，RunLoop让线程休眠；当有事件/消息发生时，RunLoop唤醒线程去处理。</li>
<li><strong>每个线程都有一个对应的 Runloop 对象</strong>；主线程的RunLoop会在App运行时自动运行，<strong>子线程中需要手动获取并运行，第一次获取时，才会去创建</strong>。</li>
<li><p>一个RunLoop包含若干个Mode,每个<strong>Mode</strong>包含若干个<strong>Source/Timer/Observer</strong>。每次启动RunLoop时，只能指定一个Mode，如果需要切换Mode，需要退出Loop，再重新指定一个Mode进入。</p>
</li>
<li><p>RunLoop，Foundation层对应的是<strong>NSRunLoop</strong>，Core Foundation层对应的是<strong>CFRunLoopRef</strong>；</p>
</li>
</ul>
<h4 id="二、Runloop-Mode"><a href="#二、Runloop-Mode" class="headerlink" title="二、Runloop Mode"></a>二、Runloop Mode</h4><h5 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h5><ul>
<li><p>一个RunLoop包含若干个Mode,每个<strong>Mode</strong>包含若干个<strong>Source/Timer/Observer</strong>。每次启动RunLoop时，只能指定一个Mode，如果需要切换Mode，需要退出Loop，再重新指定一个Mode进入。</p>
</li>
<li><p>Foundation暴露出来的Mode有： <strong>NSDefaultRunLoopMode</strong> 和 <strong>NSRunLoopCommonModes</strong>；NSDefaultRunLoopMode是默认的Mode；NSRunLoopCommonModes 是Mode集合，包括NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode; 只要RunLoop运行在NSRunLoopCommonModes中任何一个模式，这个事件源都可以被触发。</p>
</li>
</ul>
<pre><code>NSDefaultRunLoopMode             //默认的运行方式
NSTaskDeathCheckMode             //task任务
UITrackingRunLoopMode            //UI跟踪（如UITableView上下滑动）
NSRunLoopCommonModes             //Mode集合

 //其他, 很少用
NSModalPanelRunLoopMode       //在Model Panel情况下去区分事件(OS X开发中会遇到)
NSConnectionReplyMode             //可以监听NSConnection对象的状态，比较少用
</code></pre><p>  <strong>说明</strong>：RunLoop不能在运行在NSRunLoopCommonModes模式，因为NSRunLoopCommonModes只是个模式集合，而不是一个具体的模式。</p>
<h5 id="2、Source-Timer-Observer"><a href="#2、Source-Timer-Observer" class="headerlink" title="2、Source/Timer/Observer"></a>2、Source/Timer/Observer</h5><ul>
<li><p><strong>CFRunLoopSourceRef</strong></p>
<p>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</span><br><span class="line"></span><br><span class="line">Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>CFRunLoopTimerRef</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>CFRunLoopObserverRef</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">     kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">     kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">     kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">     kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">     kCFRunLoopAllActivities = 0x0FFFFFFFU // loop 所有状态改变</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="三、Runloop-Observer"><a href="#三、Runloop-Observer" class="headerlink" title="三、Runloop Observer"></a>三、Runloop Observer</h4><h5 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h5><ul>
<li><p>Runloop 通过监控 Source 来决定有没有任务要做，除此之外，我们还可以用 Runloop Observer 来监控 Runloop 本身的状态。RunLoop的状态有</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">     kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">     kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">     kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">     kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">     kCFRunLoopAllActivities = 0x0FFFFFFFU // loop 所有状态改变</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2、AutoreleasePool"><a href="#2、AutoreleasePool" class="headerlink" title="2、AutoreleasePool"></a>2、AutoreleasePool</h5><ul>
<li><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，一个监听<strong>kCFRunLoopEntry</strong>（<em>即将进入Loop</em>），回调内会<strong>创建自动释放池</strong>(<em>_objc_autoreleasePoolPush()</em>)；优先级最高，保证创建释放池发生在其他所有回调之前；</p>
</li>
<li><p>另一个监听 <strong>kCFRunLoopBeforeWaiting</strong>(<em>准备进入休眠</em>) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；<strong>kCFRunLoopExit</strong>(<em>即将退出Loop</em>) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。优先级最低，保证其释放池子发生在其他所有回调之后。</p>
</li>
</ul>
<h5 id="3、界面更新"><a href="#3、界面更新" class="headerlink" title="3、界面更新"></a>3、界面更新</h5><ul>
<li>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</li>
<li>苹果注册了一个 Observer 监听 <strong>kCFRunLoopBeforeWaiting</strong>(<em>即将进入休眠</em>) 和 <strong>kCFRunLoopExit</strong>(<em>即将退出Loop</em>)  事件，回调执行函数，函数会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</li>
</ul>
<h5 id="4、-定时器"><a href="#4、-定时器" class="headerlink" title="4、 定时器"></a>4、 定时器</h5><ul>
<li>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。</li>
<li><p>RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
</li>
<li><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
</li>
<li><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
</li>
</ul>
<h5 id="5、PerformSelecter"><a href="#5、PerformSelecter" class="headerlink" title="5、PerformSelecter"></a>5、PerformSelecter</h5><ul>
<li><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
</li>
<li><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
</li>
</ul>
<h4 id="五、RunLoop手动启动和取消"><a href="#五、RunLoop手动启动和取消" class="headerlink" title="五、RunLoop手动启动和取消"></a>五、RunLoop手动启动和取消</h4><h5 id="1、手动启动"><a href="#1、手动启动" class="headerlink" title="1、手动启动"></a>1、手动启动</h5><p>主线程默认已经启动，一般在子线程中手动启动RunLoop；NSRunloop提供的三种启动方式，如下：</p>
<pre><code>//1、无条件运行(强烈不推荐)
- (void)run; 
</code></pre><p><strong>说明1</strong>：如果Runloop上有事件源，RunLoop会一直运行在NSDefaultRunLoopMode模式；除非移除事件源，线程才能停止；</p>
<pre><code>//2、启动 + 超时限制
- (void)runUntilDate:(NSDate *)limitDate;  

//Demo, RunLoop会每1秒退出一次，然后又启动RunLoop，连续10次后退出RunLoop
NSInteger loopCount = 0;
while (loopCount++ &lt; 10){
      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
      NSLog(@&quot;%@ exiting runloop.........:&quot;,@(loopCount));
}
</code></pre><p><strong>说明2</strong>：可以控制每次RunLoop的运行时间，但是默认是NSDefaultRunLoopMode模式；超过时间限制后可以再次运行RunLoop；</p>
<pre><code>//3、有一个超时时间限制，而且设置运行模式 （推荐使用）
- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;

//Demo : 使用CFRunLoopStop暂停RunLoop
dispatch_async(dispatch_get_global_queue(0, 0), ^{
    NSLog(@&quot;线程开始&quot;);
    _thread = [NSThread currentThread];
    NSRunLoop *runloop = [NSRunLoop currentRunLoop];
    [runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
    //
    [runloop runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:10]];
    NSLog(@&quot;线程结束&quot;);
});

//延迟执行
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    [self performSelector:@selector(stopRunLoop) onThread:_thread withObject:nil waitUntilDone:NO];
});

- (void)stopRunLoop{
    CFRunLoopStop(CFRunLoopGetCurrent());
    NSLog(@&quot;暂停runloop&quot;);
}
</code></pre><p><strong>说明3</strong>：可以设置超时限制和运行模式，比较灵活，还可以被CFRunLoopStop(runloopRef)所停止（<em>Demo显示</em>）。</p>
<p><strong>说明4</strong>：NSRunloop是基于CFRunloop来封装的，NSRunloop是线程不安全的，而CFRunloop则是线程安全的；CFRunloop还提供了2中启动方式(<em>CFRunLoopRun、CFRunLoopRunInMode</em>)</p>
<p><strong>说明5</strong>：因为NSRunLoopCommonModes是个模式集合，不是一个具体的模式，RunLoop不能在运行在NSRunLoopCommonModes模式；但是可以在添加事件源的时候使用NSRunLoopCommonModes，只要RunLoop运行在NSRunLoopCommonModes中任何一个模式，这个事件源都可以被触发。</p>
<h5 id="2、取消"><a href="#2、取消" class="headerlink" title="2、取消"></a>2、取消</h5><p><em>了解了启动方式后，取消就很清晰了</em>，主要有三种：</p>
<ul>
<li><p>移除掉RunLoop中的所有事件源（timer和source）</p>
</li>
<li><p>达到超时（limitDate）条件</p>
</li>
<li><p>使用CFRunLoopStop(CFRunLoopRef rl )停止（CFRunloop运行起来或通过NSRunloop的runMode:beforeDate:方法）。</p>
</li>
</ul>
<h4 id="六、使用场景"><a href="#六、使用场景" class="headerlink" title="六、使用场景"></a>六、使用场景</h4><h5 id="1、NSTimer-CADisplayLink"><a href="#1、NSTimer-CADisplayLink" class="headerlink" title="1、NSTimer/CADisplayLink"></a>1、NSTimer/CADisplayLink</h5><pre><code>NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];

//1、timer运行在NSDefaultRunLoopMode下，一旦RunLoop进入其他模式，timer不会工作
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];

//2、timer运行在NSRunLoopCommonModes集合中任何模式下，timer会工作
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];

//3、scheduledTimer返回的定时器，会自动被添加到当前runLoop中，默认是NSDefaultRunLoopMode
NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];

//4、创建并启动GCD定时器
_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));
dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0); //每秒执行
// 事件回调
dispatch_source_set_event_handler(_timer, ^{
    NSLog(@&quot;gcd timer......&quot;);
});
dispatch_resume(_timer);
</code></pre><p><strong>说明1</strong>：一般把NSTimer/CADisplayLink的RunLoop Mode选择NSRunLoopCommonModes集合，防止因列表滑动等导致NSTimer/CADisplayLink不工作；</p>
<p><strong>说明2</strong>：Timer注册到RunLoop后，如果所属线程中有耗时操作，Timer回调的时间点并不十分准确；CADisplayLink是屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，就可能丢帧，造成界面卡顿。</p>
<p><strong>说明3</strong>：如果希望比较准的定时器的效果。可以使用GCD的定时器。</p>
<h5 id="2、-常驻线程"><a href="#2、-常驻线程" class="headerlink" title="2、 常驻线程"></a>2、 常驻线程</h5><pre><code>+ (NSThread *)networkRequestThread {
  static NSThread *_networkRequestThread = nil;
  static dispatch_once_t oncePredicate;
  dispatch_once(&amp;oncePredicate, ^{
      _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
      [_networkRequestThread start];
  });
  return _networkRequestThread;
}

+ (void)networkRequestThreadEntryPoint:(id)__unused object {
  @autoreleasepool {
      [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];

      NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
      //添加端口，防止runloop直接退出
      [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
      [runLoop run];
  }
}
</code></pre><p><strong>说明</strong>：AF2.x维护一个常驻线程，用来发起网络请求，并且接受网络请求回调处理；NSURLSession有类似实现；在AF3.x后无常驻线程这部分代码了</p>
<h5 id="3、子线程执行PerformSelector-或-Timer"><a href="#3、子线程执行PerformSelector-或-Timer" class="headerlink" title="3、子线程执行PerformSelector 或  Timer"></a>3、子线程执行PerformSelector 或  Timer</h5><pre><code>//1、子线程执行performSelector
dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@&quot;befor&quot;);
        [self performSelector:@selector(printLog) withObject:nil afterDelay:0];
         //创建并启动Runloop，performSelector才有效
         [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
        NSLog(@&quot;after&quot;);
    });

- (void)p_logAction {
    NSLog(@&quot;p_logAction&quot;);
}

//2、子线程执行timer
 dispatch_async(dispatch_get_global_queue(0, 0), ^{

    [NSTimer scheduledTimerWithTimeInterval:0.1 repeats:YES block:^(NSTimer * _Nonnull timer) {
        NSLog(@&quot;timer in thread ...&quot;);
    }];
    //创建并启动Runloop，timer才有效
    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
});
</code></pre><p><strong>说明1</strong>：<strong>performSelector</strong>原理是：设置一个timer，添加到当前线程Runloop，默认是NSDefaultRunLoopMode；通过NSTimer的 scheduledTimerWithTimeIntervaly创建的定时器，也是自动被添加到当前RunLoop中，默认是NSDefaultRunLoopMode；</p>
<p><strong>说明2</strong>：<strong>在子线程中</strong>，因为默认没有RunLoop，所以他们<strong>不执行</strong>；想要执行，<strong>需要创建并启动Runloop</strong>。</p>
<h5 id="4、卡顿检测"><a href="#4、卡顿检测" class="headerlink" title="4、卡顿检测"></a>4、卡顿检测</h5><p><strong>监听主线程(UI线程)之间的耗时，如果发现</strong>kCFRunLoopEntry<strong>(即将进入)和</strong>kCFRunLoopExit<strong>(即将退出)之间耗时过大(大于10ms),认为卡顿发生；</strong></p>
<pre><code>- (void)setupRunloopObserver{

    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        CFRunLoopRef runloop = CFRunLoopGetCurrent();
        CFRunLoopObserverRef enterObserver;
        enterObserver = CFRunLoopObserverCreate(CFAllocatorGetDefault(),
                                               kCFRunLoopEntry | kCFRunLoopExit,
                                               true,
                                               0
                                               QSRunloopObserverCallBack, NULL);
        CFRunLoopAddObserver(runloop, enterObserver, kCFRunLoopCommonModes);
        CFRelease(enterObserver);
    });
}

static void QSRunloopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {
    switch (activity) {
        case kCFRunLoopEntry: {
            NSLog(@&quot;enter runloop...&quot;);
        }
            break;
        case kCFRunLoopExit: {
            NSLog(@&quot;leave runloop...&quot;);
        }
            break;
        default: break;
    }
}
</code></pre><p><strong>说明</strong>：如果发现卡顿，可以利用PLCrashReporter搜集各个线程的调用堆栈信息，上报到服务器,参考自<a href="http://mrpeak.cn/blog/ui-detect/" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a></p>
<h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4><p>想了解更多可参考<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/01/30/iOS-iOSMemory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/30/iOS-iOSMemory/" itemprop="url">OC对象内存小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T22:43:26+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS基础/" itemprop="url" rel="index">
                    <span itemprop="name">iOS基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,232 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><h5 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a>1、内存管理</h5><ul>
<li><p><strong>引用计数</strong>：每个OC对象都有引用计数(retaincount)、retaincount表明当前有多少个对象<strong>希望该对象存活</strong>；当对象的retaincount &gt; 0,对象存活；当对象的retaincount = 0,对象销毁；</p>
</li>
<li><p><strong>创建对象</strong>，retaincount至少为1；<strong>retain操作</strong>，retaincount加1；<strong>release操作</strong>，retaincount减1；<strong>autorelease操作</strong>，清理autorelease pool后，再递减retaincount；为了简化引用计数的管理，ARC应运而生。</p>
</li>
<li><p><strong>ARC</strong>（自动引用计数）通过编译器，在合适的地方插入<strong>retain、release和autorelease</strong>等操作；变量的内存管理通过<strong>修饰符(<strong>strong、</strong>weak、__autoreleasing)</strong>指明；以<strong>alloc、new、copy和mutableCopy</strong>方法名开头返回的对象归调用者所有。</p>
</li>
<li><p><strong>ARC只管理Objective-C对象的内存</strong>，CoreFoundation对象、CoreGraphics对象、还有C/C++的内存分配还是需要开发者自己管理。</p>
</li>
</ul>
<h5 id="2、内存空间说明"><a href="#2、内存空间说明" class="headerlink" title="2、内存空间说明"></a>2、内存空间说明</h5><p>内存空间主要包括：栈、堆、全局数据区、未初始化数据区 和 代码区</p>
<ul>
<li><p><strong>栈</strong>：编译器自动分配释放，存放函数的参数值，局部变量的值等，向低地址扩展，是一块连续的内存的区域<strong>。</strong>栈顶的地址 和 栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将出现栈溢出，发生未知错误。（栈空间较小）。</p>
</li>
<li><p><strong>堆</strong>：一般由程序员分配释放，<strong>向高地址扩展</strong>，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的。堆的大小受限于计算机系统中有效的虚拟内存。</p>
</li>
<li><p>堆获得的空间比较灵活，也比较大。 但是<strong>栈空间比堆空间响应速度更快，所以一般类似int、NSInteger等占用内存比较小的通常放在栈空间，对象一般放在堆空间</strong>。</p>
</li>
<li><p><strong>全局数据区</strong>(静态区)：存放 初始化的全局变量 和 静态变量，全局区的生命周期会伴随整个应用而存在，比较消耗内存</p>
</li>
<li><p><strong>未初始化数据区</strong>，亦称BSS区（uninitialized data segment），存入的是<strong>全局未初始化变量</strong></p>
</li>
<li><p><strong>代码区</strong>：存放二进制代码</p>
</li>
</ul>
<h5 id="3、Tagged-Pointer特性"><a href="#3、Tagged-Pointer特性" class="headerlink" title="3、Tagged Pointer特性"></a>3、Tagged Pointer特性</h5><ul>
<li><p>64bit 开始，iOS 引入了<strong>Tagged Pointer</strong>技术，用于优化NSNumber、NSDate、NSString等小对象的存储。</p>
</li>
<li><p>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值；</p>
</li>
<li><p>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。当指针不够存储数据时，会使用动态分配内存的方式来存储数据。</p>
</li>
</ul>
<h5 id="4、内存泄漏"><a href="#4、内存泄漏" class="headerlink" title="4、内存泄漏"></a>4、内存泄漏</h5><ul>
<li><p>Objective-C对象分配在内存的<strong>堆区</strong>，这部分内存需要开发者自己回收；如果没有释放，就造成<strong>内存泄漏</strong>；在ARC帮助下，当前内存泄漏最大可能是<strong>循环引用</strong>，导致对象的retaincount &gt; 0,系统无法回收这部分内存。</p>
</li>
<li><p>此外，CoreFoundation对象、CoreGraphics对象、还有C/C++的内存分配还是需要开发者自己管理，否则也会发生内存泄漏。</p>
</li>
<li><p><strong>循环引用</strong>，简单来说，就是堆内存中对象相互引用，彼此都得不到释放的机会；解决办法无非是使用<strong>弱引用</strong>；比较典型的场景有三：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、一般申明代理(delegate)为weak；</span><br><span class="line">2、使用weakSelf和strongSelf处理Block的循环引用；</span><br><span class="line">3、实现NSProxy(虚拟类)的子类，然后在子类中定义weak修饰的target，然后实现消息转发方法，使target处理业务逻辑；一般用于解决NSTimer、CADisplayLink的循环引用。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5、其他内存问题"><a href="#5、其他内存问题" class="headerlink" title="5、其他内存问题"></a>5、其他内存问题</h5><ul>
<li>高清图片解码、内存暴增，可以将大图裁成小图，然后分别加载显示；</li>
<li>添加NSNotification监听，记得在dealloc中移除。</li>
<li>捕获异常时，一定要注意把try块内创建的对象清理干净。</li>
</ul>
<h4 id="二、weak相关"><a href="#二、weak相关" class="headerlink" title="二、weak相关"></a>二、weak相关</h4><h5 id="1、weak的实现原理"><a href="#1、weak的实现原理" class="headerlink" title="1、weak的实现原理"></a>1、weak的实现原理</h5><p>Runtime维护一个<strong>weak表</strong>，用于存储执行某个对象的<strong>所有weak指针</strong>；Key是对象地址，Value是weak指针的地址数组；实现分三步：</p>
<ul>
<li><p><strong>初始化时</strong>，Runtime会调用<strong>objc_initWeak</strong>函数，初始化一个新的weak指针指向对象的地址；</p>
</li>
<li><p><strong>添加引用时</strong>，调用<strong>objc_storeWeak</strong>函数，更新指针指向，创建对应的弱引用表；</p>
</li>
<li><p><strong>释放时</strong>，调用<strong>clearDeallocating</strong>函数，根据对象地址获得所有weak指针地址数组，然后遍历这个数组把其中指针置为nil，把这组对应关系从weak表中删除。</p>
<p><strong>说明</strong>：详细可了解下<a href="http://ios.jobbole.com/89012/" target="_blank" rel="noopener">weak 弱引用的实现方式</a></p>
</li>
</ul>
<h5 id="2、assgin-VS-weak"><a href="#2、assgin-VS-weak" class="headerlink" title="2、assgin VS  weak"></a>2、assgin VS  weak</h5><ul>
<li><p>assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。 </p>
</li>
<li><p>assign也可以用来修饰对象，但是当assign修饰的对象在释放之后，指针没有被nil，如果后续如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。 </p>
</li>
<li><p>而weak修饰的对象在释放之后，指针地址会被置为nil。<strong>所以现在一般弱引用就是用weak</strong>。</p>
</li>
</ul>
<h5 id="3、unsafe-unretained-vs-weak"><a href="#3、unsafe-unretained-vs-weak" class="headerlink" title="3、unsafe_unretained  vs weak"></a>3、unsafe_unretained  vs weak</h5><ul>
<li><p>unsafe_unretained修饰的变量，不属于编译器的内存管理对象</p>
<p>该修饰符表明<strong>不保留值</strong>，即对其所指向的对象既不强引用，也不弱引用。</p>
</li>
<li><p>当我们给被unsafe_unretained修饰的变量赋值时，必须保证赋值对象确实存在，不然程序就会发生崩溃。</p>
</li>
<li><p>iOS5之后才有<strong>weak，可以替换</strong>unsafe_unretaine修饰对象，可以参考NotificationCenter在iOS 9之后不需要手动移除监听了。 </p>
</li>
</ul>
<h5 id="4、strong-vs-weak"><a href="#4、strong-vs-weak" class="headerlink" title="4、strong vs  weak"></a>4、strong vs  weak</h5><ul>
<li><p>strong表示强引用，strong修饰的对象，表示持有这个对象，只有所有对这个对象的强引用都去除时，这个对象才会被释放。</p>
</li>
<li><p>weak表示弱引用，表示不持有对象</p>
</li>
</ul>
<h5 id="5、iOS-9-以后通知不再需要手动移除"><a href="#5、iOS-9-以后通知不再需要手动移除" class="headerlink" title="5、iOS 9 以后通知不再需要手动移除"></a>5、iOS 9 以后通知不再需要手动移除</h5><p>​    iOS之前，通知 NSNotification 在注册者被回收时需要手动移除，但是iOS 9以后不需要手动移除，其原因如下：</p>
<ul>
<li><p>在iOS 9之前，通知中心持有的是注册者的 <strong>unsafe_unretained</strong> 指针<strong>，在注册者被回收时</strong>若不对通知进行手动移除，则指针指向被回收的内存区域，变为野指针。此时发送通知会造成 crash </p>
</li>
<li><p>在iOS 9之后，通知中心持有的是注册者的<strong>weak</strong> 指针，这时即使不对通知进行手动移除，指针也会在注册者被回收后自动置空。因为向空指针发送消息是不会有问题的。</p>
</li>
</ul>
<h4 id="三、Autoreleasepool（自动释放池）"><a href="#三、Autoreleasepool（自动释放池）" class="headerlink" title="三、Autoreleasepool（自动释放池）"></a>三、Autoreleasepool（自动释放池）</h4><h5 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h5><ul>
<li><p>AutoreleasePool是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。</p>
</li>
<li><p>App启动后，苹果在<strong>主线程 RunLoop</strong> 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
</li>
<li><p>第一个 Observer 监视的事件是 kCFRunLoopEntry(<strong>即将进入Loop</strong>)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
</li>
<li>第二个 Observer 监视了两个事件： kCFRunLoopBeforeWaiting(<strong>准备进入休眠</strong>) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() <strong>释放旧的池并创建新池</strong>；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来<strong>释放自动释放池</strong>。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li>
<li>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</li>
</ul>
<h5 id="2、Autoreleasepool日常使用"><a href="#2、Autoreleasepool日常使用" class="headerlink" title="2、Autoreleasepool日常使用"></a>2、Autoreleasepool日常使用</h5><ul>
<li><p>在没有手动添加自动释放池的情况下，autorelease对象<strong>会自动在当前的runloop迭代中加入自动释放池push和pop</strong>，在当前的runloop迭代结束时释放；如果加了，在添加自动释放池结束后，autorelease对象释放；</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autorealsepool&#123;</span><br><span class="line"> 	 //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们访问占内存大的对象，如果交于默认的 autoreleasepool 去管理生命周期，会有因为内存飙升产生crash的风险，比如访问realm对象，进行数据库增删查改操作时候，可以在操作代码外加上@autoreleasepool，保证退出@autoreleasepool作用域，该作用域内的变量占用的内存空间能释放出来。</p>
</li>
<li><p><strong>合理使用@autorealsepool，能降低内存峰值</strong>；如容器的block版本的枚举器时，内部会自动添加一个autoreleasepool（<em>普通for循环和for in循环中没有</em>）：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">   // 这里被一个局部@autoreleasepool包围着</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>  <strong>说明</strong>：详细可了解下<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></p>
</li>
</ul>
<h4 id="四、Block"><a href="#四、Block" class="headerlink" title="四、Block"></a>四、Block</h4><h5 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h5><ul>
<li><p>Block在C语言层面就是结构体，结构体存储了<strong>isa（Class对象的指针）</strong>、<strong>函数指针</strong>(invoke指针，指向块的实现)和<strong>捕获的变量列表</strong>等;</p>
</li>
<li><p>Block可以分配在<strong>栈上</strong>、<strong>堆上</strong>或<strong>全局</strong>上；<strong>栈上分配的Block</strong>，作用域结束后自动释放；<strong>堆上分配的Block</strong>，和Objective-C对象一样有引用计数了；<strong>全局分配的Block</strong>分配在全局内存中，不会被系统回收，相当于单例；</p>
</li>
<li><p>ARC开启时，会自动把栈上的Block拷贝到堆上；</p>
</li>
<li><p>Block捕获对象的时候会增加对象的引用计数。</p>
<p><strong>说明</strong>： <a href="http://blog.csdn.net/hello_hwc/article/details/70210549" target="_blank" rel="noopener">Objective C block背后的黑魔法</a></p>
</li>
</ul>
<h5 id="2、-block和-weak"><a href="#2、-block和-weak" class="headerlink" title="2、__block和__weak"></a>2、<code>__block</code>和<code>__weak</code></h5><ul>
<li><p><code>__block</code>是用来修饰一个<strong>变量</strong>，这个变量就可以在block中被修改 ，使用__block修饰的变量在block代码快中会被retain（ARC下，MRC下不会retain）</p>
</li>
<li><p><code>__weak</code>：使用__weak修饰的变量不会在block代码块中被retain </p>
</li>
<li><p>在ARC下，要避免block出现循环引用 __weak typedof(self)weakSelf = self;</p>
</li>
</ul>
<h5 id="3、-block在ARC和MRC下含义"><a href="#3、-block在ARC和MRC下含义" class="headerlink" title="3、__block在ARC和MRC下含义"></a>3、__block在ARC和MRC下含义</h5><ul>
<li>在MRC中<code>__block</code> variable在block中使用是不会retain的；但是ARC中__block則是会Retain的。</li>
</ul>
<h5 id="4、函数指针-VS-Block"><a href="#4、函数指针-VS-Block" class="headerlink" title="4、函数指针 VS  Block"></a>4、函数指针 VS  Block</h5><p><strong>相同点:</strong></p>
<ul>
<li><p>二者都可以看成是一个代码片段。</p>
</li>
<li><p>函数指针类型和 Block 类型都可以作为<strong>变量和函数参数</strong>的类型（typedef定义别名之后，这个别名就是一个类型）。</p>
</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>函数指针只能指向预先定义好的函数代码块，函数地址是在编译链接时就已经确定好的。从内存的角度看，函数指针只不过是指向代码区的一段可执行代码；</li>
<li>Block 本质是 OC对象，是 NSObject的子类，是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。</li>
</ul>
<h5 id="5、指针函数-VS-函数指针"><a href="#5、指针函数-VS-函数指针" class="headerlink" title="5、指针函数 VS 函数指针"></a>5、指针函数 VS 函数指针</h5><ul>
<li><strong>指针函数</strong>是指<strong>带指针的函数</strong>，即本质是一个函数，函数返回类型是某一类型的指针。它是一个函数，只不过这个函数的返回值是一个地址值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *f(x，y);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>函数指针</strong>是指向函数的指针变量，即本质是一个<strong>指针变量</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (*f) (int x); /*声明一个函数指针 */</span><br><span class="line">f = func; /* 将func函数的首地址赋给指针f */</span><br></pre></td></tr></table></figure>
<h4 id="五、发现循环引用"><a href="#五、发现循环引用" class="headerlink" title="五、发现循环引用"></a>五、发现循环引用</h4><p><em>有一定开发经验后，开发中可以避免绝大多数的循环引用问题，但是代码多了之后，不能保证代码中没有循环引用问题；</em>这时候就要靠工具了。</p>
<h5 id="1、Instrument"><a href="#1、Instrument" class="headerlink" title="1、Instrument"></a>1、Instrument</h5><ul>
<li><p>App内存中有三类：<strong>Abandoned memory</strong>、<strong>Leaked memory</strong>和<strong>Cached memory</strong>；有了ARC帮助管理内存，Leaked memory很少了，Leaks工具效果不大；</p>
</li>
<li><p>目前用得比较多的是<strong>Allocation</strong>，利用它观察在App运行中，业务相关类的创建和销毁情况。如进入底层页后退出，底层页相关的Controller、View等是否会销毁。</p>
</li>
<li><p>使用<strong>Allocation</strong>，需要一个个场景去跑，比较费时，但是可信度最高，可以作为其他方案补充；人力够的话，可以安排单人跑（<em>感觉有点奢侈</em>）。</p>
</li>
</ul>
<h5 id="2、MLeaksFinder"><a href="#2、MLeaksFinder" class="headerlink" title="2、MLeaksFinder"></a>2、<a href="https://github.com/Tencent/MLeaksFinder" target="_blank" rel="noopener">MLeaksFinder</a></h5><ul>
<li><p><em>微信阅读推出的内存泄漏检测工具</em>；它通过利用Method Swizzling，<strong>hook</strong> 掉 UIViewController 和 UINavigationController 的dismiss和pop方法，当对象即将释放时，调用<strong>willDealloc</strong>方法; 该方法先用一个弱指针指向 self，并在一小段时间(2秒)后，通过这个弱指针调用<strong>assertNotDealloc</strong>，而<strong>assertNotDealloc</strong>主要是利用<strong>FBRetainCycleDetector</strong>找出<strong>循环引用链</strong>，以此定位循环引用的位置。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;</span><br><span class="line"></span><br><span class="line"> 	// 白名单机制，消除某些场景的内存泄漏警告...（略）</span><br><span class="line">   	  __weak id weakSelf = self;</span><br><span class="line">    	 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">         	__strong id strongSelf = weakSelf;</span><br><span class="line">         	[strongSelf assertNotDealloc];</span><br><span class="line">     	&#125;);</span><br><span class="line">     	return YES;</span><br><span class="line">  	 &#125;</span><br><span class="line"></span><br><span class="line">- (void)assertNotDealloc &#123;</span><br><span class="line"></span><br><span class="line"> 	if ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[self parentPtrs]]) &#123;</span><br><span class="line">  	   return;</span><br><span class="line">   	&#125;</span><br><span class="line">    //检查循环引用链</span><br><span class="line">    [MLeakedObjectProxy addLeakedObject:self];</span><br><span class="line">    //输出日志...（略）</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有可能误判的情形，</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>场景</th>
<th>解决</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>单例和Cache 起来复用的 View 或 ViewController</strong></td>
<td>可以将willDealloc返回NO，以消除内存泄漏的警告。</td>
</tr>
<tr>
<td>2</td>
<td><strong>释放不及时的 View 或 ViewController</strong></td>
<td>可能是网络请求返回慢的原因，可以在网络请求回调的 block 里弱引用 ViewController（比较合理）</td>
</tr>
</tbody>
</table>
<p>  <strong>说明</strong>：具体可以参考<a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/" target="_blank" rel="noopener">MLeaksFinder：精准 iOS 内存泄露检测工具</a>、<a href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/" target="_blank" rel="noopener">MLeaksFinder 新特性</a></p>
<h5 id="3、FBMemoryProfiler"><a href="#3、FBMemoryProfiler" class="headerlink" title="3、FBMemoryProfiler"></a>3、<a href="https://github.com/facebook/FBMemoryProfiler" target="_blank" rel="noopener">FBMemoryProfiler</a></h5><ul>
<li><p>Facebook发布的内存检查工具，FBMemoryProfiler包括<strong>FBAllocationTracker</strong> 、 <strong>FBRetainCycleDetector</strong>和 <strong>UI界面</strong>。</p>
</li>
<li><p><strong>FBAllocationTracker</strong>利用Method Swizzling 替换原本的 alloc 方法，记录检测所有的实例分配；而<strong>FBRetainCycleDetector</strong>用来递归遍历对象中的所有强引用的对象，以检测以该对象为根结点的强引用树有没有循环引用。</p>
</li>
<li><p><strong>FBMemoryProfiler</strong> 除了可以手动调试之外，它还可以进行自动化检测。 通过它内置的两个组件 FBRetainCycleDetector 和 FBAllocationTracker，直接检测出内存中的循环引用，然后把数据发送到自己的服务器上，可以形成一个自动化检测系统。 </p>
<p><strong>说明</strong>：详细了解可见<a href="https://code.facebook.com/posts/583946315094347/automatic-memory-leak-detection-on-ios/" target="_blank" rel="noopener">automatic-memory-leak-detection-on-ios</a></p>
</li>
</ul>
<h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><ul>
<li>保持良好编程习惯的同时，搭配工具来及时纠错；推荐<strong>MLeaksFinder + Instrument</strong> 或 <strong>FBMemoryProfiler + Instrument</strong>组合使用。通过MLeaksFinder/FBMemoryProfiler发现后。然后使用Instrument再验证下。</li>
</ul>
<h4 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h4><h5 id="1、对象的深浅拷贝问题"><a href="#1、对象的深浅拷贝问题" class="headerlink" title="1、对象的深浅拷贝问题"></a>1、对象的深浅拷贝问题</h5><ul>
<li>浅拷贝：对象的引用复制，指向相同的一块内存空间</li>
<li>深拷贝：拷贝对象本身，系统会随机给拷贝的对象重新分配一块内存，深拷贝以后，<code>两份对象的内存地址不一样，指针指向也不一样</code>。</li>
<li>可变对象的 的copy和mutableCopy 都是深拷贝</li>
<li>不可变对象的 copy是 浅拷贝。不可变对象的 mutableCopy是深拷贝</li>
<li>自定义类需要分别遵守 <nscopying>协议和<nsmutablecopying>协议，分别实现copyWithZone方法和mutableCopyWithZone方法，实现该类对象的copy和mutableCopy操作, 否则会无法响应copy和mutableCopy消息(<strong>unrecognized selector sent to instance</strong>)</nsmutablecopying></nscopying></li>
</ul>
<h5 id="2、内联函数的问题"><a href="#2、内联函数的问题" class="headerlink" title="2、内联函数的问题"></a>2、内联函数的问题</h5><ul>
<li>内联函数关键字是 <strong>inline</strong> ，普通函数使用的申明或实现使用<strong>inline</strong> 修饰后，即为内联函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline int sum(int a, int b)&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意：递归函数即使被 <strong>inline</strong> 修饰后也不是内联函数，依然是普通函数。</p>
</li>
<li><p>普通函数调用会<strong>开辟一段栈空间</strong>执行相关代码，函数执行完再将对应的栈空间回收。而内联函数调用中，编译器会<strong>将函数调用直接展开为函数代码</strong>。如cout &lt;&lt; sum(1, 2) &lt;&lt; endl会直接转换为cout &lt;&lt; 1 + 2&lt;&lt; endl，由此可见内联函数和一般的宏很类似，都是<strong>直接替换相关代码</strong>。同宏相比，内联函数只是多了一些函数特性和语法检测功能。</p>
</li>
<li><p>OC 中可以通过关键字 NS_INLINE 使用内联函数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NS_INLINE void log(int value) &#123;</span><br><span class="line">    NSLog(@&quot;%d&quot;, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>内联函数或宏省去了</strong> <strong>参数压栈、生成汇编语言的CALL调用、返回参数、执行return等</strong> <strong>过程</strong>，可以<strong>减少函数调用的开销。但是会增加代码体积</strong>，所以减少内联函数或宏的使用一定程度上可以减少包体积。 并不是说为了减小包体积完全不去使用内联函数，建议经常会被调用的代码，且代码量不是很多的时候(不超过10行)，为减少函数调用的开销，可适当使用内联函数。</li>
</ul>
<h5 id="3、-import和-include区别"><a href="#3、-import和-include区别" class="headerlink" title="3、#import和#include区别"></a>3、#import和#include区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import与#include的类似，都是把其后面的文件拷贝到该指令所在的地方</span><br><span class="line">#import可以自动防止重复导入</span><br><span class="line">#import &lt;&gt; 用于包含系统文件</span><br><span class="line">#import&quot;&quot;用于包含本项目中的文件</span><br><span class="line">#import, 告诉编译器找到并处理名为Foundation.h文件,这是一个系统文件,</span><br><span class="line">#import表示将该文件的信息导入到程序中</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/01/28/iOS-AppLaunchOptimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/28/iOS-AppLaunchOptimize/" itemprop="url">启动优化小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-28T17:22:36+08:00">
                2018-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/App优化/" itemprop="url" rel="index">
                    <span itemprop="name">App优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,073 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前iOS优化主要包括三方面：<strong>卡顿优化</strong>、<strong>启动优化</strong>和<strong>瘦身优化</strong>，本文简单说下<strong>启动优化</strong></p>
<h4 id="一、启动时间"><a href="#一、启动时间" class="headerlink" title="一、启动时间"></a>一、启动时间</h4><ul>
<li><p>如果你的App启动超过20s，是时候考虑换个工作了(<em>开个玩笑</em>)；启动优化是<strong>基于当下的业务复杂度和代码复杂度的近似最优处理</strong>。</p>
</li>
<li><p><strong>App总启动时间</strong> = t1(main函数之前的加载时间) + t2(main函数之后的加载时间)</p>
</li>
<li><p><strong>t1</strong> = 系统dylib(动态链接库)和自身App可执行文件的加载时间</p>
</li>
<li><strong>t2</strong> = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</li>
</ul>
<h4 id="二、main函数之前的优化"><a href="#二、main函数之前的优化" class="headerlink" title="二、main函数之前的优化"></a>二、main函数之前的优化</h4><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><ul>
<li><p><strong>加载过程</strong>：先加载<strong>可执行文件</strong>；然后<strong>加载dyld</strong>(dynamic link editor)动态链接器；最后dyld从可执行文件的依赖开始，递归加载所有依赖的动态链接库。</p>
</li>
<li><p><strong>动态链接库</strong>包括：系统的framework、加载OC Runtime的libobjc、系统级别的libSystem、如libdispatch(GCD)和libsystem_blocks(Block)。</p>
</li>
<li><p><strong>Apple不允许使用自己的动态库</strong>，否则无法过审；只能选择<strong>静态库</strong>的方式，第三方登录、分享都使用该类方式；链接时会被完整的复制到可执行文件中；</p>
</li>
<li><p>相比<strong>静态库</strong>而言，<strong>动态链接库</strong>在程序运行时才记载到内存，不会增加可执行文件的体积，但是会增加加载时间；而<strong>静态库</strong>虽然有利于优化加载速度，但是会增加包的体积。</p>
</li>
</ul>
<h5 id="2、main之前做了什么"><a href="#2、main之前做了什么" class="headerlink" title="2、main之前做了什么"></a>2、main之前做了什么</h5><ul>
<li><p><strong>load dylibs image</strong>: 读取库静态文件</p>
</li>
<li><p><strong>rebase/bind image</strong>: 修复镜像中的资源指针，来指向正确的地址。rebase修复的是镜像内部的资源指针，bind指向的是镜像外部的资源指针；</p>
</li>
<li><p><strong>objc setup</strong>:注册objc类；将category的定义插入方法列表；保证selector的唯一；</p>
</li>
<li><p><strong>initializers</strong>:动态调整，执行load函数，C+++构造函数属性函数，非基本类型的C++静态全局变量的创建</p>
</li>
</ul>
<h5 id="3、优化思路"><a href="#3、优化思路" class="headerlink" title="3、优化思路"></a>3、优化思路</h5><ul>
<li><p>减少不必要的framework，因为动态链接比较耗时；</p>
</li>
<li><p>检查framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查；</p>
</li>
<li><p>合并或者删减一些OC类；删减一些无用的静态变量；删减没有被调用到或者已经废弃的方法；</p>
</li>
<li><p>将不必须在+load方法中做的事情延迟到+initialize中；</p>
</li>
<li><p>尽量不要用C++虚函数(创建虚函数表有开销)；</p>
</li>
</ul>
<h5 id="4、耗时衡量"><a href="#4、耗时衡量" class="headerlink" title="4、耗时衡量"></a>4、耗时衡量</h5><ul>
<li><p>Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS 设为 1</p>
</li>
<li><p>Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS_DETAILS 设为 1，可以看到更多数据</p>
</li>
</ul>
<h4 id="三、main函数之后的优化"><a href="#三、main函数之后的优化" class="headerlink" title="三、main函数之后的优化"></a>三、main函数之后的优化</h4><h5 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h5><ul>
<li>这部分主要是服务初始化、闪屏（广告或引导）和首页UI渲染等工作；</li>
</ul>
<h5 id="2、优化思路"><a href="#2、优化思路" class="headerlink" title="2、优化思路"></a>2、优化思路</h5><ul>
<li><p><strong>视图</strong>：使用代码创建首页视图。</p>
</li>
<li><p><strong>服务初始化</strong>：团队间沟通优化业务逻辑，如，延迟某些服务的初始化；合并某些网络请求或减少启动时网络请求个数；</p>
</li>
<li><p><strong>其他</strong>：减少NSLog输出，因为其会隐似创建个NSCalender，比较耗时；网络请求和数据读取等耗时操作放在子线程；图片子线程解码等。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>一个比较靠谱团队，启动这块耗时不会太糟糕，动不动就优化效果显著，要么是太牛逼，要么是团队太坑；做启动优化这块，需要平常心和耐心。</p>
</li>
<li><p><strong>main函数之后优化空间比较大，主要在业务上</strong>；所以要先需要熟悉业务，优化之前和各方沟通好，如XX提供的SDK能否延迟初始化，XXX效果设计团队能否接受；XXXX处理会不会给其他团队人员的工作带来困扰….</p>
</li>
<li><p>网络上有很多团队分享了启动优化经验，大都是基于自身业务特点的优化总结；想系统了解，还是推荐看看<a href="https://techblog.toutiao.com/2017/01/17/iosspeed/" target="_blank" rel="noopener">今日头条iOS客户端启动速度优化</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/01/26/iOS-AppFPSOptimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/26/iOS-AppFPSOptimize/" itemprop="url">卡顿优化小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-26T23:23:05+08:00">
                2018-01-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/App优化/" itemprop="url" rel="index">
                    <span itemprop="name">App优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,684 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前iOS优化主要包括三方面：<strong>卡顿优化</strong>、<strong>启动优化</strong>和<strong>瘦身优化</strong>，本文简单说下<strong>卡顿优化</strong>。</p>
<h4 id="一、卡顿"><a href="#一、卡顿" class="headerlink" title="一、卡顿"></a>一、卡顿</h4><h5 id="1、简述"><a href="#1、简述" class="headerlink" title="1、简述"></a>1、简述</h5><ul>
<li><p>iOS设备使用双缓存，以<strong>60HZ</strong>的频率刷新屏幕，这就意味着，在<strong>1/60s(16.67ms)</strong>内要将完成<strong>下一帧</strong>的图片的绘制，并存在缓存区中；</p>
</li>
<li><p>在这1/60s(16.67ms)内，<strong>CPU要计算显示内容</strong>，然后将这些内容交给<strong>GPU去变换、合成和渲染</strong>，GPU把渲染后的内容提交到帧缓存区，等待更新信号；</p>
</li>
<li><p>如果在1/60s(16.67ms)不能完成这些工作，这帧内容就会被丢弃，显示屏还保存之前的内容，也就是常说的<strong>丢帧</strong>了，这也是<strong>卡顿的原因</strong>。</p>
</li>
<li><p>简单说，卡顿优化就是为了，<strong>优化CPU和GPU的使用情况</strong>。</p>
</li>
</ul>
<h5 id="2、卡顿监控"><a href="#2、卡顿监控" class="headerlink" title="2、卡顿监控"></a>2、卡顿监控</h5><ul>
<li><p><strong>主线程卡顿监控</strong>。通过子线程监测主线程的 RunLoop，判断两个状态区域之间的耗时是否达到一定阈值，发现卡顿还可以抓取堆栈信息，上报到服务器，便于准确定位和优化。</p>
</li>
<li><p><strong>FPS监控</strong>，利用CADisplayLink(和屏幕刷新频率相同)，过记录两次刷新时间间隔，计算出当前的 FPS。</p>
<p><strong>说明</strong>：卡顿监控很有意义，要么自己做，要么用第三方的，如腾讯的bugly。</p>
<p>参考：<a href="http://mrpeak.cn/blog/ui-detect/" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a></p>
</li>
</ul>
<h4 id="二、CPU方面优化"><a href="#二、CPU方面优化" class="headerlink" title="二、CPU方面优化"></a>二、CPU方面优化</h4><p>CPU做计算显示的内容，主要包括：视图创建、视图布局、图片解码、文本绘制、图像绘制等。</p>
<h5 id="1、视图创建"><a href="#1、视图创建" class="headerlink" title="1、视图创建"></a>1、视图创建</h5><ul>
<li><p><strong>对象复用</strong>，复用对象的代价比创建新对象的成本要低；比较典型的是：<strong>UITableViewCell对象的复用</strong>，需要UITableViewCell对象，先从缓存池取，如果取不到，才去创建新对象；</p>
</li>
<li><p><strong>选择轻量级对象</strong>：不响应触摸事件的视图，不使用UIView，优先使用CAShapeLayer(硬件加速、渲染快）。</p>
</li>
<li><p><strong>数据对象的缓存</strong>：比较典型的是，解码图像的缓存和cell高度的缓存；前者避免图片重复解码，后者避免Cell高度重复计算。</p>
</li>
</ul>
<h5 id="2、视图布局"><a href="#2、视图布局" class="headerlink" title="2、视图布局"></a>2、视图布局</h5><ul>
<li><p>不使用Autolayout（布局计算在主线程），视图复杂后，性能不佳；可以使用代码创建View，使用frame布局；要注意<strong>frame值要取整</strong>，避免像素不对齐；</p>
</li>
<li><p>尽量减少视图的数量、层级数量、层级调整、视图添加和删除操作；</p>
</li>
<li><p>尽量减少不必要的属性修改，如CALayer相关的属性(如frame、bounds、transform、center等），修改会引起隐式动画。</p>
</li>
</ul>
<h5 id="3、图片解码"><a href="#3、图片解码" class="headerlink" title="3、图片解码"></a>3、图片解码</h5><ul>
<li>子线程解码图片，然后在主线程展示解码后的位图（位图结果记得缓存）。</li>
</ul>
<h5 id="4、文本绘制"><a href="#4、文本绘制" class="headerlink" title="4、文本绘制"></a>4、文本绘制</h5><ul>
<li><strong>文本的宽高计算和绘制</strong>会占用资源，可以在子线程计算和绘制，然后在主线程显示；这适用于大量文本显示的处理，如果只是2-3行文本显示，没必要选择这么做。</li>
</ul>
<h5 id="5、图像绘制"><a href="#5、图像绘制" class="headerlink" title="5、图像绘制"></a>5、图像绘制</h5><ul>
<li><p>图片的绘制可以放到子线程中做，因为CG绘制是线程安全的；将图片绘制到画布上，然后将图片显示到视图中。</p>
<p><strong>总结</strong>：因为<strong>主线程占用CPU高、子线程占用CPU低</strong>；优化时，把不是必须要在主线程中做的事情 放在子线程中做，但是要防止线程爆炸，参考<a href="https://www.jianshu.com/p/5d51a367ed62" target="_blank" rel="noopener">GCD小结之控制最大并发数</a>。</p>
</li>
</ul>
<h4 id="三、GPU方面优化"><a href="#三、GPU方面优化" class="headerlink" title="三、GPU方面优化"></a>三、GPU方面优化</h4><p>GPU接收提交的纹理(Texture) 和顶点数据信息，应用变换(transform)、混合并渲染等，然后输出到屏幕上。</p>
<h5 id="1、纹理的渲染"><a href="#1、纹理的渲染" class="headerlink" title="1、纹理的渲染"></a>1、纹理的渲染</h5><ul>
<li><p>GPU的消耗主要在：所有Bitmap由内存提交到显存、绑定为GPU Texture；GPU的调整；渲染Texture等。尽量避免短时间显示大量图片，否则会造成CPU使用率低，而GPU使用率飙升；可以合成多张图片，做一张显示。</p>
</li>
<li><p>尽量避免图片过大，超过GPU的最大纹理尺寸，需要CPU进行预处理，带来CPU和GPU的格外消耗。在网络环境中，遇到下载特大高清图时，SDWebImage的处理是，<strong>将大的原图裁剪成指定大小的小图，然后拼成大图</strong> 思路类似异步绘制内容的图层CATiledLayer，不加载全部图片，而是将大图分解成小图片，然后再载入显示。</p>
</li>
</ul>
<h5 id="2、视图混合"><a href="#2、视图混合" class="headerlink" title="2、视图混合"></a>2、视图混合</h5><ul>
<li><p><strong>尽量减少视图的数量和层级</strong>，多视图叠加在一起显示时，GPU需要混合计算，视图的数量和层级越深，GPU的消耗越大；</p>
</li>
<li><p>视图尽量<strong>不使用透明的背景色</strong>，避免像素混合计算(视图默认不透明 opaque=YES)；尽量<strong>使用不透明的图片</strong>，避免像素混合计算</p>
</li>
<li><p>UILabel显示中文时，记得<strong>masksToBounds = YES</strong>，避免混合计算</p>
</li>
</ul>
<h5 id="3、离屏渲染"><a href="#3、离屏渲染" class="headerlink" title="3、离屏渲染"></a>3、离屏渲染</h5><ul>
<li><p>GPU屏幕渲染分为当前<strong>屏幕渲染</strong>(On-Screen Rendering)和<strong>离屏渲染</strong>(Off-Screen Rendering)，<strong>离屏渲染</strong>需要在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作，其中涉及到的<strong>创建新缓冲区</strong>、<strong>上下文切换</strong>都很消耗GPU资源。</p>
</li>
<li><p>容易触发离屏渲染最多的四个场景，<strong>圆角处理</strong>（RoundCorner）、<strong>阴影处理</strong>(Shadow)、<strong>遮罩</strong>(Mask)和Group Opacity（组不透明）；</p>
</li>
<li><p><strong>圆角处理</strong>可以采用绘制方式，可以参考<a href="https://www.jianshu.com/p/a38a7c7bccbb" target="_blank" rel="noopener">网络图片的优化显示</a>；<strong>阴影处理</strong>可以通过设置shadowPath来避免；Mask没啥好办法; GroupOpacity处理是<strong>关闭layer的allowsGroupOpacity 属性</strong>；</p>
</li>
<li><p><strong>离屏渲染不可避免情况下</strong>，设置<strong>shouldRasterize=YES</strong>（启动光栅化)，可以将layer光栅化为Bitmap, layer的阴影等效果也会被缓存到Bitmap中，减少离屏渲染次数，减少GPU消耗。</p>
</li>
</ul>
<p><strong>说明</strong>：还有种<strong>CPU渲染</strong>的说法，重写了drawRect方法，或使用Core Graphics绘制都会触发；虽然其性能可能还不如GPU的离屏渲染，但是可以在子线程中做CPU渲染，然后在主线程显示。</p>
<h5 id="4、像素不对齐"><a href="#4、像素不对齐" class="headerlink" title="4、像素不对齐"></a>4、像素不对齐</h5><ul>
<li>图片显示前，在子线程中可以按目标显示大小裁剪，使图片符合展示大小，避免拉伸缩放(像素不对齐)。</li>
</ul>
<h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><ul>
<li><p>优化工作视具体业务来做，没必要过早优化；</p>
</li>
<li><p>如果没做过优化方面工作的同学，可以仔细阅读<strong>ibireme</strong>的<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a>，后续很多团队的分享经验都没有跳出ibireme的框架。</p>
</li>
<li><p>iOS图片优化是个值得注意的点，不管是在卡顿优化、还是在App瘦身，可以参考我的一点见解<a href="https://buaa0300.github.io/2018/01/13/imageOptimize/" target="_blank" rel="noopener">浅谈iOS图片优化</a>。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/01/14/iOS-FLAnimatedImage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/14/iOS-FLAnimatedImage/" itemprop="url">速览FLAnimatedImage库笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-14T12:05:17+08:00">
                2018-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS第三方库/" itemprop="url" rel="index">
                    <span itemprop="name">iOS第三方库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,023 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>FLAnimatedImage库很不错，分享下我的学习笔记</p>
<blockquote>
<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote>
<ul>
<li><p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>处理网络GIF播放，是在<a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>基础上做的。</p>
</li>
<li><p><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>就主要的类是：<strong>FLAnimatedImage类</strong>和<strong>FLAnimatedImageView类</strong>。<strong>FLAnimatedImage</strong>看做个生产者，负责将GIF图片转换成一帧帧图片，提供给<strong>FLAnimatedImageView</strong>；后者可以看做是消费者，将一帧帧图片刷新显示到屏幕中。</p>
</li>
<li><p><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage库</a>中涉及一些<strong>线程安全</strong>、<strong>weakProxy</strong>、<strong>内存警告处理</strong>还是很值得借鉴的。</p>
</li>
</ul>
<blockquote>
<h4 id="二、FLAnimatedImage-类"><a href="#二、FLAnimatedImage-类" class="headerlink" title="二、FLAnimatedImage 类"></a>二、FLAnimatedImage 类</h4></blockquote>
<p>重要的两个方法，分别是<strong>initWithAnimatedGIFData:方法</strong> 和  <strong>imageLazilyCachedAtIndex:方法</strong></p>
<h5 id="1、initWithAnimatedGIFData-方法"><a href="#1、initWithAnimatedGIFData-方法" class="headerlink" title="1、initWithAnimatedGIFData: 方法"></a>1、initWithAnimatedGIFData: 方法</h5><ul>
<li><p>其一、获取<strong>GIF图片的信息</strong>，包括图片大小、图片帧数、首帧图片、每帧图片的属性信息(播放时间)、循环播放次数，最大缓存帧个数等。其中<strong>最大缓存帧个数</strong>是根据图片大小获得 或者 手动指定。</p>
</li>
<li><p>其二、设置个弱代理(weakProxy)，用来<strong>防止循环引用</strong>用的。</p>
</li>
<li><p>其三、将自己添加<strong>allAnimatedImagesWeak</strong>对象中（添加操作使用@synchronized保证线程安全），这是一个NSHashTable对象，当哈希表中的FLAnimatedImage对象的引用计数是0时，表中会清除该对象。</p>
<p><strong>说明</strong>：线程同步中，一说<strong>同步锁</strong>，很多人直觉反应，性能最差，不用；但是FLAnimatedImage库和SDWebImage都在用，应该是其<strong>使用方便</strong>所致；其本身实现很有意思，利用对象的内存地址去获取互斥锁；还添加了异常处理，如果同步某对象抛出异常时，还会释放掉锁。</p>
</li>
</ul>
<h5 id="2、imageLazilyCachedAtIndex-方法"><a href="#2、imageLazilyCachedAtIndex-方法" class="headerlink" title="2、imageLazilyCachedAtIndex:方法"></a>2、imageLazilyCachedAtIndex:方法</h5><ul>
<li><p>通过<strong>imageLazilyCachedAtIndex:方法</strong>将帧每一帧图片给FLAnimatedImageView对象展示。</p>
</li>
<li><p>根据<strong>当前的帧号</strong>(index)和<strong>当前缓存帧数</strong>(frameCacheSizeCurrent)获取接下来需要缓存的帧图片，并异步绘制出位图，并保存在内存缓存中。</p>
<p><strong>说明</strong>：都是提前绘制后面需要展示的图片，第一帧图片在init方法时就获得了。</p>
</li>
</ul>
<h5 id="3、内存警告的处理"><a href="#3、内存警告的处理" class="headerlink" title="3、内存警告的处理"></a>3、内存警告的处理</h5><ul>
<li><p>位图比较大，将位图缓存在内存中，即使FLAnimatedImage做了优化，当时GIF较大，或多张GIF同时播放，内存的压力会很大，很大概率收到内存警告。</p>
</li>
<li><p><strong>allAnimatedImagesWeak</strong>保存所有的FLAnimatedImage对象，收到内存警告时，通知所有FLAnimatedImage对象，当前只允许缓存一帧图片；如果接下来没有新的内存警告，慢慢恢复到定义的缓存的图片帧数；但是如果内存警告次数超过三次，以后只能缓存一帧图片。</p>
</li>
<li><p>在内存警告处理中，使用了些<strong>延迟执行</strong>的方法，防止循环引用，使用了弱代理(weakProxy)。</p>
</li>
<li><p>weakProxy是FLWeakProxy 对象；FLWeakProxy是NSProxy类子类，持有一个 weak 对象的代理，利用消息转发机制将消息的处理交给weak 对象；用来避免循环引用的一种方法，具体可以看我之前写的<a href="https://www.jianshu.com/p/5068b6f02238" target="_blank" rel="noopener">解决NSTimer/CADisplayLink的循环引用</a>。</p>
</li>
</ul>
<blockquote>
<h4 id="三、FLAnimatedImageView"><a href="#三、FLAnimatedImageView" class="headerlink" title="三、FLAnimatedImageView"></a>三、FLAnimatedImageView</h4></blockquote>
<h5 id="1、CADispalyLink"><a href="#1、CADispalyLink" class="headerlink" title="1、CADispalyLink"></a>1、CADispalyLink</h5><ul>
<li><p>CADispalyLink是个和屏幕刷新率相同的定时器，将帧图片刷新显示在屏幕上。</p>
</li>
<li><p>使用FLWeakProxy这类弱引用代理，打破循环引用；</p>
</li>
<li><p>多个处理器情况下，CADispalyLink对象默认以NSRunLoopCommonModes添加到Runloop上，避免因为列表滑动不刷新显示。</p>
</li>
<li><p>CADispalyLink的刷新时间是：每帧图片播放时间的最大公约数；因为不能保证每帧图片的播放时间是一样的，取他们的最大公约数，使得每一帧都尽可能获得其播放时间。当然也可以暴力使用平均停留时间作为CADispalyLink的刷新时间。</p>
</li>
</ul>
<blockquote>
<h4 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h4></blockquote>
<ul>
<li><p>这是之前阅读FLAnimatedImage库的笔记整理，一是本着学习的目的，二是为了评估 <strong>在列表页缩放裁剪播放n张GIF图的需求</strong>的可行性；</p>
</li>
<li><p>将<strong>GIF图片的裁剪和合成小GIF图</strong>的重任交给客户端，本身就很冒险；裁剪过程中，GIF图片的帧数多，GIF图片多，对内存的挑战是很大的，在列表中下发小的GIF图播放比较好（后台表示压力大）。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/01/13/iOS-GenerateCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/iOS-GenerateCode/" itemprop="url">代码自动生成笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T20:05:09+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS实践/" itemprop="url" rel="index">
                    <span itemprop="name">iOS实践</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,424 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS开发中，使用脚本语言(Ruby或Python)生成些Objective-C代码，提高代码生产力。</p>
<blockquote>
<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4></blockquote>
<ul>
<li><p>使用脚本生成简单的Objective-C代码，这件工作并不复杂；</p>
</li>
<li><p>先介绍<strong>Xcode自动运行脚本相关设置</strong>和 <strong>自动添加类文件到项目</strong>；</p>
</li>
<li><p>最后介绍一个使用Ruby生成Objective-C代码的<strong>实例</strong>；</p>
</li>
</ul>
<blockquote>
<h4 id="二、Xcode自动运行脚本"><a href="#二、Xcode自动运行脚本" class="headerlink" title="二、Xcode自动运行脚本"></a>二、Xcode自动运行脚本</h4></blockquote>
<p><strong>目标</strong>：在运行项目时自动运行脚本。考虑到可能在项目中引入比较多的脚本，建议在项目的根路径下新建一个存放脚本的文件夹；在这个文件夹中，集中管理脚本。推荐两个比较常见的设置自动运行脚本的办法。</p>
<h5 id="方法1：External-Build-System-外部编译系统"><a href="#方法1：External-Build-System-外部编译系统" class="headerlink" title="方法1：External Build System(外部编译系统)"></a>方法1：External Build System(外部编译系统)</h5><p>具体步骤分为以下 5 步</p>
<h6 id="1）新建External-Build-System"><a href="#1）新建External-Build-System" class="headerlink" title="1）新建External Build System"></a>1）新建External Build System</h6><p>在工程下添加一个<strong>target</strong>：选择Cross-platform &gt; Other &gt; External Build System，取名为CodeGenerator。</p>
<h6 id="2）新建shell脚本文件"><a href="#2）新建shell脚本文件" class="headerlink" title="2）新建shell脚本文件"></a>2）新建shell脚本文件</h6><p>在工程的根路径下新建一个<strong>ToolScripts</strong>文件夹，新建脚本文件，名为start.sh</p>
<h6 id="3）设置CodeGenerator"><a href="#3）设置CodeGenerator" class="headerlink" title="3）设置CodeGenerator"></a>3）设置CodeGenerator</h6><p>选择Targets &gt; CodeGenerator &gt;Info &gt; External Build Tool Configuration，<strong>Build Tools</strong>中填入start.sh所在的路径；<strong>Directory</strong>中填入存放所有脚本的文件夹，本例中是ToolScripts所在的位置。如果编译失败，请检查这里Directory的设置，修改成对应的位置。</p>
<h6 id="4）添加运行依赖"><a href="#4）添加运行依赖" class="headerlink" title="4）添加运行依赖"></a>4）添加运行依赖</h6><p>选择Targets &gt; QSRunScriptDemo &gt; Build Phase &gt; Target Dependencies,添加运行依赖。</p>
<h6 id="5）编译运行"><a href="#5）编译运行" class="headerlink" title="5）编译运行"></a>5）编译运行</h6><p>编译运行，选择Show the report navigator -&gt; build，可以看到对应的日志输出。</p>
<h5 id="方法2：项目中直接添加脚本执行"><a href="#方法2：项目中直接添加脚本执行" class="headerlink" title="方法2：项目中直接添加脚本执行"></a>方法2：项目中直接添加脚本执行</h5><p>具体步骤分为以下 4 步</p>
<h6 id="1）新建shell脚本文件"><a href="#1）新建shell脚本文件" class="headerlink" title="1）新建shell脚本文件"></a>1）新建shell脚本文件</h6><p>在工程的根路径下新建一个<strong>ToolScripts</strong>文件夹，新建脚本文件，名为start.sh，这步骤和方法1一样。</p>
<h6 id="2）添加Run-Script"><a href="#2）添加Run-Script" class="headerlink" title="2）添加Run Script"></a>2）添加Run Script</h6><p>选择Targets &gt; QSRunScriptDemo &gt; Build Phase中添加 New Run Script Phase 即可。</p>
<h6 id="3）设置Run-Script"><a href="#3）设置Run-Script" class="headerlink" title="3）设置Run Script"></a>3）设置Run Script</h6><p>在Run Script中设置执行start.sh命令即可。</p>
<h6 id="4）编译运行"><a href="#4）编译运行" class="headerlink" title="4）编译运行"></a>4）编译运行</h6><p>编译运行，选择Show the report navigator -&gt; build，可以看到对应的日志输出。</p>
<h5 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h5><ul>
<li><p>我们并没有直接设置<strong>执行Ruby 或 Python 代码</strong>，是因为这两类脚本可能并存在项目中，编译前执行shell脚本，在shell脚本中定义执行Ruby 或 Python脚本。</p>
</li>
<li><p>接下来介绍如何将生成的类文件自动添加到项目中。</p>
</li>
</ul>
<blockquote>
<h4 id="三、自动添加类文件到项目"><a href="#三、自动添加类文件到项目" class="headerlink" title="三、自动添加类文件到项目"></a>三、自动添加类文件到项目</h4></blockquote>
<p><strong>目标</strong>：将通过Ruby 脚本来生成类文件自动添加到项目。（手动添加也可以，但是我想偷点懒）</p>
<h5 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h5><ul>
<li><p>在Xcode项目中，我们手动添加和删除类文件，其实是在修改<strong>project.pbxproj</strong>文件。</p>
</li>
<li><p>Cocoapods提供了一个可以创建和修改 Xcode 工程文件的工具：<a href="https://github.com/CocoaPods/Xcodeproj" target="_blank" rel="noopener">Xcodeproj</a>，该工具中有<strong>Ruby 的开源库xcodeproj</strong>，可以帮助我们实现<strong>自动添加类文件到项目</strong>。（Cocoapods也是通过它自动添加文件到到项目）</p>
</li>
<li><p>我们可以通过<strong>安装Cocoapods实现安装ruby的xcodeproj库</strong>；当然也可以<strong>直接安装</strong>，执行命令gem install xcodeproj即可。无论是选择哪种方案，都需要注意使用正确的ruby源。</p>
</li>
<li><p>因为一直在使用<strong>Cocoapods</strong>，恰好在升级系统到<strong>macOS 10.13</strong>后，发现使用xcodeproj库有问题，原因是Cocoapods版本过旧，需要升级Cocoapods，升级过程中，要注意现在“taobao Gems 源已停止维护”，使用 ruby-china 提供镜像服务。下面以安装Cocoapods为例：</p>
<pre><code>sudo gem update --system    //升级gem，很有必要

gem sources --remove https://rubygems.org/
gem sources --remove https://ruby.taobao.org/       //如果安装了淘宝的镜像
gem sources -a https://gems.ruby-china.org/          //保证只使用ruby-china镜像
gem sources -l                                       //查看更换源结果，保证只有ruby-china镜像

sudo gem uninstall cocoapods                           //如果有旧的CocoaPods，先卸载
sudo gem install -n /usr/local/bin cocoapods          //安装最新的
</code></pre></li>
</ul>
<h5 id="2、主要代码实现"><a href="#2、主要代码实现" class="headerlink" title="2、主要代码实现"></a>2、主要代码实现</h5><pre><code>#添加类文件到项目
def add_files_to_projects(oc_file_paths,group_path)

  #1、获取.xcodeproj
  xcodeproj_path = File.expand_path File.join(__dir__, &quot;../&quot;, &quot;QSRunScriptDemo.xcodeproj&quot;)
  project = Xcodeproj::Project.open(xcodeproj_path)

  #2、获取target
  target = project.targets.first

  #3、创建group
  generator_group = project.main_group.find_subpath(group_path, true)
  generator_group.clear
  generator_group.set_source_tree(&apos;SOURCE_ROOT&apos;)

  #4、向group中添加文件
  file_refs = []
  oc_file_paths.each do |f|
      unless generator_group.find_file_by_path(f)
          file_ref = generator_group.new_reference(f)
          file_refs &lt;&lt; file_ref
      end
  end
  #5、将文件加入 Build Phases
  target.add_file_references(file_refs)

  #6、保存 project
  project.save

end
</code></pre><blockquote>
<h4 id="四、自动生成Objective-C代码实例"><a href="#四、自动生成Objective-C代码实例" class="headerlink" title="四、自动生成Objective-C代码实例"></a>四、自动生成Objective-C代码实例</h4></blockquote>
<p>#####1、输入：txt模板（文件名user_model.txt） #####</p>
<pre><code>varchar,name
int,age
varchar,address
varchar,password
</code></pre><p><strong>说明</strong>：文件名和OC类名相关，文本内每一行描述属性类型和名称。</p>
<p>#####2、执行脚本（自动执行） #####</p>
<p>在start.sh文件中输入执行脚本命令</p>
<pre><code>ruby generator_model/model_generator.rb
</code></pre><p>#####3、输出：OC类文件及代码 #####</p>
<pre><code>// QSUserModel.h文件
// Generated by Ruby.  DO NOT EDIT!
//  Copyright © 2017年 shaoqing. All rights reserved.

#import &lt;UIKit/UIKit.h&gt;

@interface QSUserModel : NSObject

@property (nonatomic,copy)NSString *name;
@property (nonatomic,assign)NSInteger age;
@property (nonatomic,copy)NSString *address;
@property (nonatomic,copy)NSString *password;

@end

//QSUserModel.m文件
// Generated by Ruby.  DO NOT EDIT!
//  Copyright © 2017年 shaoqing. All rights reserved.

#import &quot;QSUserModel.h&quot;
@implementation QSUserModel

@end
</code></pre><p><strong>说明</strong>：类名QSUserModel，根据模板文件名而来；属性定义根据模板内容而来。</p>
<p>#####4、总结 #####</p>
<ul>
<li><p>通过ruby脚本，实现了根据模板实现了<strong>自动生成Model类</strong>和<strong>自动添加文件到项目</strong>。</p>
</li>
<li><p>在iOS项目中，脚本生成代码这类做法，不单单是帮助iOS开发减少重复工作量，从更广的范围来看，其实是为了让跨团队，跨部门的合作更加高效，更好地达成目标。</p>
</li>
<li><p>本例只是一个简单例子，主要为了说清思路，设计比较粗糙；在实际工程中，模板中需要定义的信息很多，txt并不是一个很好的选择；ruby脚本还需要更多完善的地方。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://buaa0300/nanhuacoder.com/2018/01/13/iOS-AppImageOptimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="南华coder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南华coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/iOS-AppImageOptimize/" itemprop="url">iOS图片优化小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T19:40:12+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/App优化/" itemprop="url" rel="index">
                    <span itemprop="name">App优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,278 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4 分
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>根据我自己的经验，说一下我对图片优化的理解。</p>
<h4 id="一、他山之石"><a href="#一、他山之石" class="headerlink" title="一、他山之石"></a>一、他山之石</h4><h5 id="1、图片的加载步骤"><a href="#1、图片的加载步骤" class="headerlink" title="1、图片的加载步骤"></a>1、图片的加载步骤</h5><p>从磁盘中加载图片，并通过UIImageVIew显示在屏幕上，需要经过以下步骤：</p>
<pre><code>1、从磁盘拷贝数据到内核缓冲区
2、从内核缓冲区复制数据到用户空间
3、生成UIImageView，把图像数据赋值给UIImageView
4、如果图像数据为未解码的PNG/JPG，解码为位图数据
5、CATransaction捕获到UIImageView layer树的变化
6、主线程Runloop提交CATransaction，开始进行图像渲染
  6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。
  6.2 GPU处理位图数据，进行渲染。
</code></pre><p><strong>说明1</strong>：这部分摘抄自<a href="http://blog.cnbang.net/tech/2578/" target="_blank" rel="noopener">iOS图片加载速度极限优化—FastImageCache解析</a>，它介绍了<a href="https://github.com/path/FastImageCache" target="_blank" rel="noopener">FastImageCache</a>极限优化的手段。</p>
<h5 id="2、FastImageCache的优化手段"><a href="#2、FastImageCache的优化手段" class="headerlink" title="2、FastImageCache的优化手段"></a>2、FastImageCache的优化手段</h5><p><em>优化有三</em>：</p>
<ul>
<li><p>使用<strong>mmap这样的内存映射方案</strong>，将文件映射进内存；比普通的<strong>read()读取</strong>少了一次内存拷贝（内核缓存区拷贝到用户内存空间）</p>
</li>
<li><p><strong>图像子线程解码</strong>，将耗时的解码工作从主线程移到了子线程; <strong>缓存解码后的位图数据</strong>到磁盘，避免重复解码。</p>
</li>
<li><p><strong>字节对齐</strong>；生成字节对齐的数据，防止CoreAnimation在渲染时再拷贝一份数据。</p>
</li>
</ul>
<h5 id="3、FastImageCache的缺点"><a href="#3、FastImageCache的缺点" class="headerlink" title="3、FastImageCache的缺点"></a>3、FastImageCache的缺点</h5><p><em>缺点有三</em>：</p>
<ul>
<li><p>位图数据缓要保存在磁盘，<strong>占据空间大</strong>。</p>
</li>
<li><p><strong>接口不友好</strong>，需预定义好缓存的图像尺寸。FastImageCache无法像SDWebImage那样无缝接入UIImageView。</p>
</li>
<li><p>FastImageCache库已经快4年没有新的版本更新，很多项目使用SDWebImage这样的活跃库。</p>
</li>
</ul>
<h5 id="4、我的拙见"><a href="#4、我的拙见" class="headerlink" title="4、我的拙见"></a>4、我的拙见</h5><ul>
<li><p>在项目中，为了优化，直接颠覆原来的，风险很大；但是借鉴其他好的方法，对原有的进行优化，是个值得做的事情。</p>
</li>
<li><p>图片的优化，绕不开图片的<strong>解码</strong>、<strong>缓存</strong>和<strong>下载</strong>三大件。</p>
</li>
<li><p>优化工作需要考虑 <strong>低代价高回报</strong> 这件事。</p>
</li>
</ul>
<h4 id="二、本地图片加载的优化"><a href="#二、本地图片加载的优化" class="headerlink" title="二、本地图片加载的优化"></a>二、本地图片加载的优化</h4><h5 id="1、优化的目的"><a href="#1、优化的目的" class="headerlink" title="1、优化的目的"></a>1、优化的目的</h5><p><em>目的有三：</em></p>
<ul>
<li><p><strong>减少App包的大小</strong>；图片体积的暴增最大原因之一；可能是新业务引入大量图片资源。</p>
</li>
<li><p><strong>提高图片加载的性能</strong>；使用UIImage的方法imageNamed:方法加载图片，<strong>默认在主线程解码</strong>会拖累你的APP性能。可以考虑<strong>将图片的解码放在子线程</strong>。</p>
</li>
<li><p><strong>图像不失真</strong>；JPG或PNG格式的图片展示时，可能会失真。PNG比JPG好一些。</p>
</li>
</ul>
<h5 id="2、优化手段"><a href="#2、优化手段" class="headerlink" title="2、优化手段"></a>2、优化手段</h5><p><em>手段有三：</em></p>
<ul>
<li><p><strong>PNG图片虽好不作为唯一的选择</strong>，本地图片可以使用其他方案代替。如<strong>矢量图PDF</strong>、<strong>ICONFONT</strong>、<strong>CG绘制</strong>。（像运营类色彩比较丰富的图片，优先使用PNG图片）</p>
</li>
<li><p><strong>缓存的使用</strong>。无论是图片的解码，还是绘制CG图片，都是个耗时耗CPU的操作，将这些结果缓存(到内存中)下来，避免重复解码和绘制，是个好的选择，这里推荐<a href="https://github.com/ibireme/YYCache" target="_blank" rel="noopener">YYCache</a>这样的方案（线程安全、LRU淘汰算法）。</p>
</li>
<li><p><strong>及时清理旧的图片资源</strong>。使用类似<a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a> 清理旧的图片文件。</p>
<p><strong>说明</strong>：导入项目中的图片记得压缩。</p>
</li>
</ul>
<h4 id="三、网络图片的优化"><a href="#三、网络图片的优化" class="headerlink" title="三、网络图片的优化"></a>三、网络图片的优化</h4><p>相比较本地图片，它面临复杂的网络环境、复杂的图片来源。</p>
<h5 id="1、优化目的"><a href="#1、优化目的" class="headerlink" title="1、优化目的"></a>1、优化目的</h5><p><em>目的有三：</em></p>
<ul>
<li><p><strong>异步下载</strong>，不阻塞主线程操作；</p>
</li>
<li><p>图片<strong>快速加载显示</strong>；</p>
</li>
<li><p><strong>良好的接口</strong>，让使用者用的<em>开心</em> ；（不必关心复杂的网络环境、图片加载性能等）</p>
</li>
</ul>
<h5 id="2、优化手段-1"><a href="#2、优化手段-1" class="headerlink" title="2、优化手段"></a>2、优化手段</h5><p><em>手段有三：</em></p>
<ul>
<li><p><strong>使用优秀的第三方库</strong>，如<a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>。关于SDWebImage我在简书上写了文章<a href="https://www.jianshu.com/p/f3cb4ea0d14c" target="_blank" rel="noopener">SDWebImage源码理解</a>,可以看看。</p>
</li>
<li><p><strong>使用压缩比高，质量小，失真小的图片格式</strong>，如Google的Webp、Tencent的SharpP格式，这两图片文件小，很适合在网络中传输，消耗的流量少，下载快,解码快（SharpP和webp的编码慢）。</p>
</li>
<li><p><strong>结合业务需要优化图片</strong>；网络环境获取图片比较复杂，且难以预测；对下载下来的图片进行<strong>裁剪</strong>（按显示的<em>目标大小</em>、<em>是否需要圆角</em>、<em>描边</em>、<em>阴影</em>等），能很大程度上避免<strong>图片像素不对齐</strong>(图片大小和显示大小不一致)、<strong>像素混合</strong>（图层透明）、<strong>离屏渲染</strong>（圆角和阴影等）等问题。</p>
<p>  <strong>参考</strong>：<a href="https://cloud.tencent.com/developer/article/1004404" target="_blank" rel="noopener">图片流量节省大杀器：基于 CDN 的 sharpP 自适应图片技术实践</a></p>
</li>
</ul>
<h5 id="3、一些小的优化手段"><a href="#3、一些小的优化手段" class="headerlink" title="3、一些小的优化手段"></a>3、一些小的优化手段</h5><ul>
<li><p>要从网络中获取的<strong>重要图片</strong>（如广告、运营相关的图片），要<strong>先校验图片的完整性</strong>，校验通过才去真正处理并显示，否则不处理。</p>
</li>
<li><p>纯显示的视图，CALayer代替UIImageVIew，可以减少GPU计算（去透明/像素对齐）</p>
</li>
</ul>
<h4 id="End"><a href="#End" class="headerlink" title="End"></a>End</h4><ul>
<li>这篇文章算是对之前写的 <a href="https://www.jianshu.com/p/a38a7c7bccbb" target="_blank" rel="noopener">网络图片的优化显示</a> 和 <a href="https://www.jianshu.com/p/26402bc4ddac" target="_blank" rel="noopener">iOS中本地图片的缩放、裁剪和压缩</a>的<strong>补充</strong>和<strong>扩展</strong>吧。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="南华coder" />
            
              <p class="site-author-name" itemprop="name">南华coder</p>
              <p class="site-description motion-element" itemprop="description">于无声处听惊雷,于无色处见繁花</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南华coder</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">75.3k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
